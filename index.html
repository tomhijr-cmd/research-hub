<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Fieldwork ‚Äî HRI Paper Feed</title>

  <!-- ‚îÄ‚îÄ Google Fonts: Lora (serif headings) + Inter (UI / body text) ‚îÄ‚îÄ -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Lora:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">

  <!-- ‚îÄ‚îÄ Favicon: Fieldwork signal-mark ‚îÄ‚îÄ -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle cx='11' cy='16' r='5' fill='%231A5F6E'/%3E%3Cline x1='17' y1='16' x2='23' y2='16' stroke='%231A5F6E' stroke-width='2.5' stroke-linecap='round'/%3E%3Cline x1='16.5' y1='12.5' x2='21.5' y2='8' stroke='%231A5F6E' stroke-width='2.5' stroke-linecap='round'/%3E%3Cline x1='16.5' y1='19.5' x2='21.5' y2='24' stroke='%231A5F6E' stroke-width='2.5' stroke-linecap='round'/%3E%3C/svg%3E">

  <!-- ‚îÄ‚îÄ Firebase SDK (compat mode = no bundler needed, works in plain HTML) ‚îÄ‚îÄ -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

  <style>
    /* ‚îÄ‚îÄ CSS Custom Properties (theme variables) ‚îÄ‚îÄ */
    :root {
      --bg:           #f5f2ed;
      --surface:      #ffffff;
      --border:       #e2ddd5;
      --text:         #18181b;
      --text-muted:   #6b6b74;
      --accent:       #1a5f6e;
      --accent-light: #e6f3f5;
      --tag-bg:       #eef3f4;
      --tag-off:      #f0efed;
      --tag-off-text: #9a9a9a;
      --score-high:   #2d7a3a;
      --score-mid:    #c17d2e;
      --score-low:    #9a9aa8;
      --shadow:       0 1px 3px rgba(0,0,0,0.08);
      --radius:       6px;
      --font-serif:   'Lora', Georgia, 'Times New Roman', serif;
      --font-sans:    'Inter', system-ui, -apple-system, sans-serif;
    }

    /* Dark mode variables */
    [data-theme="dark"] {
      --bg:           #111618;
      --surface:      #1a2224;
      --border:       #2a3a3f;
      --text:         #f0ede8;
      --text-muted:   #8a8a98;
      --accent:       #4aa8bc;
      --accent-light: #0e2428;
      --tag-bg:       #1a2e32;
      --tag-off:      #1e2a2d;
      --tag-off-text: #666;
      --score-high:   #5cb87a;
      --score-mid:    #d4943a;
      --score-low:    #6b6b7a;
      --shadow:       0 1px 4px rgba(0,0,0,0.4);
    }

    /* ‚îÄ‚îÄ Reset & Base ‚îÄ‚îÄ */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: var(--font-sans);
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
      min-height: 100vh;
      transition: background 0.2s, color 0.2s;
    }

    /* ‚îÄ‚îÄ Layout ‚îÄ‚îÄ */
    .app-wrapper {
      max-width: 860px;
      margin: 0 auto;
      padding: 0 16px 60px;
    }

    /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 24px 0 20px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 24px;
      gap: 12px;
      flex-wrap: wrap;
    }

    .header-title {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .brand-mark {
      flex-shrink: 0;
      color: var(--accent);
    }
    .brand-wordmark h1 {
      font-family: var(--font-serif);
      font-size: 1.45rem;
      font-weight: 600;
      letter-spacing: -0.01em;
      color: var(--text);
      margin: 0;
    }
    .brand-wordmark p {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin: 2px 0 0;
      letter-spacing: 0.01em;
    }

    .header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    /* ‚îÄ‚îÄ Buttons ‚îÄ‚îÄ */
    button {
      cursor: pointer;
      font-family: var(--font-sans);
      border: none;
      border-radius: var(--radius);
      transition: opacity 0.15s, background 0.15s;
    }

    button:hover { opacity: 0.85; }
    button:active { opacity: 0.7; }

    .btn-primary {
      background: var(--accent);
      color: #fff;
      padding: 7px 14px;
      font-size: 0.85rem;
    }

    .btn-secondary {
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      padding: 7px 14px;
      font-size: 0.85rem;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .btn-icon {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 7px 10px;
      font-size: 1rem;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    /* Plain text link button */
    .btn-text {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.8rem;
      padding: 4px 6px;
      text-decoration: underline;
      white-space: nowrap;
    }

    /* Spinning animation for refresh button when loading */
    .btn-spinning { animation: spin 0.8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* ‚îÄ‚îÄ Auth area styles ‚îÄ‚îÄ */

    /* Google sign-in button */
    .btn-signin {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 6px 12px;
      font-size: 0.82rem;
      font-weight: 500;
      white-space: nowrap;
      box-shadow: var(--shadow);
    }

    .btn-signin svg {
      flex-shrink: 0;
    }

    /* Signed-in user display */
    .auth-user {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .user-avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      object-fit: cover;
      border: 1px solid var(--border);
      flex-shrink: 0;
    }

    /* Fallback avatar when no photo */
    .user-avatar-fallback {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: var(--accent);
      color: #fff;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .user-name {
      font-size: 0.82rem;
      color: var(--text-muted);
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .btn-signout {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 0.75rem;
      text-decoration: underline;
      padding: 0;
      cursor: pointer;
    }

    .btn-signout:hover { color: var(--text); opacity: 1; }

    /* Hint shown in settings panel when signed out */
    .signin-notice {
      font-style: italic;
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-bottom: 14px;
    }

    /* ‚îÄ‚îÄ Settings Panel ‚îÄ‚îÄ */
    /* ‚îÄ‚îÄ Side panels (My Topics + Feed Insights) ‚îÄ‚îÄ */
    .side-panel {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      margin-bottom: 24px;
      box-shadow: var(--shadow);
      display: none; /* hidden by default ‚Äî toggled via .open class */
      overflow: hidden;
    }
    .side-panel.open { display: block; }

    .side-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 20px 12px;
      border-bottom: 1px solid var(--border);
    }
    .side-panel-header h2 {
      font-family: var(--font-serif);
      font-size: 1rem;
      font-weight: normal;
      margin: 0;
      color: var(--text);
    }
    .panel-close-btn {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 0.9rem;
      color: var(--text-muted);
      padding: 2px 4px;
      border-radius: 4px;
      line-height: 1;
      transition: color 0.15s;
    }
    .panel-close-btn:hover { color: var(--text); }

    .side-panel-body {
      padding: 16px 20px 20px;
    }
    .side-panel-hint {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin: 0 0 14px;
      line-height: 1.5;
    }

    /* ‚îÄ‚îÄ Reading List button: active state when RL view is open ‚îÄ‚îÄ */
    #readingListToggle.active {
      background: var(--accent-light);
      border-color: var(--accent);
      color: var(--accent);
    }

    /* ‚îÄ‚îÄ Insights panel: ‚ú¶ button dot indicator ‚îÄ‚îÄ */
    #insightsToggle {
      position: relative;
    }
    #insightsToggle.has-insights::after {
      content: '';
      position: absolute;
      top: 5px;
      right: 5px;
      width: 6px;
      height: 6px;
      background: var(--accent);
      border-radius: 50%;
    }

    /* ‚îÄ‚îÄ Feed Insights panel content ‚îÄ‚îÄ */
    .insights-section {
      margin-bottom: 18px;
    }
    .insights-section-title {
      font-size: 0.72rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-muted);
      margin: 0 0 8px;
    }
    .insights-hint {
      font-size: 0.74rem;
      color: var(--text-muted);
      margin: 0 0 8px;
    }
    .insights-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    /* Read-only insight chips ‚Äî no interaction affordance */
    .insights-chip {
      background: var(--tag-off);
      color: var(--tag-off-text);
      border-radius: 10px;
      padding: 2px 10px;
      font-size: 0.75rem;
      cursor: default;
      user-select: none;
    }
    .insights-empty {
      font-size: 0.78rem;
      color: var(--text-muted);
      font-style: italic;
    }
    .insights-divider {
      border: none;
      border-top: 1px solid var(--border);
      margin: 18px 0 16px;
    }
    .insights-reset-area { }

    /* Reset button ‚Äî subtle, destructive styling only on confirm */
    .btn-reset-profile {
      background: none;
      border: 1px solid var(--border);
      color: var(--text-muted);
      border-radius: var(--radius);
      padding: 6px 12px;
      font-size: 0.78rem;
      cursor: pointer;
      transition: color 0.15s, border-color 0.15s;
    }
    .btn-reset-profile:hover {
      color: var(--text);
      border-color: var(--text-muted);
    }
    .reset-warning {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin: 0 0 10px;
      line-height: 1.5;
    }
    .reset-confirm-btns {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .btn-danger {
      background: #c0392b;
      color: #fff;
      border: none;
      border-radius: var(--radius);
      padding: 6px 14px;
      font-size: 0.82rem;
      cursor: pointer;
      transition: background 0.15s;
    }
    .btn-danger:hover { background: #a93226; }

    /* ‚îÄ‚îÄ Toast notifications ‚îÄ‚îÄ */
    .toast-container {
      position: fixed;
      bottom: 28px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      pointer-events: none;
    }
    .toast {
      background: var(--text);
      color: var(--surface);
      padding: 8px 20px;
      border-radius: 20px;
      font-size: 0.82rem;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0,0,0,0.18);
    }
    .toast--visible {
      opacity: 1;
      transform: translateY(0);
    }
    /* Undo toast variant */
    .toast--with-undo {
      display: flex;
      align-items: center;
      gap: 10px;
      pointer-events: all; /* allow clicking undo */
    }
    .toast-undo-btn {
      background: none;
      border: 1px solid rgba(255,255,255,0.4);
      color: inherit;
      border-radius: 10px;
      padding: 2px 8px;
      font-size: 0.78rem;
      cursor: pointer;
      flex-shrink: 0;
    }
    .toast-undo-btn:hover { background: rgba(255,255,255,0.15); }

    /* ‚îÄ‚îÄ Reading List ‚îÄ‚îÄ */
    .rl-badge {
      display: inline-block;
      background: var(--accent);
      color: #fff;
      border-radius: 10px;
      font-size: 0.68rem;
      padding: 1px 6px;
      margin-left: 4px;
      vertical-align: middle;
      line-height: 1.5;
    }
    #readingListView { margin-bottom: 24px; }
    .rl-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    .rl-header h2 {
      font-family: var(--font-serif);
      font-size: 1.1rem;
      font-weight: normal;
      margin: 0;
    }
    .rl-count { color: var(--text-muted); font-size: 0.85rem; font-family: var(--font-sans); }
    .rl-controls { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    .rl-sort-select {
      font-size: 0.8rem;
      padding: 5px 8px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--surface);
      color: var(--text);
      cursor: pointer;
    }
    .rl-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 14px 18px;
      margin-bottom: 10px;
      box-shadow: var(--shadow);
    }
    .rl-card-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 4px;
    }
    .rl-title {
      font-size: 0.95rem;
      font-weight: 600;
      line-height: 1.4;
      margin: 0;
      flex: 1;
    }
    .rl-title a { color: var(--accent); text-decoration: none; }
    .rl-title a:hover { text-decoration: underline; }
    .rl-card-badges { display: flex; gap: 6px; align-items: center; flex-shrink: 0; }
    .rl-meta { font-size: 0.78rem; color: var(--text-muted); margin-bottom: 6px; }
    .rl-abstract {
      font-size: 0.82rem;
      color: var(--text-muted);
      line-height: 1.55;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      cursor: pointer;
      margin-bottom: 8px;
    }
    .rl-abstract.expanded {
      display: block;
      -webkit-line-clamp: unset;
      overflow: visible;
    }
    .rl-card-actions {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 6px;
    }
    .rl-added-date { font-size: 0.72rem; color: var(--text-muted); }
    .rl-remove-btn {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 0.78rem;
      padding: 0;
      margin-left: auto;
    }
    .rl-remove-btn:hover { color: var(--text); }
    .rl-empty-state {
      text-align: center;
      padding: 60px 0;
      color: var(--text-muted);
    }
    .rl-empty-state .icon { font-size: 2.5rem; margin-bottom: 12px; }
    .rl-empty-state p { font-size: 0.9rem; margin-bottom: 8px; }
    .rl-migration-notice {
      background: var(--accent-light);
      color: var(--accent);
      border: 1px solid var(--accent);
      border-radius: var(--radius);
      padding: 8px 14px;
      font-size: 0.8rem;
      margin-bottom: 14px;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
    }

    /* Keyword chips container */
    .keyword-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
      min-height: 36px;
    }

    /* Each keyword is a toggle chip */
    .keyword-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: var(--tag-bg);
      color: var(--accent);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 4px 10px 4px 12px;
      font-size: 0.8rem;
      cursor: pointer;
      user-select: none;
      transition: background 0.15s, color 0.15s;
    }

    /* Disabled/off chip style */
    .keyword-chip.off {
      background: var(--tag-off);
      color: var(--tag-off-text);
      border-color: var(--border);
      text-decoration: line-through;
    }

    /* The √ó remove button inside each chip */
    .keyword-chip .remove-btn {
      background: none;
      border: none;
      color: inherit;
      font-size: 1rem;
      line-height: 1;
      padding: 0 0 0 2px;
      opacity: 0.5;
      cursor: pointer;
    }

    .keyword-chip .remove-btn:hover { opacity: 1; }

    /* Add keyword input row */
    .add-keyword-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .add-keyword-row input {
      flex: 1;
      font-family: var(--font-sans);
      font-size: 0.85rem;
      padding: 7px 12px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--bg);
      color: var(--text);
      outline: none;
    }

    .add-keyword-row input:focus { border-color: var(--accent); }

    /* ‚îÄ‚îÄ Active keyword tags shown below header ‚îÄ‚îÄ */
    .active-keywords-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 16px;
      align-items: center;
    }

    .active-keywords-bar .bar-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-right: 4px;
    }

    .active-kw-tag {
      background: var(--accent-light);
      color: var(--accent);
      border-radius: 12px;
      padding: 2px 10px;
      font-size: 0.75rem;
    }

    /* ‚îÄ‚îÄ Search bar ‚îÄ‚îÄ */
    .search-bar-container {
      margin-bottom: 12px;
    }

    .search-input-wrapper {
      position: relative;
      display: flex;
      align-items: center;
    }

    .search-icon {
      position: absolute;
      left: 12px;
      font-size: 0.9rem;
      pointer-events: none;
      color: var(--text-muted);
    }

    .search-input {
      width: 100%;
      font-family: var(--font-sans);
      font-size: 0.9rem;
      padding: 9px 36px 9px 36px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--surface);
      color: var(--text);
      outline: none;
      transition: border-color 0.15s;
    }

    .search-input:focus { border-color: var(--accent); }

    .search-clear-btn {
      position: absolute;
      right: 8px;
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 0.85rem;
      padding: 4px 6px;
      line-height: 1;
      cursor: pointer;
    }

    .search-clear-btn:hover { color: var(--text); opacity: 1; }

    /* Search highlight inside paper cards */
    mark.search-highlight {
      background: #fff176;
      color: inherit;
      border-radius: 2px;
      padding: 0 1px;
    }

    [data-theme="dark"] mark.search-highlight {
      background: #7a6d00;
    }

    /* ‚îÄ‚îÄ Filter panel ‚îÄ‚îÄ */
    .filter-panel {
      margin-bottom: 16px;
    }

    .filter-panel-header {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .filter-toggle-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }

    /* Small badge showing how many filters are active */
    .filter-active-count {
      background: var(--accent);
      color: #fff;
      border-radius: 10px;
      font-size: 0.7rem;
      font-weight: 600;
      padding: 1px 6px;
      min-width: 18px;
      text-align: center;
    }

    /* Active filter tag pills in the header row */
    .active-filter-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      flex: 1;
    }

    .filter-tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: var(--accent-light);
      color: var(--accent);
      border: 1px solid var(--accent);
      border-radius: 12px;
      padding: 2px 8px 2px 10px;
      font-size: 0.75rem;
      white-space: nowrap;
    }

    .filter-tag-remove {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.8rem;
      padding: 0;
      line-height: 1;
      cursor: pointer;
      opacity: 0.6;
    }

    .filter-tag-remove:hover { opacity: 1; }

    /* The collapsible body of the filter panel */
    .filter-panel-body {
      margin-top: 12px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    /* Common filters section ‚Äî horizontally wrapping */
    .filter-common-section {
      display: flex;
      flex-wrap: wrap;
      gap: 16px 24px;
    }

    /* Divider + toggle button for advanced filters */
    .filter-advanced-toggle-row {
      width: 100%;
      padding-top: 12px;
      margin-top: 12px;
      border-top: 1px solid var(--border);
    }
    #filterAdvancedToggle {
      font-size: 0.78rem;
      color: var(--text-muted);
      padding: 0;
      text-decoration: none;
    }
    #filterAdvancedToggle:hover { color: var(--text); }

    /* Advanced filters section ‚Äî same horizontal wrap layout */
    .filter-advanced-section {
      flex-wrap: wrap;
      gap: 16px 24px;
      padding-top: 12px;
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 140px;
    }

    .filter-group-label {
      font-size: 0.72rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
    }

    .filter-check-row,
    .filter-radio-row {
      display: flex;
      flex-wrap: wrap;
      gap: 4px 6px;
    }

    /* Individual filter option labels */
    .filter-option-label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      padding: 3px 8px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--bg);
      color: var(--text);
      user-select: none;
      white-space: nowrap;
      transition: background 0.12s, border-color 0.12s;
    }

    .filter-option-label input[type="checkbox"],
    .filter-option-label input[type="radio"] {
      display: none; /* we style the label itself as the control */
    }

    .filter-option-label:has(input:checked) {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    .sort-select {
      font-family: var(--font-sans);
      font-size: 0.82rem;
      padding: 5px 8px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      outline: none;
    }

    .sort-select:focus { border-color: var(--accent); }

    /* ‚îÄ‚îÄ Status / error messages ‚îÄ‚îÄ */
    .status-bar {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-bottom: 16px;
      min-height: 20px;
    }

    .status-bar.error { color: #c0392b; }

    /* ‚îÄ‚îÄ Feed header ‚îÄ‚îÄ */
    .feed-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 0.8rem;
    }

    .feed-header-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .feed-header-right {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--text-muted);
    }

    .feed-count {
      font-weight: 600;
      color: var(--text);
    }

    /* Unread badge */
    .unread-badge {
      background: var(--accent);
      color: #fff;
      border-radius: 10px;
      font-size: 0.7rem;
      font-weight: 600;
      padding: 1px 7px;
    }

    .feed-last-refreshed {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    /* "Show hidden" toggle label */
    .toggle-label {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      cursor: pointer;
      user-select: none;
      color: var(--text-muted);
    }

    .toggle-label input[type="checkbox"] {
      cursor: pointer;
      accent-color: var(--accent);
    }

    /* ‚îÄ‚îÄ Paper Feed ‚îÄ‚îÄ */
    .paper-feed {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    /* Individual paper card */
    .paper-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px 22px;
      box-shadow: var(--shadow);
      transition: box-shadow 0.15s, opacity 0.35s, transform 0.35s;
    }

    .paper-card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.12); }

    /* Fading out on hide */
    .paper-card--fading {
      opacity: 0;
      transform: translateY(-6px);
      pointer-events: none;
    }

    .paper-card-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 8px;
    }

    .paper-title {
      font-family: var(--font-serif);
      font-size: 1.05rem;
      line-height: 1.4;
      color: var(--text);
      flex: 1;
    }

    .paper-title a {
      color: inherit;
      text-decoration: none;
    }

    .paper-title a:hover { color: var(--accent); text-decoration: underline; }

    /* Score badge */
    .score-badge {
      flex-shrink: 0;
      font-size: 0.75rem;
      font-weight: 600;
      padding: 3px 8px;
      border-radius: 12px;
      background: var(--tag-bg);
      color: var(--score-low);
      white-space: nowrap;
    }

    .score-badge.high { color: var(--score-high); background: #eef6ef; }
    .score-badge.mid  { color: var(--score-mid);  background: #f6f2ea; }

    [data-theme="dark"] .score-badge.high { background: #1a2e1c; }
    [data-theme="dark"] .score-badge.mid  { background: #2c2718; }

    /* ‚îÄ‚îÄ Score explainer first-visit callout ‚îÄ‚îÄ */
    .paper-card-badges { position: relative; }
    .score-explainer-callout {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      background: var(--surface);
      border: 1px solid var(--accent);
      border-radius: var(--radius);
      padding: 8px 12px;
      font-size: 0.78rem;
      color: var(--text);
      white-space: nowrap;
      box-shadow: var(--shadow);
      z-index: 50;
      line-height: 1.5;
    }
    /* Upward arrow */
    .score-explainer-callout::before {
      content: '';
      position: absolute;
      bottom: 100%;
      right: 14px;
      border: 5px solid transparent;
      border-bottom-color: var(--accent);
    }
    .score-explainer-dismiss {
      display: block;
      margin-top: 6px;
      font-size: 0.72rem;
      color: var(--accent);
      text-decoration: underline;
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
      font-family: inherit;
    }

    .paper-meta {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-bottom: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 0 4px;
      align-items: center;
    }

    /* Citation count in meta row (legacy ‚Äî kept for backward compat) */
    .citation-count {
      margin-left: 4px;
      color: var(--text-muted);
    }

    /* ‚îÄ‚îÄ Author link + count ‚îÄ‚îÄ */
    .author-link {
      color: var(--text-muted);
      text-decoration: none;
    }
    .author-link:hover { color: var(--accent); text-decoration: underline; }
    .author-count { font-size: 0.72rem; color: var(--text-muted); }

    /* ‚îÄ‚îÄ Open Access badge + PDF link ‚îÄ‚îÄ */
    .oa-badge { font-size: 0.82rem; vertical-align: middle; }
    .oa-badge.locked { opacity: 0.45; }
    .pdf-link {
      color: var(--accent);
      text-decoration: none;
      font-size: 0.75rem;
      margin-left: 2px;
    }
    .pdf-link:hover { text-decoration: underline; }

    /* ‚îÄ‚îÄ Rich metrics row ‚îÄ‚îÄ */
    .paper-metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 4px 12px;
      margin: 8px 0 4px;
      font-size: 0.75rem;
      color: var(--text-muted);
      align-items: center;
    }

    .metric { display: inline-flex; align-items: center; gap: 3px; }

    /* Clickable metric (citation count, ref count) */
    .metric-link {
      text-decoration: none;
      cursor: pointer;
      border-bottom: 1px dashed currentColor;
      transition: opacity 0.12s;
    }
    .metric-link:hover { opacity: 0.75; }

    /* Citation count colour tiers */
    .cite-grey  { color: var(--text-muted); }
    .cite-blue  { color: #4a90d9; font-weight: 500; }
    .cite-green { color: var(--score-high); font-weight: 500; }
    .cite-gold  { color: #c9930a; font-weight: 700; }

    [data-theme="dark"] .cite-blue  { color: #6aabda; }
    [data-theme="dark"] .cite-gold  { color: #e0a800; }

    /* Citation velocity */
    .velocity-trending { color: #cc3344; font-weight: 600; }
    .velocity-growing  { color: var(--score-high); font-weight: 500; }
    .velocity-stable   { color: var(--text-muted); }

    /* Highly influential badge */
    .highly-influential-badge {
      background: #fff3cd;
      color: #7d5a00;
      border-radius: 10px;
      padding: 1px 8px;
      font-weight: 600;
      font-size: 0.72rem;
    }
    [data-theme="dark"] .highly-influential-badge { background: #2d2300; color: #e0a800; }

    /* Venue name ‚Äî italic, truncated */
    .venue-name {
      font-style: italic;
      color: var(--text-muted);
      max-width: 240px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: inline-block;
      vertical-align: middle;
    }

    /* Fields of study tags */
    .field-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin: 4px 0 6px;
    }
    .field-tag {
      background: var(--tag-off);
      color: var(--tag-off-text);
      border-radius: 10px;
      padding: 1px 8px;
      font-size: 0.70rem;
    }

    /* On mobile, hide venue + field tags to save space */
    @media (max-width: 600px) {
      .venue-name { display: none; }
      .field-tags { display: none; }
    }

    /* ‚îÄ‚îÄ Paper card badges (score + wildcard) ‚îÄ‚îÄ */
    .paper-card-badges {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }

    /* ‚îÄ‚îÄ Wildcard / Explore badge ‚îÄ‚îÄ */
    .wildcard-badge {
      display: inline-block;
      background: #e8f4f8;
      color: #1a6a8a;
      border-radius: 10px;
      padding: 2px 8px;
      font-size: 0.70rem;
      font-weight: 600;
      white-space: nowrap;
    }
    [data-theme="dark"] .wildcard-badge {
      background: #0d2d3a;
      color: #5bbcde;
    }
    .paper-card--wildcard {
      border-left: 3px solid #5bbcde;
    }
    /* First-visit one-liner explaining what the Explore badge means */
    .wildcard-first-tip {
      display: inline-block;
      font-size: 0.72rem;
      color: var(--text-muted);
      margin-left: 8px;
      line-height: 1.4;
      vertical-align: middle;
    }
    .wildcard-first-tip button {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 0.85rem;
      cursor: pointer;
      padding: 0 0 0 4px;
      vertical-align: middle;
      line-height: 1;
    }
    .wildcard-first-tip button:hover { color: var(--text); }

    /* ‚îÄ‚îÄ Research Profile section ‚îÄ‚îÄ */
    .research-profile {
      margin-top: 28px;
      border-top: 1px solid var(--border);
      padding-top: 20px;
    }
    .research-profile-inner {}
    .profile-heading {
      font-size: 1rem;
      font-weight: 700;
      margin: 0 0 4px;
      color: var(--text);
    }
    .profile-subtitle {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin: 0 0 16px;
    }
    .profile-section {
      margin-bottom: 16px;
    }
    .profile-section-title {
      font-size: 0.82rem;
      font-weight: 600;
      margin: 0 0 4px;
      color: var(--text);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .profile-hint {
      font-size: 0.74rem;
      color: var(--text-muted);
      margin: 0 0 8px;
    }
    .profile-empty {
      font-size: 0.78rem;
      color: var(--text-muted);
      font-style: italic;
    }
    .profile-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .profile-topic-chip {
      background: var(--tag-off);
      color: var(--tag-off-text);
      border-radius: 10px;
      padding: 2px 10px;
      font-size: 0.75rem;
    }

    /* ‚îÄ‚îÄ Learned keyword chips (with √ó remove button) ‚îÄ‚îÄ */
    .learned-kw-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 4px;
    }
    .learned-kw-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: #e8f0fe;
      color: #1a3a8a;
      border-radius: 10px;
      padding: 2px 8px 2px 10px;
      font-size: 0.75rem;
      font-weight: 500;
    }
    [data-theme="dark"] .learned-kw-chip {
      background: #1a2a4a;
      color: #7aabde;
    }
    .remove-learned-btn {
      background: none;
      border: none;
      cursor: pointer;
      color: inherit;
      opacity: 0.6;
      font-size: 0.85rem;
      line-height: 1;
      padding: 0 1px;
    }
    .remove-learned-btn:hover { opacity: 1; }

    /* ‚îÄ‚îÄ Reset profile button ‚îÄ‚îÄ */
    .btn-reset-profile {
      margin-top: 8px;
      font-size: 0.78rem;
      padding: 5px 12px;
    }

    .paper-abstract {
      font-size: 0.88rem;
      color: var(--text);
      line-height: 1.65;
      /* Show first ~4 lines, expandable */
      display: -webkit-box;
      -webkit-line-clamp: 4;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .paper-abstract.expanded {
      display: block;
      -webkit-line-clamp: unset;
    }

    .expand-btn {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.78rem;
      padding: 4px 0;
      margin-top: 4px;
      cursor: pointer;
      display: inline-block;
    }

    .expand-btn:hover { text-decoration: underline; opacity: 1; }

    /* Keyword match tags under abstract */
    .paper-keyword-tags {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .matched-kw-tag {
      background: var(--accent-light);
      color: var(--accent);
      border-radius: 10px;
      padding: 1px 8px;
      font-size: 0.72rem;
    }

    /* ‚îÄ‚îÄ Paper action buttons ‚îÄ‚îÄ */
    .paper-actions {
      display: flex;
      gap: 6px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
      flex-wrap: wrap;
      position: relative; /* anchor for .signin-popover */
    }

    .action-btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text-muted);
      border-radius: 14px;
      padding: 4px 10px;
      font-size: 0.78rem;
      cursor: pointer;
      transition: background 0.12s, color 0.12s, border-color 0.12s;
      user-select: none;
    }

    .action-btn:hover { opacity: 1; background: var(--tag-bg); color: var(--text); }

    /* Active (toggled on) state */
    .action-btn.active { color: #fff; border-color: transparent; }

    .like-btn.active  { background: #e35; }
    .save-btn.active  { background: var(--score-high); }
    .hide-btn.active  { background: #888; }

    /* Dimmed when signed out ‚Äî pointer-events kept ON so click triggers sign-in popover */
    .action-btn.disabled-action {
      opacity: 0.45;
    }

    /* Hover hint on Save button ‚Äî "Moves to Reading List" */
    .action-btn { position: relative; }
    .action-btn-hint {
      position: absolute;
      bottom: calc(100% + 6px);
      left: 50%;
      transform: translateX(-50%);
      background: var(--text);
      color: var(--surface);
      font-size: 0.72rem;
      padding: 4px 8px;
      border-radius: 4px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s;
      z-index: 10;
    }
    .action-btn:hover .action-btn-hint { opacity: 1; }

    /* Sign-in popover ‚Äî appears above the clicked action button when signed out */
    .signin-popover {
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: var(--text);
      color: var(--surface);
      border-radius: var(--radius);
      padding: 8px 12px;
      font-size: 0.78rem;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      z-index: 200;
      line-height: 1.5;
      animation: fadeInUp 0.15s ease;
    }
    .signin-popover a {
      color: #7ecfe0; /* light teal readable on dark bg */
      text-decoration: underline;
      cursor: pointer;
    }
    /* Downward arrow */
    .signin-popover::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 5px solid transparent;
      border-top-color: var(--text);
    }
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateX(-50%) translateY(4px); }
      to   { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* ‚îÄ‚îÄ Pagination load-more ‚îÄ‚îÄ */
    .feed-load-more {
      text-align: center;
      padding: 8px 0 4px;
    }

    .feed-load-more button {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 9px 28px;
      font-size: 0.85rem;
      border-radius: var(--radius);
    }

    .feed-load-more button:hover { background: var(--tag-bg); opacity: 1; }

    /* ‚îÄ‚îÄ Empty / loading states ‚îÄ‚îÄ */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .empty-state .icon { font-size: 2.5rem; margin-bottom: 12px; }

    /* ‚îÄ‚îÄ Skeleton loading cards ‚îÄ‚îÄ */
    .skeleton-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px 22px;
    }

    .skeleton-line {
      background: var(--border);
      border-radius: 4px;
      margin-bottom: 10px;
      animation: pulse 1.4s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50%       { opacity: 0.5; }
    }

    /* ‚îÄ‚îÄ Footer ‚îÄ‚îÄ */
    footer {
      margin-top: 40px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
      font-size: 0.75rem;
      color: var(--text-muted);
      text-align: center;
    }

    /* ‚îÄ‚îÄ Health / system status bar (bottom of page) ‚îÄ‚îÄ */
    .health-bar {
      margin-top: 12px;
      padding: 6px 12px;
      border-radius: var(--radius);
      font-size: 0.72rem;
      display: inline-block;
      background: var(--tag-bg);
      color: var(--text-muted);
      border: 1px solid var(--border);
    }

    .health-bar.ok    { color: var(--score-high); background: #eef6ef; border-color: #c3e0c7; }
    .health-bar.error { color: #c0392b;           background: #fdf0ef; border-color: #f0c4c0; }

    [data-theme="dark"] .health-bar.ok    { background: #1a2e1c; border-color: #2d4d30; }
    [data-theme="dark"] .health-bar.error { background: #2e1a1a; border-color: #4d2d2d; }

    /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
    @media (max-width: 600px) {
      .header-title h1 { font-size: 1.2rem; }
      .paper-card { padding: 16px; }
      .paper-title { font-size: 0.95rem; }
      .filter-panel-body { gap: 12px; }
    }
  </style>
</head>
<body>

<div class="app-wrapper">

  <!-- ‚îÄ‚îÄ Header ‚îÄ‚îÄ -->
  <header>
    <div class="header-title">
      <!-- Fieldwork signal-mark: circle + asymmetric rays -->
      <svg class="brand-mark" width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <circle cx="11" cy="16" r="5" fill="currentColor"/>
        <line x1="17.2" y1="16" x2="23" y2="16" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"/>
        <line x1="16.8" y1="12.8" x2="21.5" y2="8.5" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"/>
        <line x1="16.8" y1="19.2" x2="21.5" y2="23.5" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"/>
        <line x1="17" y1="11.5" x2="20.5" y2="6.5" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" opacity="0.4"/>
        <line x1="17" y1="20.5" x2="20.5" y2="25.5" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" opacity="0.4"/>
      </svg>
      <div class="brand-wordmark">
        <h1>Fieldwork</h1>
        <p>Every researcher, at the frontier</p>
      </div>
    </div>
    <div class="header-actions">
      <!-- Auth area: shows sign-in button OR avatar + name + sign-out -->
      <div class="auth-area" id="authArea"></div>
      <!-- Refresh button ‚Äî its inner span spins while loading -->
      <button class="btn-icon" id="refreshBtn" title="Fetch new papers" aria-label="Refresh papers">
        <span id="refreshIcon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>
        </span>
      </button>
      <!-- Dark/light mode toggle -->
      <button class="btn-icon" id="themeBtn" title="Toggle dark/light mode" aria-label="Toggle theme">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
      </button>
      <!-- My Topics: keyword management -->
      <button class="btn-secondary" id="keywordsToggle">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
        My Topics
      </button>
      <!-- Feed Insights: signal-mark (matches brand logo) -->
      <button class="btn-secondary" id="insightsToggle" title="Feed Insights ‚Äî what the system learned about you">
        <svg width="14" height="14" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <circle cx="11" cy="16" r="5" fill="currentColor"/>
          <line x1="17.2" y1="16" x2="23" y2="16" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"/>
          <line x1="16.8" y1="12.8" x2="21.5" y2="8.5" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"/>
          <line x1="16.8" y1="19.2" x2="21.5" y2="23.5" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"/>
          <line x1="17" y1="11.5" x2="20.5" y2="6.5" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" opacity="0.4"/>
          <line x1="17" y1="20.5" x2="20.5" y2="25.5" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" opacity="0.4"/>
        </svg>
        Insights
      </button>
      <!-- Reading List: papers liked and queued for reading -->
      <button class="btn-secondary" id="readingListToggle" title="Reading List ‚Äî papers you've saved for later">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>
        Reading List <span class="rl-badge" id="readingListBadge" style="display:none"></span>
      </button>
    </div>
  </header>

  <!-- ‚îÄ‚îÄ Panel 1: My Topics (keyword management) ‚îÄ‚îÄ -->
  <section class="side-panel" id="keywordsPanel" aria-label="My Topics">
    <div class="side-panel-header">
      <h2>My Topics</h2>
      <button class="panel-close-btn" id="keywordsPanelClose" aria-label="Close panel">‚úï</button>
    </div>
    <div class="side-panel-body">
      <p class="side-panel-hint">
        Click a keyword to toggle it on/off. Active keywords fetch and score papers.
        The √ó button removes a keyword entirely.
      </p>
      <!-- Sign-in hint shown only when signed out -->
      <p class="signin-notice" id="signinNotice" style="display:none;">
        Your keywords are saved locally. Sign in with Google to sync them across devices.
      </p>
      <!-- Keyword chips rendered here by JS -->
      <div class="keyword-list" id="keywordList"></div>
      <!-- Add keyword row ‚Äî disabled when signed out -->
      <div class="add-keyword-row" id="addKeywordRow">
        <input type="text" id="newKeywordInput" placeholder="Add a keyword‚Ä¶" maxlength="80" aria-label="New keyword" />
        <button class="btn-primary" id="addKeywordBtn">Add</button>
      </div>
    </div>
  </section>

  <!-- ‚îÄ‚îÄ Panel 2: Feed Insights (system-learned personalisation data) ‚îÄ‚îÄ -->
  <section class="side-panel" id="insightsPanel" aria-label="Feed Insights">
    <div class="side-panel-header">
      <h2>Feed Insights</h2>
      <button class="panel-close-btn" id="insightsPanelClose" aria-label="Close panel">‚úï</button>
    </div>
    <div class="side-panel-body">
      <p class="side-panel-hint">Based on your likes and reading activity.</p>
      <!-- Content rendered by renderInsightsPanel() -->
      <div id="insightsPanelBody"></div>
    </div>
  </section>

  <!-- ‚îÄ‚îÄ Toast notification container ‚îÄ‚îÄ -->
  <div id="toastContainer" class="toast-container" aria-live="polite" aria-atomic="false"></div>

  <!-- ‚îÄ‚îÄ Reading List view (swaps in place of the feed) ‚îÄ‚îÄ -->
  <div id="readingListView" style="display:none" aria-label="Reading List"></div>

  <!-- ‚îÄ‚îÄ Active keyword tags shown in feed view ‚îÄ‚îÄ -->
  <div class="active-keywords-bar" id="activeKeywordsBar"></div>

  <!-- ‚îÄ‚îÄ Search bar ‚îÄ‚îÄ -->
  <div class="search-bar-container" id="searchBarContainer">
    <div class="search-input-wrapper">
      <span class="search-icon">üîç</span>
      <input id="searchInput" class="search-input" type="search"
             placeholder="Search titles, abstracts, authors‚Ä¶" maxlength="200" />
      <button id="searchClearBtn" class="search-clear-btn" style="display:none" aria-label="Clear search">‚úï</button>
    </div>
  </div>

  <!-- ‚îÄ‚îÄ Filter panel ‚îÄ‚îÄ -->
  <div id="filterPanel" class="filter-panel">
    <div class="filter-panel-header">
      <button id="filterToggleBtn" class="btn-secondary filter-toggle-btn">
        ‚öô Filters <span id="filterActiveCount" class="filter-active-count" style="display:none"></span>
      </button>
      <div id="activeFilterTags" class="active-filter-tags"></div>
      <button id="clearAllFiltersBtn" class="btn-text" style="display:none">Clear all</button>
    </div>
    <div id="filterPanelBody" class="filter-panel-body" style="display:none">
      <!-- Common filters ‚Äî always visible when panel is open -->
      <div class="filter-common-section">
        <div class="filter-group">
          <label class="filter-group-label" for="sortSelect">Sort</label>
          <select id="sortSelect" class="sort-select">
            <option value="newest">Newest first</option>
            <option value="oldest">Oldest first</option>
            <option value="relevance">Highest relevance</option>
            <option value="cited">Most cited</option>
            <option value="influential">Most influential citations</option>
            <option value="trending">Trending (citation velocity)</option>
          </select>
        </div>
        <div class="filter-group">
          <span class="filter-group-label">Relevance</span>
          <div id="scoreFilterGroup" class="filter-check-row"></div>
        </div>
        <div class="filter-group">
          <span class="filter-group-label">Date</span>
          <div id="dateFilterGroup" class="filter-radio-row"></div>
        </div>
        <div class="filter-group">
          <span class="filter-group-label">Status</span>
          <div id="statusFilterGroup" class="filter-radio-row"></div>
        </div>
      </div>
      <!-- Advanced filters toggle row -->
      <div class="filter-advanced-toggle-row">
        <button class="btn-text" id="filterAdvancedToggle">Advanced filters ‚ñ∏</button>
      </div>
      <!-- Advanced filters ‚Äî collapsed by default -->
      <div class="filter-advanced-section" id="filterAdvancedSection" style="display:none">
        <div class="filter-group">
          <span class="filter-group-label">Keyword</span>
          <div id="keywordFilterGroup" class="filter-check-row"></div>
        </div>
        <div class="filter-group">
          <span class="filter-group-label">Citations</span>
          <div id="citationFilterGroup" class="filter-radio-row"></div>
        </div>
        <div class="filter-group">
          <span class="filter-group-label">Influential</span>
          <div id="inflCitationFilterGroup" class="filter-radio-row"></div>
        </div>
        <div class="filter-group">
          <span class="filter-group-label">Velocity</span>
          <div id="velocityFilterGroup" class="filter-radio-row"></div>
        </div>
        <div class="filter-group">
          <span class="filter-group-label">Access</span>
          <div id="openAccessFilterGroup" class="filter-check-row"></div>
        </div>
        <div class="filter-group">
          <span class="filter-group-label">Type</span>
          <div id="pubTypeFilterGroup" class="filter-radio-row"></div>
        </div>
        <div class="filter-group">
          <span class="filter-group-label">Field</span>
          <div id="fieldsFilterGroup" class="filter-check-row"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- ‚îÄ‚îÄ Feed header ‚îÄ‚îÄ -->
  <div id="feedHeader" class="feed-header">
    <div class="feed-header-left">
      <span id="feedCount" class="feed-count"></span>
      <span id="unreadBadge" class="unread-badge" style="display:none"></span>
    </div>
    <div class="feed-header-right">
      <span id="feedLastRefreshed" class="feed-last-refreshed"></span>
      <label class="toggle-label">
        <input type="checkbox" id="showHiddenToggle"> Show hidden
      </label>
    </div>
  </div>

  <!-- ‚îÄ‚îÄ Status line ‚îÄ‚îÄ -->
  <div class="status-bar" id="statusBar"></div>

  <!-- ‚îÄ‚îÄ Paper feed ‚îÄ‚îÄ -->
  <main class="paper-feed" id="paperFeed" aria-live="polite"></main>

  <footer>
    Data from <a href="https://www.semanticscholar.org/" target="_blank" rel="noopener" style="color:var(--accent)">Semantic Scholar</a>
    ‚Äî open and free academic search API.
    <div id="healthBar" class="health-bar" style="display:none;"></div>
  </footer>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  Research Hub ‚Äî HRI Paper Feed
//  Single-file vanilla JS app. No frameworks, no build step.
//  Keywords sync to Firestore when signed in.
//  Paper actions (like/save/hide) stored in Firestore subcollection.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ Firebase setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const firebaseConfig = {
  apiKey:            'AIzaSyCGeXjURWaP02MdENQIR5wjQJdmapyAEPo',
  authDomain:        'research-hub-8da6a.firebaseapp.com',
  projectId:         'research-hub-8da6a',
  storageBucket:     'research-hub-8da6a.firebasestorage.app',
  messagingSenderId: '765872653008',
  appId:             '1:765872653008:web:ea08868e0e59e86acb14d5',
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db   = firebase.firestore();

// Holds the signed-in Firebase User object, or null if signed out.
let currentUser = null;


// ‚îÄ‚îÄ Constants ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const THEME_KEY            = 'researchhub_theme';
const LAST_FETCH_KEY       = 'researchhub_last_fetch';
const HEALTH_KEY           = 'researchhub_health';
const SEEN_PAPERS_KEY      = 'researchhub_seen_papers';
const READING_LIST_KEY     = 'researchhub_reading_list'; // { paper, likedAt }[]
const KEYWORDS_LOCAL_KEY   = 'researchhub_keywords_local'; // localStorage fallback when signed out
const SCORE_TIP_SEEN_KEY   = 'researchhub_score_tip_seen';
const WILDCARD_TIP_SEEN_KEY= 'researchhub_wildcard_tip_seen';
const FETCH_TTL_MS    = 24 * 60 * 60 * 1000;
const PAGE_SIZE       = 20;

const API_BASE     = '/api/papers';
const PAPERS_LIMIT = 30;

// Stop words excluded when extracting topic keywords from paper titles/abstracts.
const STOP_WORDS = new Set([
  'the','a','an','and','or','but','in','on','at','to','for','of','with','by',
  'from','as','is','are','was','were','be','been','being','have','has','had',
  'do','does','did','will','would','could','should','may','might','this','that',
  'these','those','it','its','we','our','they','their','study','paper','research',
  'using','used','results','show','shows','showed','approach','method','methods',
  'system','based','new','also','can','two','one','both','between','more','most',
  'such','than','when','which','who','how','data','model','propose','proposed',
  'present','demonstrate','find','found','analysis','evaluate','evaluation',
  'provide','different','task','tasks','work','works','high','large','small',
  'number','recent','review','effect','effects','related','across','within',
  'toward','through','during','while','where','other','each','into','over',
]);

const DEFAULT_KEYWORDS = [
  { text: 'social robots',          active: true },
  { text: 'human-robot interaction', active: true },
  { text: 'emotional contagion',    active: true },
  { text: 'priming public spaces',  active: true },
  { text: 'non-humanoid robots',    active: true },
];

// Fields we request from Semantic Scholar.
// All fields are returned in a single API response ‚Äî no extra calls needed.
const API_FIELDS = 'title,abstract,authors,year,publicationDate,externalIds,url,' +
  'citationCount,influentialCitationCount,referenceCount,' +
  'isOpenAccess,openAccessPdf,publicationVenue,fieldsOfStudy';


// ‚îÄ‚îÄ App State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

let keywords    = [];   // { text, active }[]
let allPapers   = [];   // raw results per fetch ‚Äî never mutated after set
let papers      = [];   // derived filtered+sorted view of allPapers
let loading     = false;

let searchQuery = '';       // current live search string
let searchTimer = null;     // debounce handle

let filterState = {
  scores:        [1, 2, 3, 4, 5],  // active score checkboxes
  dateRange:     'all',             // 'all'|'7d'|'30d'|'90d'|'1y'
  status:        'all',             // 'all'|'unread'|'liked'|'saved'|'hidden'
  keywords:      [],                // [] = no keyword filter; strings = must match one
  citations:     0,                 // minimum total citation count: 0|10|50|100|500
  inflCitations: 0,                 // minimum influential citations: 0|5|10|25
  velocity:      'any',             // 'any'|'trending'|'growing'|'stable'
  openAccess:    false,             // true = open-access papers only
  pubType:       'all',             // 'all'|'journal'|'conference'|'preprint'
  fields:        [],                // [] = all fields; strings = must match at least one
};

let sortOrder  = 'relevance';  // 'newest'|'oldest'|'relevance'|'cited'|'influential'|'trending'
let pageIndex  = 0;

// Cache of { [paperId]: { liked, saved, hidden } } loaded from Firestore
let userActions = {};

// Cache of { [paperId]: { liked, saved, expanded, clicked, secondsVisible, ... } }
// Separate from userActions ‚Äî stores richer behavioral signals for learning
let userSignals = {};

// Learned keywords extracted from papers the user has liked/saved
// { text: string, weight: number }[]  ‚Äî persisted to Firestore users/{uid}.learnedKeywords
let learnedKeywords = [];

// Set of paperIds seen in a previous session (for unread badge)
let seenPaperIds = new Set();

// Whether to include hidden papers in the feed
let showHidden = false;

// Reading List: array of { paper, likedAt (ISO string) }
// Persisted in localStorage ‚Äî fully independent from the hide/learning signals.
let readingList     = [];
let readingListOpen = false;    // whether the RL view is currently showing
let rlSortOrder     = 'date-desc'; // 'date-desc'|'score-desc'|'pub-desc'


// ‚îÄ‚îÄ Initialise ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function init() {
  renderAuthUI();
  loadKeywords();
  loadReadingList(); // load before first render so exclusion filter works
  loadTheme();
  loadSeenPapers();
  bindEvents();
  renderFilterPanel();
  renderHealthBar();
  smartRefresh();
}


// ‚îÄ‚îÄ Auth UI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function renderAuthUI() {
  const area = document.getElementById('authArea');
  if (!area) return;

  if (currentUser) {
    const photo    = currentUser.photoURL;
    const name     = currentUser.displayName || currentUser.email || 'User';
    const initials = name.charAt(0).toUpperCase();

    const avatarHtml = photo
      ? `<img class="user-avatar" src="${esc(photo)}" alt="${esc(name)}" referrerpolicy="no-referrer">`
      : `<span class="user-avatar-fallback">${esc(initials)}</span>`;

    area.innerHTML = `
      <div class="auth-user">
        ${avatarHtml}
        <span class="user-name" title="${esc(name)}">${esc(name)}</span>
        <button class="btn-signout" id="signOutBtn">Sign out</button>
      </div>`;

    document.getElementById('signOutBtn').addEventListener('click', signOut);

    const row    = document.getElementById('addKeywordRow');
    const notice = document.getElementById('signinNotice');
    if (row)    row.classList.remove('disabled');
    if (notice) notice.style.display = 'none';

  } else {
    area.innerHTML = `
      <button class="btn-signin" id="signInBtn">
        <svg width="16" height="16" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
          <path d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844a4.14 4.14 0 0 1-1.796 2.716v2.259h2.908c1.702-1.567 2.684-3.875 2.684-6.615z" fill="#4285F4"/>
          <path d="M9 18c2.43 0 4.467-.806 5.956-2.184l-2.908-2.259c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332A8.997 8.997 0 0 0 9 18z" fill="#34A853"/>
          <path d="M3.964 10.706A5.41 5.41 0 0 1 3.682 9c0-.593.102-1.17.282-1.706V4.962H.957A8.996 8.996 0 0 0 0 9c0 1.452.348 2.827.957 4.038l3.007-2.332z" fill="#FBBC05"/>
          <path d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0A8.997 8.997 0 0 0 .957 4.962L3.964 7.294C4.672 5.163 6.656 3.58 9 3.58z" fill="#EA4335"/>
        </svg>
        Sign in with Google
      </button>`;

    document.getElementById('signInBtn').addEventListener('click', signIn);

    const notice = document.getElementById('signinNotice');
    // Add-keyword row is fully enabled when signed out ‚Äî keywords save to localStorage.
    // Sign-in notice tells users what changes when they do sign in.
    if (notice) notice.style.display = 'block';
  }
}

function signIn() {
  const provider = new firebase.auth.GoogleAuthProvider();
  auth.signInWithPopup(provider).catch(err => {
    console.error('Sign-in error:', err);
  });
}

function signOut() {
  auth.signOut().catch(err => {
    console.error('Sign-out error:', err);
  });
}


// ‚îÄ‚îÄ Firestore: keywords ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function userDocRef() {
  return db.collection('users').doc(currentUser.uid);
}

async function loadKeywordsFromFirestore() {
  try {
    const snap = await userDocRef().get();
    if (snap.exists && snap.data().keywords) {
      keywords = snap.data().keywords;
    } else {
      keywords = DEFAULT_KEYWORDS.map(k => ({ ...k }));
      await saveKeywordsToFirestore();
    }
  } catch (e) {
    console.error('Firestore load error:', e);
    keywords = DEFAULT_KEYWORDS.map(k => ({ ...k }));
  }
}

async function saveKeywordsToFirestore() {
  try {
    await userDocRef().set({ keywords }, { merge: true });
  } catch (e) {
    console.error('Firestore save error:', e);
  }
}


// ‚îÄ‚îÄ Firestore: user actions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Actions are stored in a subcollection: users/{uid}/actions/{paperId}
// Each doc: { liked: bool, saved: bool, hidden: bool, updatedAt: Timestamp }

function userActionsRef() {
  return db.collection('users').doc(currentUser.uid).collection('actions');
}

// Load all action docs for the current user into the userActions cache.
async function loadUserActions() {
  if (!currentUser) return;
  try {
    const snap = await userActionsRef().get();
    userActions = {};
    snap.forEach(doc => {
      userActions[doc.id] = doc.data();
    });
    renderPapers(); // re-render with loaded actions
  } catch (e) {
    console.error('Error loading user actions:', e);
  }
}

// Update one action field for a paper (merges with existing doc).
async function saveUserAction(paperId, key, value) {
  if (!currentUser) return;
  userActions[paperId] = userActions[paperId] || {};
  userActions[paperId][key] = value;
  try {
    await userActionsRef().doc(paperId).set(
      { [key]: value, updatedAt: firebase.firestore.FieldValue.serverTimestamp() },
      { merge: true }
    );
  } catch (e) {
    console.error('Error saving user action:', e);
  }
}


// ‚îÄ‚îÄ Firestore: behavioral signals ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Signals are stored in: users/{uid}/signals/{paperId}
// Separate from 'actions' ‚Äî stores richer behavioral data for learning.
// Each doc: { liked, saved, expanded, clicked, secondsVisible, removed,
//             title, abstract, authors, updatedAt }

function userSignalsRef() {
  return db.collection('users').doc(currentUser.uid).collection('signals');
}

// Load all signal docs into the in-memory userSignals cache.
async function loadUserSignals() {
  if (!currentUser) return;
  try {
    const snap = await userSignalsRef().get();
    userSignals = {};
    snap.forEach(doc => { userSignals[doc.id] = doc.data(); });
  } catch (e) {
    console.error('Error loading user signals:', e);
  }
}

// Write a single field to a signal doc (merge). Also snapshots the paper
// content so we can do keyword extraction later without re-fetching.
async function recordSignal(paperId, field, value) {
  if (!currentUser) return;
  const paper = allPapers.find(p => p.paperId === paperId);
  // Update in-memory cache immediately
  userSignals[paperId] = userSignals[paperId] || {};
  userSignals[paperId][field] = value;
  const doc = {
    [field]: value,
    title:    paper?.title    || userSignals[paperId]?.title    || '',
    abstract: paper?.abstract || userSignals[paperId]?.abstract || '',
    authors:  paper?.authors  || userSignals[paperId]?.authors  || [],
    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
  };
  try {
    await userSignalsRef().doc(paperId).set(doc, { merge: true });
  } catch (e) {
    console.error('Error recording signal:', e);
  }
}

// Compute a signal-based score adjustment for a paper based on past interactions.
// Returns a raw number (positive = boost, negative = penalty). Not clamped yet.
function computeSignalScore(paperId) {
  const s = userSignals[paperId];
  if (!s) return 0;

  // Recency multiplier based on updatedAt timestamp
  const updatedAt = s.updatedAt?.toDate?.() || new Date(0);
  const daysAgo   = (Date.now() - updatedAt.getTime()) / (1000 * 60 * 60 * 24);
  const recency   = daysAgo <= 7 ? 1.0 : daysAgo <= 30 ? 0.7 : 0.4;

  let raw = 0;
  if (s.liked)    raw += 3;
  if (s.saved)    raw += 2;
  if (s.removed)  raw -= 5;
  if (s.expanded) raw += 1;
  if (s.clicked)  raw += 2;
  // Time on screen: +0.5 per 10s, capped at 120s = max +6
  raw += Math.min(s.secondsVisible || 0, 120) / 10 * 0.5;

  return raw * recency;
}


// ‚îÄ‚îÄ Keyword learning ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Extract the top N meaningful words from a paper's title + abstract.
// Title is weighted double (concatenated twice) so title words score higher.
function extractKeywords(title, abstract, topN = 3) {
  const text   = `${title} ${title} ${abstract}`.toLowerCase();
  const tokens = text.split(/[^a-z]+/).filter(w => w.length >= 4 && !STOP_WORDS.has(w));
  const freq   = {};
  for (const t of tokens) freq[t] = (freq[t] || 0) + 1;
  return Object.entries(freq)
    .sort((a, b) => b[1] - a[1])
    .slice(0, topN)
    .map(([word]) => word);
}

// Compute a relevance boost (0‚Äì2) from learned keywords matching this paper.
function scoreLearnedKeywords(paper) {
  if (!learnedKeywords.length) return 0;
  const text = `${paper.title || ''} ${paper.abstract || ''}`.toLowerCase();
  let boost  = 0;
  for (const lk of learnedKeywords) {
    if (text.includes(lk.text.toLowerCase())) {
      boost += lk.weight * 0.3;
    }
  }
  return Math.min(2, boost);
}

// Called when a user likes or saves a paper.
// Extracts keywords and adds/strengthens them in learnedKeywords[].
function addLearnedKeywords(paper) {
  if (!currentUser || !paper) return;
  const extracted = extractKeywords(paper.title || '', paper.abstract || '');
  const manualTexts = keywords.map(k => k.text.toLowerCase());
  let changed = false;

  for (const word of extracted) {
    // Don't learn words already in manual keywords
    if (manualTexts.some(m => m.includes(word) || word.includes(m))) continue;
    const existing = learnedKeywords.find(lk => lk.text === word);
    if (existing) {
      existing.weight = Math.min(3.0, existing.weight + 0.5); // strengthen
    } else {
      learnedKeywords.push({ text: word, weight: 1.0 });
    }
    changed = true;
  }

  if (changed) {
    saveLearnedKeywords();
    updateInsightsDotIndicator();
    renderInsightsPanel();
  }
}

// Remove a learned keyword by text (called from insights panel UI).
function removeLearnedKeyword(text) {
  learnedKeywords = learnedKeywords.filter(lk => lk.text !== text);
  saveLearnedKeywords();
  rescoreAll();
  updateInsightsDotIndicator();
  renderInsightsPanel();
  showToast('Removed from your learned topics');
}

// Load learnedKeywords from the users/{uid} document.
async function loadLearnedKeywords() {
  if (!currentUser) return;
  try {
    const doc = await db.collection('users').doc(currentUser.uid).get();
    learnedKeywords = doc.data()?.learnedKeywords || [];
  } catch (e) {
    console.error('Error loading learned keywords:', e);
    learnedKeywords = [];
  }
}

// Persist learnedKeywords back to Firestore.
async function saveLearnedKeywords() {
  if (!currentUser) return;
  try {
    await db.collection('users').doc(currentUser.uid).set(
      { learnedKeywords },
      { merge: true }
    );
  } catch (e) {
    console.error('Error saving learned keywords:', e);
  }
}

// Show inline confirmation UI in place of the reset button.
function showResetConfirmation() {
  const area = document.getElementById('resetConfirmArea');
  if (!area) return;
  area.innerHTML = `
    <p class="reset-warning">This clears inferred keywords, topics, and author data. Your manual keywords stay. This cannot be undone.</p>
    <div class="reset-confirm-btns">
      <button class="btn-secondary" id="resetCancelBtn">Cancel</button>
      <button class="btn-danger" id="resetConfirmBtn">Yes, reset</button>
    </div>
  `;
  document.getElementById('resetCancelBtn').addEventListener('click', () => {
    area.innerHTML = '<button class="btn-reset-profile" id="resetProfileBtn">üîÑ Reset learning profile</button>';
    document.getElementById('resetProfileBtn').addEventListener('click', showResetConfirmation);
  });
  document.getElementById('resetConfirmBtn').addEventListener('click', resetLearningProfile);
}

// Reset the full learning profile: delete all signals + learned keywords.
async function resetLearningProfile() {
  if (!currentUser) return;

  try {
    // Batch-delete all signal docs
    const snap = await userSignalsRef().get();
    const batch = db.batch();
    snap.forEach(doc => batch.delete(doc.ref));
    await batch.commit();

    // Clear learned keywords from Firestore
    await db.collection('users').doc(currentUser.uid).set(
      { learnedKeywords: [] },
      { merge: true }
    );
  } catch (e) {
    console.error('Error resetting profile:', e);
  }

  userSignals     = {};
  learnedKeywords = [];
  rescoreAll();
  updateInsightsDotIndicator();
  renderInsightsPanel();
  showToast('Learning profile cleared');
}


// ‚îÄ‚îÄ Combined scoring ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Full relevance score incorporating keyword match, signal history, and learned keywords.
// Returns integer 1‚Äì5. This replaces the direct scorepaper() call during fetch.
function scoreWithSignals(paper) {
  const base          = scorepaper(paper);                       // 1‚Äì5 keyword score
  const learnedBoost  = scoreLearnedKeywords(paper);             // 0‚Äì2 boost
  const signalBoost   = computeSignalScore(paper.paperId);       // raw signal value

  // Signals contribute up to ¬±2 to the score (clamped and scaled)
  const signalContrib = Math.max(-2, Math.min(2, signalBoost * 0.3));

  const raw = base + (learnedBoost * 0.5) + signalContrib;
  return Math.max(1, Math.min(5, Math.round(raw)));
}

// Re-score allPapers[] with the current signals + learned keywords, then re-render.
function rescoreAll() {
  if (allPapers.length === 0) return;
  allPapers = allPapers.map(p => ({ ...p, score: scoreWithSignals(p) }));
  papers    = applyFiltersAndSort(allPapers);
  renderPapers();
}


// ‚îÄ‚îÄ Score explanation (for tooltip) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Returns up to 3 human-readable reasons for a paper's score.
function buildScoreExplanation(paper) {
  const reasons = [];
  const base    = scorepaper(paper);
  const learned = scoreLearnedKeywords(paper);
  const s       = userSignals[paper.paperId];

  if (base >= 4)      reasons.push(`Strong keyword match (base ${base}/5)`);
  else if (base >= 2) reasons.push(`Partial keyword match (base ${base}/5)`);
  else                reasons.push('Outside your main keywords');

  if (s?.liked)                        reasons.push('You liked this paper');
  if (s?.saved)                        reasons.push('You saved this paper');
  if (s?.clicked)                      reasons.push('You previously opened this paper');
  if ((s?.secondsVisible || 0) >= 30)  reasons.push('You spent time reading this');
  if (learned > 0.2)                   reasons.push('Matches topics from papers you liked');
  if (paper.isWildcard)                reasons.push('üîç Explore: highly cited, outside your usual keywords');

  return reasons.slice(0, 3);
}


// ‚îÄ‚îÄ Wildcard paper selection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Pick a "wildcard" paper for diversity ‚Äî low keyword match but notably cited.
// Returns a paper object with isWildcard=true, or null if none available.
function pickWildcard(allPapersArr, alreadyShown) {
  const shownIds = new Set(alreadyShown.map(p => p.paperId));
  // Candidates: not already shown, low keyword score, but cited (interesting discovery)
  const candidates = allPapersArr
    .filter(p => !shownIds.has(p.paperId) && p.score <= 2 && (p.influentialCitationCount || 0) >= 3)
    .sort((a, b) => (b.influentialCitationCount || 0) - (a.influentialCitationCount || 0));
  if (!candidates.length) return null;
  return { ...candidates[0], isWildcard: true };
}


// ‚îÄ‚îÄ Auth state observer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

auth.onAuthStateChanged(async (user) => {
  currentUser = user;

  if (user) {
    await loadKeywordsFromFirestore();
    // Firestore is now canonical ‚Äî discard any localStorage draft made while signed out
    localStorage.removeItem(KEYWORDS_LOCAL_KEY);
    await loadUserActions();
    await loadUserSignals();
    await loadLearnedKeywords();
  } else {
    // Signed out: load from localStorage (allows local keyword customisation without sign-in)
    loadKeywords();
    userActions     = {};
    userSignals     = {};
    learnedKeywords = [];
  }

  renderAuthUI();
  renderKeywordChips();
  renderActiveKeywordsBar();
  renderFilterPanel(); // keyword filter group depends on active keywords
  updateInsightsDotIndicator();

  // Re-score papers already on screen with updated signals + learned keywords
  if (allPapers.length > 0) {
    allPapers = allPapers.map(p => ({ ...p, score: scoreWithSignals(p) }));
    papers    = applyFiltersAndSort(allPapers);
    pageIndex = 0;
    renderPapers();
  }
});


// ‚îÄ‚îÄ localStorage helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function loadKeywords() {
  // When signed out, load from localStorage (allows local customisation without sign-in).
  // When signed in, Firestore is canonical ‚Äî this function is only called for the signed-out path.
  try {
    const saved = localStorage.getItem(KEYWORDS_LOCAL_KEY);
    keywords = saved ? JSON.parse(saved) : DEFAULT_KEYWORDS.map(k => ({ ...k }));
  } catch(e) {
    keywords = DEFAULT_KEYWORDS.map(k => ({ ...k }));
  }
}

function saveKeywords() {
  if (currentUser) {
    // Signed in: persist to Firestore (canonical store)
    saveKeywordsToFirestore();
  } else {
    // Signed out: persist to localStorage so edits survive page reload
    try {
      localStorage.setItem(KEYWORDS_LOCAL_KEY, JSON.stringify(keywords));
    } catch(e) { /* storage quota ‚Äî skip */ }
  }
}

function loadTheme() {
  const saved = localStorage.getItem(THEME_KEY) || 'light';
  applyTheme(saved);
}

function applyTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  // Swap theme icon: sun in dark mode, moon in light mode
  document.getElementById('themeBtn').innerHTML = theme === 'dark'
    ? `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>`
    : `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>`;
  localStorage.setItem(THEME_KEY, theme);
}


// ‚îÄ‚îÄ Unread tracking ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// We store the IDs of papers seen in the last session in localStorage.
// Papers in the current fetch that aren't in seenPaperIds are "new".

function loadSeenPapers() {
  try {
    const raw = localStorage.getItem(SEEN_PAPERS_KEY);
    if (raw) seenPaperIds = new Set(JSON.parse(raw));
  } catch (e) {
    seenPaperIds = new Set();
  }
}

// Save the current allPapers IDs as "seen" (capped at 500).
function updateSeenPapers() {
  const currentIds = allPapers.map(p => p.paperId).filter(Boolean);
  // Merge with previous (keep old seen IDs, add new ones)
  const merged = [...seenPaperIds, ...currentIds];
  const capped  = merged.slice(-500);
  try {
    localStorage.setItem(SEEN_PAPERS_KEY, JSON.stringify(capped));
  } catch (e) { /* quota exceeded ‚Äî skip silently */ }
  // Update the in-memory set to include just-seen papers
  // so they won't be "unread" next session
  // (we set it AFTER renderPapers so the badge shows this session's new papers)
}


// ‚îÄ‚îÄ Smart refresh ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function smartRefresh() {
  fetchPapers();
}

function friendlyTime(date) {
  const diff = Math.floor((Date.now() - date.getTime()) / 1000);
  if (diff < 60)    return 'just now';
  if (diff < 3600)  return `${Math.floor(diff / 60)} min ago`;
  if (diff < 86400) return `${Math.floor(diff / 3600)} hr ago`;
  return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
}


// ‚îÄ‚îÄ Health check ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async function runHealthCheck() {
  const firstKeyword = activeKeywords()[0];
  if (!firstKeyword) return;

  let ok = false, msg = '';
  try {
    const params = new URLSearchParams({ query: firstKeyword, fields: 'title,year', limit: 1 });
    const res  = await fetch(`${API_BASE}?${params}`);
    const data = await res.json();
    if (res.status === 429 || (data.message && !data.data)) {
      msg = 'API rate-limited';
    } else if (!res.ok) {
      msg = `API error (HTTP ${res.status})`;
    } else if (!data.data || data.data.length === 0) {
      msg = 'API returned no papers';
    } else if (!data.data[0].title) {
      msg = 'API returned malformed data';
    } else {
      ok = true; msg = 'All systems good';
    }
  } catch (e) {
    msg = e.message === 'Failed to fetch' ? 'Cannot reach API' : e.message;
  }
  const result = { ok, msg, ts: new Date().toISOString() };
  localStorage.setItem(HEALTH_KEY, JSON.stringify(result));
  renderHealthBar(result);
}

function renderHealthBar(result) {
  if (!result) {
    try {
      const saved = localStorage.getItem(HEALTH_KEY);
      if (!saved) return;
      result = JSON.parse(saved);
    } catch (e) { return; }
  }
  const el = document.getElementById('healthBar');
  if (!el) return;
  const time = friendlyTime(new Date(result.ts));
  el.style.display = 'inline-block';
  el.className = 'health-bar ' + (result.ok ? 'ok' : 'error');
  el.textContent = result.ok
    ? `‚úÖ ${result.msg} ‚Äî last checked ${time}`
    : `‚ùå ${result.msg} ‚Äî last checked ${time}`;
}


// ‚îÄ‚îÄ Reading List ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Load reading list from localStorage.
function loadReadingList() {
  try {
    readingList = JSON.parse(localStorage.getItem(READING_LIST_KEY) || '[]');
  } catch { readingList = []; }
  updateReadingListBadge();
}

// Persist reading list to localStorage and refresh the badge.
function saveReadingList() {
  localStorage.setItem(READING_LIST_KEY, JSON.stringify(readingList));
  updateReadingListBadge();
}

// Update the count badge on the Reading List header button.
function updateReadingListBadge() {
  const badge = document.getElementById('readingListBadge');
  if (!badge) return;
  if (readingList.length > 0) {
    badge.textContent = readingList.length;
    badge.style.display = '';
  } else {
    badge.style.display = 'none';
  }
}

// Add a paper to the reading list (called on like). No-ops if already present.
function addToReadingList(paper) {
  if (!paper) return;
  if (readingList.some(e => e.paper.paperId === paper.paperId)) return;
  readingList.unshift({ paper, likedAt: new Date().toISOString() });
  saveReadingList();
}

// Remove a paper from the reading list WITHOUT touching the like signal.
// The learning algorithm keeps the positive like signal ‚Äî removal just clears the queue.
function removeFromReadingList(paperId, silent = false) {
  readingList = readingList.filter(e => e.paper.paperId !== paperId);
  saveReadingList();
  if (readingListOpen) renderReadingList();
  if (!silent) showToast('Removed from Reading List');
}

// Show the Reading List view ‚Äî hides feed elements, renders RL content.
function openReadingListView() {
  readingListOpen = true;
  closeAllPanels();
  ['activeKeywordsBar','searchBarContainer','filterPanel','feedHeader','statusBar','paperFeed']
    .forEach(id => { const el = document.getElementById(id); if (el) el.style.display = 'none'; });
  document.getElementById('readingListView').style.display = 'block';
  // Highlight the Reading List button to show it is the active view
  document.getElementById('readingListToggle')?.classList.add('active');
  renderReadingList();
}

// Hide the Reading List view and restore the feed.
function closeReadingListView() {
  readingListOpen = false;
  document.getElementById('readingListView').style.display = 'none';
  ['activeKeywordsBar','searchBarContainer','filterPanel','feedHeader','statusBar','paperFeed']
    .forEach(id => { const el = document.getElementById(id); if (el) el.style.display = ''; });
  document.getElementById('readingListToggle')?.classList.remove('active');
}

// One-time migration: add previously-liked OR saved papers (before RL existed, or before
// Save was wired to RL) into the reading list.
// Runs after both userActions and allPapers are available.
function migrateOldLikesToReadingList() {
  // v3 key: Reading List is now Save-only (Like is a pure learning signal, stays in feed).
  // Back-fill any previously-saved papers that aren't already in the RL.
  const migrationKey = 'researchhub_rl_migrated_v3';
  if (localStorage.getItem(migrationKey)) return;

  let migrated = 0;
  for (const [paperId, actions] of Object.entries(userActions)) {
    // Only saved papers belong in the Reading List (liked papers stay in feed)
    if (actions.saved && !readingList.some(e => e.paper.paperId === paperId)) {
      const paper = allPapers.find(p => p.paperId === paperId);
      if (paper) {
        readingList.push({ paper, likedAt: new Date().toISOString() });
        migrated++;
      }
    }
  }
  if (migrated > 0) {
    saveReadingList();
    localStorage.setItem('researchhub_rl_migration_notice', migrated.toString());
  }
  localStorage.setItem(migrationKey, '1');
}

// Build the HTML for one dense Reading List card.
function buildRlCardHtml(paper, likedAt) {
  const paperId  = paper.paperId || '';
  const paperUrl = paper.url ||
    (paper.externalIds?.DOI
      ? `https://doi.org/${paper.externalIds.DOI}`
      : `https://www.semanticscholar.org/paper/${paperId}`);
  const firstAuthor = paper.authors?.[0]?.name || 'Unknown author';
  const authorCount = paper.authors?.length || 0;
  const yearDisplay = paper.publicationDate?.slice(0, 7) || (paper.year ? String(paper.year) : '');
  const venue       = paper.publicationVenue?.name || '';
  const metaParts   = [
    firstAuthor + (authorCount > 1 ? ` +${authorCount - 1}` : ''),
    yearDisplay,
    venue,
  ].filter(Boolean);
  const scoreClass = paper.score >= 4 ? 'high' : paper.score >= 2 ? 'mid' : '';
  const oaBadge    = paper.isOpenAccess
    ? `<span class="oa-badge" title="Open Access">üîì</span>` : '';
  const addedDate  = new Date(likedAt).toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
  const abstractSnippet = paper.abstract ? esc(paper.abstract) : '<em style="color:var(--text-muted)">No abstract available.</em>';
  const isSaved    = !!userActions[paperId]?.saved;

  return `
    <article class="rl-card" data-paperid="${esc(paperId)}">
      <div class="rl-card-top">
        <h2 class="rl-title">
          <a href="${esc(paperUrl)}" target="_blank" rel="noopener">${esc(paper.title || 'Untitled')}</a>
        </h2>
        <div class="rl-card-badges">
          ${oaBadge}
          ${isSaved ? '<span title="Also saved" style="font-size:0.85rem">üîñ</span>' : ''}
          <span class="score-badge ${scoreClass}" title="Relevance score when liked">‚òÖ ${paper.score}/5</span>
        </div>
      </div>
      <div class="rl-meta">${esc(metaParts.join(' ¬∑ '))}</div>
      <p class="rl-abstract" title="Click to expand">${abstractSnippet}</p>
      <div class="rl-card-actions">
        <span class="rl-added-date">Added ${esc(addedDate)}</span>
        <a class="btn-text" href="${esc(paperUrl)}" target="_blank" rel="noopener" style="font-size:0.78rem">Open ‚Üó</a>
        <button class="rl-remove-btn" data-paperid="${esc(paperId)}" title="Remove from Reading List">Remove ‚úï</button>
      </div>
    </article>`;
}

// Render the full Reading List view inside #readingListView.
function renderReadingList() {
  const view = document.getElementById('readingListView');
  if (!view) return;

  // Show migration notice if applicable
  const migrationCount = localStorage.getItem('researchhub_rl_migration_notice');
  const migrationBanner = migrationCount
    ? `<div class="rl-migration-notice" id="rlMigrationNotice">
        üìö We've added ${migrationCount} previously liked paper${migrationCount > 1 ? 's' : ''} to your Reading List.
        <button class="btn-text" style="margin-left:8px;font-size:0.78rem" onclick="
          localStorage.removeItem('researchhub_rl_migration_notice');
          document.getElementById('rlMigrationNotice')?.remove();
        ">Dismiss</button>
      </div>`
    : '';

  if (readingList.length === 0) {
    view.innerHTML = `
      ${migrationBanner}
      <div class="rl-header"><h2>Reading List</h2>
        <button class="btn-secondary" onclick="closeReadingListView()">‚Üê Back to Feed</button>
      </div>
      <div class="rl-empty-state">
        <div class="icon">üìö</div>
        <p>Your reading list is empty.</p>
        <p style="font-size:0.8rem;margin-top:4px">Save a paper in the feed to add it here.</p>
      </div>`;
    return;
  }

  // Sort the list
  const sorted = readingList.slice().sort((a, b) => {
    if (rlSortOrder === 'score-desc') return (b.paper.score || 0) - (a.paper.score || 0);
    if (rlSortOrder === 'pub-desc') {
      const da = a.paper.publicationDate || (a.paper.year ? `${a.paper.year}-01-01` : '0000');
      const db = b.paper.publicationDate || (b.paper.year ? `${b.paper.year}-01-01` : '0000');
      return db.localeCompare(da);
    }
    // default: date-desc ‚Äî newest added first
    return new Date(b.likedAt) - new Date(a.likedAt);
  });

  const cardsHtml = sorted.map(({ paper, likedAt }) => buildRlCardHtml(paper, likedAt)).join('');

  view.innerHTML = `
    ${migrationBanner}
    <div class="rl-header">
      <h2>Reading List <span class="rl-count">(${readingList.length})</span></h2>
      <div class="rl-controls">
        <select class="rl-sort-select" id="rlSortSelect">
          <option value="date-desc"${rlSortOrder === 'date-desc' ? ' selected' : ''}>Date added</option>
          <option value="score-desc"${rlSortOrder === 'score-desc' ? ' selected' : ''}>Relevance score</option>
          <option value="pub-desc"${rlSortOrder === 'pub-desc' ? ' selected' : ''}>Publication date</option>
        </select>
        <button class="btn-secondary" onclick="closeReadingListView()">‚Üê Back to Feed</button>
      </div>
    </div>
    <div id="rlCardList">${cardsHtml}</div>`;

  // Wire sort selector
  document.getElementById('rlSortSelect')?.addEventListener('change', (e) => {
    rlSortOrder = e.target.value;
    renderReadingList();
  });

  // Wire remove buttons
  view.querySelectorAll('.rl-remove-btn').forEach(btn => {
    btn.addEventListener('click', () => removeFromReadingList(btn.dataset.paperid));
  });

  // Abstract expand on click
  view.querySelectorAll('.rl-abstract').forEach(el => {
    el.addEventListener('click', () => el.classList.toggle('expanded'));
  });
}


// ‚îÄ‚îÄ Insights dot indicator ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Toggle the .has-insights class on the ‚ú¶ button whenever learnedKeywords changes.
function updateInsightsDotIndicator() {
  const btn = document.getElementById('insightsToggle');
  if (!btn) return;
  btn.classList.toggle('has-insights', learnedKeywords.length > 0);
}


// ‚îÄ‚îÄ Toast notifications ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Show a non-blocking toast message at the bottom of the screen.
function showToast(message, duration = 2500) {
  const container = document.getElementById('toastContainer');
  if (!container) return;
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.textContent = message;
  container.appendChild(toast);
  // Trigger CSS transition (must be a separate frame from append)
  requestAnimationFrame(() => toast.classList.add('toast--visible'));
  setTimeout(() => {
    toast.classList.remove('toast--visible');
    toast.addEventListener('transitionend', () => toast.remove(), { once: true });
  }, duration);
}


// Animate a paper card out of the feed (slide-left + fade), then fire callback.
// Reuses the existing .paper-card--fading CSS transition (~380ms).
function animateCardOut(paperId, callback) {
  const card = document.querySelector(`[data-paperid="${paperId}"]`);
  if (!card) { callback?.(); return; }
  card.classList.add('paper-card--fading');
  setTimeout(() => callback?.(), 380);
}

// Like showToast() but with an Undo button. onUndo fires if tapped within duration.
function showToastWithUndo(message, onUndo, duration = 4000) {
  const container = document.getElementById('toastContainer');
  if (!container) return;
  const toast = document.createElement('div');
  toast.className = 'toast toast--with-undo';
  toast.innerHTML = `<span>${esc(message)}</span><button class="toast-undo-btn">Undo</button>`;
  container.appendChild(toast);

  let undone = false;
  toast.querySelector('.toast-undo-btn').addEventListener('click', () => {
    undone = true;
    onUndo?.();
    toast.classList.remove('toast--visible');
    toast.addEventListener('transitionend', () => toast.remove(), { once: true });
  });

  requestAnimationFrame(() => toast.classList.add('toast--visible'));
  setTimeout(() => {
    if (!undone) {
      toast.classList.remove('toast--visible');
      toast.addEventListener('transitionend', () => toast.remove(), { once: true });
    }
  }, duration);
}


// ‚îÄ‚îÄ Panel open/close helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Open a named side-panel (closes any already-open panel first).
function openPanel(id) {
  ['keywordsPanel', 'insightsPanel'].forEach(pid => {
    document.getElementById(pid)?.classList.remove('open');
  });
  document.getElementById(id)?.classList.add('open');
}

// Close all side-panels.
function closeAllPanels() {
  ['keywordsPanel', 'insightsPanel'].forEach(pid => {
    document.getElementById(pid)?.classList.remove('open');
  });
}


// ‚îÄ‚îÄ Event binding ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function bindEvents() {
  // Header: My Topics panel
  document.getElementById('keywordsToggle').addEventListener('click', () => {
    openPanel('keywordsPanel');
    renderKeywordChips();
  });

  // Header: Feed Insights panel
  document.getElementById('insightsToggle').addEventListener('click', () => {
    openPanel('insightsPanel');
    renderInsightsPanel();
  });

  // Header: Reading List view
  document.getElementById('readingListToggle').addEventListener('click', () => {
    if (readingListOpen) {
      closeReadingListView();
    } else {
      closeAllPanels();
      openReadingListView();
    }
  });

  // Close buttons inside each panel
  document.getElementById('keywordsPanelClose').addEventListener('click', closeAllPanels);
  document.getElementById('insightsPanelClose').addEventListener('click', closeAllPanels);

  // Click outside panels (on .app-main) closes them
  document.querySelector('.app-main')?.addEventListener('click', (e) => {
    if (!e.target.closest('.side-panel') && !e.target.closest('#keywordsToggle') && !e.target.closest('#insightsToggle')) {
      closeAllPanels();
    }
  });

  document.getElementById('refreshBtn').addEventListener('click', fetchPapers);
  document.getElementById('themeBtn').addEventListener('click', () => {
    const current = document.documentElement.getAttribute('data-theme');
    applyTheme(current === 'dark' ? 'light' : 'dark');
  });
  document.getElementById('addKeywordBtn').addEventListener('click', addKeyword);
  document.getElementById('newKeywordInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') addKeyword();
  });

  // Search
  document.getElementById('searchInput').addEventListener('input', handleSearchInput);
  document.getElementById('searchClearBtn').addEventListener('click', clearSearch);

  // Filter panel toggle
  document.getElementById('filterToggleBtn').addEventListener('click', () => {
    const body = document.getElementById('filterPanelBody');
    body.style.display = body.style.display === 'none' ? 'flex' : 'none';
  });

  // Advanced filters toggle inside the filter panel body
  document.getElementById('filterAdvancedToggle')?.addEventListener('click', () => {
    const sec = document.getElementById('filterAdvancedSection');
    const btn = document.getElementById('filterAdvancedToggle');
    if (!sec || !btn) return;
    const isOpen = sec.style.display !== 'none';
    sec.style.display = isOpen ? 'none' : 'flex';
    btn.textContent = isOpen ? 'Advanced filters ‚ñ∏' : 'Advanced filters ‚ñ¥';
  });

  // Clear all filters
  document.getElementById('clearAllFiltersBtn').addEventListener('click', clearAllFilters);

  // Sort select
  document.getElementById('sortSelect').addEventListener('change', (e) => {
    sortOrder = e.target.value;
    applyAndRender();
  });

  // Show hidden toggle
  document.getElementById('showHiddenToggle').addEventListener('change', (e) => {
    showHidden = e.target.checked;
    applyAndRender();
  });
}


// ‚îÄ‚îÄ Keyword management ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function addKeyword() {
  const input = document.getElementById('newKeywordInput');
  const text  = input.value.trim().toLowerCase();
  if (!text) return;
  if (keywords.some(k => k.text === text)) { input.value = ''; return; }
  keywords.push({ text, active: true });
  saveKeywords();
  input.value = '';
  renderKeywordChips();
  renderActiveKeywordsBar();
  renderKeywordFilterGroup(); // update filter panel
  fetchPapers();
  showToast('Keyword added ‚Äî feed will update');
}

function removeKeyword(index) {
  keywords.splice(index, 1);
  saveKeywords();
  renderKeywordChips();
  renderActiveKeywordsBar();
  renderKeywordFilterGroup();
  fetchPapers();
  showToast('Keyword removed');
}

function toggleKeyword(index) {
  keywords[index].active = !keywords[index].active;
  saveKeywords();
  renderKeywordChips();
  renderActiveKeywordsBar();
  renderKeywordFilterGroup();
  fetchPapers();
}

function activeKeywords() {
  return keywords.filter(k => k.active).map(k => k.text);
}


// ‚îÄ‚îÄ Relevance scoring ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function scorepaper(paper) {
  const active = activeKeywords();
  if (active.length === 0) return 1;

  const title    = (paper.title    || '').toLowerCase();
  const abstract = (paper.abstract || '').toLowerCase();

  let depthScore = 0;  // sum of per-keyword depth points (max 3 per kw: 2 title + 1 abstract)
  let matchedKws = 0;  // how many keywords appeared at all in this paper

  for (const kw of active) {
    const kwLower    = kw.toLowerCase();
    const inTitle    = title.includes(kwLower);
    const inAbstract = abstract.includes(kwLower);
    if (inTitle || inAbstract) {
      matchedKws++;
      if (inTitle)    depthScore += 2; // title match worth more
      if (inAbstract) depthScore += 1;
    }
  }

  // No keyword found in this paper at all ‚Üí not relevant
  if (matchedKws === 0) return 1;

  // Breadth: what fraction of ALL active keywords matched this paper?
  // e.g. 1 of 4 keywords ‚Üí 0.25; 4 of 4 ‚Üí 1.0
  const breadth = matchedKws / active.length;

  // Depth: how deeply did the matched keywords hit (title vs abstract)?
  // Always in [0.33, 1.0] when matchedKws > 0.
  const depth = depthScore / (matchedKws * 3);

  // Combined score weighted 70% breadth (coverage) + 30% depth (title/abstract hit).
  // This ensures a paper matching only 1 of 4 keywords cannot score 5/5,
  // even if that one keyword appears in both title and abstract.
  const combined = (breadth * 0.7) + (depth * 0.3);

  if (combined >= 0.75) return 5; // strong multi-keyword match
  if (combined >= 0.50) return 4; // good coverage
  if (combined >= 0.30) return 3; // partial match
  if (combined >= 0.10) return 2; // weak match
  return 1;                       // effectively no match
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  FILTER & SORT PIPELINE
//  All pure functions ‚Äî no DOM side effects.
//  Input: allPapers[]  ‚Üí  Output: filtered+sorted papers[]
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Master entry point: recompute papers[] from allPapers[], reset page, re-render.
function applyAndRender() {
  papers    = applyFiltersAndSort(allPapers);
  pageIndex = 0;
  renderPapers();
}

// Chains all 6 filter steps then sort. Returns a new array (never mutates input).
function applyFiltersAndSort(arr) {
  let result = arr.slice(); // shallow copy ‚Äî safe because we never mutate paper objects
  result = applySearchFilter(result, searchQuery);
  result = applyScoreFilter(result, filterState.scores);
  result = applyDateFilter(result, filterState.dateRange);
  result = applyStatusFilter(result, filterState.status, userActions);
  result = applyKeywordFilter(result, filterState.keywords);
  result = applyCitationFilter(result, filterState.citations);
  result = applyInflCitationFilter(result, filterState.inflCitations);
  result = applyVelocityFilter(result, filterState.velocity);
  result = applyOpenAccessFilter(result, filterState.openAccess);
  result = applyPubTypeFilter(result, filterState.pubType);
  result = applyFieldsFilter(result, filterState.fields);
  // Unless "show hidden" is on, remove hidden papers from the default view
  if (!showHidden) {
    result = result.filter(p => !userActions[p.paperId]?.hidden);
  }
  // Papers in the reading list are moved there ‚Äî exclude from main feed
  // (like signal is preserved; this is purely a UI routing decision)
  result = result.filter(p => !readingList.some(e => e.paper.paperId === p.paperId));
  result = applySortOrder(result, sortOrder);
  return result;
}

// Full-text search across title, abstract, authors (case-insensitive substring).
function applySearchFilter(arr, q) {
  if (!q || !q.trim()) return arr;
  const term = q.trim().toLowerCase();
  return arr.filter(p => {
    const title    = (p.title    || '').toLowerCase();
    const abstract = (p.abstract || '').toLowerCase();
    const authors  = (p.authors  || []).map(a => (a.name || '').toLowerCase()).join(' ');
    return title.includes(term) || abstract.includes(term) || authors.includes(term);
  });
}

// Keep only papers whose score is in the allowed scores array.
function applyScoreFilter(arr, scores) {
  if (!scores || scores.length === 5) return arr; // all selected = no filter
  return arr.filter(p => scores.includes(p.score));
}

// Filter by publication date using paper.publicationDate (YYYY-MM-DD).
// Falls back to paper.year if publicationDate is absent.
function applyDateFilter(arr, range) {
  if (range === 'all') return arr;

  const now = Date.now();
  const cutoffMs = {
    '7d':  7  * 24 * 60 * 60 * 1000,
    '30d': 30 * 24 * 60 * 60 * 1000,
    '90d': 90 * 24 * 60 * 60 * 1000,
    '1y':  365 * 24 * 60 * 60 * 1000,
  }[range];

  if (!cutoffMs) return arr;
  const cutoff = now - cutoffMs;

  return arr.filter(p => {
    // Prefer full date, fall back to year-only
    const dateStr = p.publicationDate || (p.year ? `${p.year}-01-01` : null);
    if (!dateStr) return false;
    const ts = new Date(dateStr).getTime();
    return !isNaN(ts) && ts >= cutoff;
  });
}

// Filter by status: all / unread / liked / saved / hidden
function applyStatusFilter(arr, status, actions) {
  if (status === 'all') return arr;
  return arr.filter(p => {
    const a = actions[p.paperId] || {};
    if (status === 'liked')  return !!a.liked;
    if (status === 'saved')  return !!a.saved;
    if (status === 'hidden') return !!a.hidden;
    if (status === 'unread') return !seenPaperIds.has(p.paperId);
    return true;
  });
}

// Keep papers that match at least one of the selected keyword filters.
// Empty array = no keyword filter (show all).
function applyKeywordFilter(arr, kws) {
  if (!kws || kws.length === 0) return arr;
  const kwsLower = kws.map(k => k.toLowerCase());
  return arr.filter(p => {
    const text = ((p.title || '') + ' ' + (p.abstract || '')).toLowerCase();
    return kwsLower.some(kw => text.includes(kw));
  });
}

// Keep papers where citationCount >= min (undefined/null treated as 0).
function applyCitationFilter(arr, min) {
  if (!min || min === 0) return arr;
  return arr.filter(p => (p.citationCount || 0) >= min);
}

// ‚îÄ‚îÄ Citation velocity helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Returns citations per year since publication. Papers published this year
// get a minimum age of 1 to avoid division-by-zero / inflation.
function citationVelocity(paper) {
  const count   = paper.citationCount || 0;
  const pubYear = paper.publicationDate
    ? new Date(paper.publicationDate).getFullYear()
    : (paper.year || null);
  if (!pubYear) return 0;
  const yearsOld = Math.max(1, new Date().getFullYear() - pubYear + 1);
  return count / yearsOld;
}

// Returns 'trending' (‚â•20/yr) | 'growing' (5-20/yr) | 'stable' (<5/yr)
function velocityLabel(paper) {
  const v = citationVelocity(paper);
  if (v >= 20) return 'trending';
  if (v >= 5)  return 'growing';
  return 'stable';
}

// ‚îÄ‚îÄ New filter functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Keep papers where influentialCitationCount >= min.
function applyInflCitationFilter(arr, min) {
  if (!min || min === 0) return arr;
  return arr.filter(p => (p.influentialCitationCount || 0) >= min);
}

// Keep papers whose citation velocity matches the given label.
// 'any' returns all papers unchanged.
function applyVelocityFilter(arr, v) {
  if (!v || v === 'any') return arr;
  return arr.filter(p => velocityLabel(p) === v);
}

// Keep open-access papers only (when oa === true).
function applyOpenAccessFilter(arr, oa) {
  if (!oa) return arr;
  return arr.filter(p => !!p.isOpenAccess);
}

// Keep papers matching the publication type.
// Uses publicationVenue.type from Semantic Scholar; falls back to ArXiv
// external ID for preprints that have no venue set.
function applyPubTypeFilter(arr, type) {
  if (!type || type === 'all') return arr;
  return arr.filter(p => {
    const venueType = (p.publicationVenue?.type || '').toLowerCase();
    if (type === 'journal')    return venueType.includes('journal');
    if (type === 'conference') return venueType.includes('conference') || venueType.includes('workshop');
    if (type === 'preprint')   return venueType.includes('preprint') || venueType.includes('arxiv') ||
                                      (p.externalIds?.ArXiv && !venueType);
    return true;
  });
}

// Keep papers that have at least one fieldsOfStudy value matching the
// selected fields array. [] = no filter (return all).
function applyFieldsFilter(arr, fields) {
  if (!fields || fields.length === 0) return arr;
  const fLower = fields.map(f => f.toLowerCase());
  return arr.filter(p =>
    (p.fieldsOfStudy || []).some(f => fLower.includes(f.toLowerCase()))
  );
}

// Sort a copy of the array by the given order. Does NOT mutate input.
function applySortOrder(arr, order) {
  const a = arr.slice();
  if (order === 'newest') {
    return a.sort((x, y) => {
      const dx = x.publicationDate || (x.year ? `${x.year}-12-31` : '0000-01-01');
      const dy = y.publicationDate || (y.year ? `${y.year}-12-31` : '0000-01-01');
      return dy.localeCompare(dx);
    });
  }
  if (order === 'oldest') {
    return a.sort((x, y) => {
      const dx = x.publicationDate || (x.year ? `${x.year}-01-01` : '9999-12-31');
      const dy = y.publicationDate || (y.year ? `${y.year}-01-01` : '9999-12-31');
      return dx.localeCompare(dy);
    });
  }
  if (order === 'relevance') {
    return a.sort((x, y) => y.score - x.score);
  }
  if (order === 'cited') {
    return a.sort((x, y) => (y.citationCount || 0) - (x.citationCount || 0));
  }
  if (order === 'influential') {
    return a.sort((x, y) => (y.influentialCitationCount || 0) - (x.influentialCitationCount || 0));
  }
  if (order === 'trending') {
    return a.sort((x, y) => citationVelocity(y) - citationVelocity(x));
  }
  return a;
}

// Returns the active keyword phrases found in a paper's title+abstract.
function getMatchedKeywords(paper) {
  const active = activeKeywords();
  if (!active.length) return [];
  const text = ((paper.title || '') + ' ' + (paper.abstract || '')).toLowerCase();
  return active.filter(kw => text.includes(kw.toLowerCase()));
}

// Wrap each occurrence of query in the pre-escaped text with <mark>.
// IMPORTANT: text must already be HTML-escaped before calling this function.
// We never inject user input as HTML ‚Äî only hard-coded <mark> tags are inserted.
function highlightSearchTerms(text, q) {
  if (!q || !q.trim()) return text;
  // Escape regex special characters so they're treated as literals
  const escaped = q.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex   = new RegExp(escaped, 'gi');
  return text.replace(regex, match => `<mark class="search-highlight">${match}</mark>`);
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  API FETCH
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function fetchOneKeyword(keyword) {
  const params = new URLSearchParams({
    query:  keyword,
    fields: API_FIELDS,
    limit:  10,
  });
  const res  = await fetch(`${API_BASE}?${params}`);
  const data = await res.json();
  if (res.status === 429 || (data.message && !data.data)) {
    throw new Error('Rate limited by Semantic Scholar. Wait 30 seconds and click Refresh.');
  }
  if (!res.ok) {
    throw new Error(`Semantic Scholar API error (${res.status}). Try again shortly.`);
  }
  return data.data || [];
}

function wait(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function fetchPapers() {
  if (loading) return;

  const active = activeKeywords();
  if (active.length === 0) {
    setStatus('No active keywords. Enable at least one keyword in settings.', true);
    return;
  }

  loading = true;
  setStatus(`Fetching papers for ${active.length} keyword${active.length > 1 ? 's' : ''}‚Ä¶`);
  showSkeletons();
  setRefreshSpinning(true);

  try {
    const seen    = new Set();
    const results = [];

    for (let i = 0; i < active.length; i++) {
      if (i > 0) await wait(500);
      setStatus(`Fetching papers‚Ä¶ (${i + 1}/${active.length})`);
      try {
        const batch = await fetchOneKeyword(active[i]);
        for (const paper of batch) {
          if (paper.title && paper.paperId && !seen.has(paper.paperId)) {
            seen.add(paper.paperId);
            results.push(paper);
          }
        }
      } catch (kwErr) {
        console.warn(`Skipping keyword "${active[i]}": ${kwErr.message}`);
      }
    }

    // Score all results using keyword match + signal history + learned keywords
    allPapers = results.map(p => ({ ...p, score: scoreWithSignals(p) }));

    // One-time migration: move previously-liked papers into the reading list
    migrateOldLikesToReadingList();

    // Apply filters and sort to derive the view
    papers    = applyFiltersAndSort(allPapers);
    pageIndex = 0;

    if (allPapers.length === 0) {
      setStatus('No papers found. The API may be rate-limited ‚Äî wait 30 seconds and click Refresh.', true);
    } else {
      const now = new Date();
      localStorage.setItem(LAST_FETCH_KEY, now.toISOString());
      setStatus(''); // clear status; feed header shows count
      runHealthCheck();
    }

    // Track unread BEFORE updating seen (so new papers show as unread this session)
    renderPapers();

    // After rendering, mark current papers as seen for next session
    updateSeenPapers();
    // Update the in-memory seenPaperIds so they don't show as unread in this session
    allPapers.forEach(p => { if (p.paperId) seenPaperIds.add(p.paperId); });

    // Load user actions if signed in
    if (currentUser) {
      await loadUserActions(); // will call renderPapers() again with actions
    }

  } catch (err) {
    console.error('Fetch error:', err);
    const msg = err.message === 'Failed to fetch'
      ? 'Could not reach local server. Make sure server.py is running.'
      : err.message;
    setStatus(msg, true);
    document.getElementById('paperFeed').innerHTML = '';
  } finally {
    loading = false;
    setRefreshSpinning(false);
  }
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SEARCH BAR
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function handleSearchInput(e) {
  const val = e.target.value;
  const clearBtn = document.getElementById('searchClearBtn');
  clearBtn.style.display = val ? 'block' : 'none';

  // Debounce: wait 300ms after typing stops before filtering
  clearTimeout(searchTimer);
  searchTimer = setTimeout(() => {
    searchQuery = val;
    applyAndRender();
  }, 300);
}

function clearSearch() {
  searchQuery = '';
  const input = document.getElementById('searchInput');
  if (input) input.value = '';
  document.getElementById('searchClearBtn').style.display = 'none';
  applyAndRender();
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  FILTER PANEL
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Renders ALL filter groups from scratch.
// Called on init and whenever keyword list changes.
function renderFilterPanel() {
  renderScoreFilterGroup();
  renderDateFilterGroup();
  renderStatusFilterGroup();
  renderKeywordFilterGroup();
  renderCitationFilterGroup();
  renderInflCitationFilterGroup();
  renderVelocityFilterGroup();
  renderOpenAccessFilterGroup();
  renderPubTypeFilterGroup();
  renderFieldsFilterGroup();
  renderActiveFilterTags();

  // Auto-expand advanced section if any advanced filter is currently active,
  // so users returning with an active filter don't lose their context.
  const hasAdvancedActive =
    (filterState.keywords     && filterState.keywords.length > 0)   ||
    filterState.citations     > 0                                    ||
    filterState.inflCitations > 0                                    ||
    (filterState.velocity     && filterState.velocity !== 'any')     ||
    filterState.openAccess                                           ||
    (filterState.pubType      && filterState.pubType !== 'all')      ||
    (filterState.fields       && filterState.fields.length > 0);

  const advSec = document.getElementById('filterAdvancedSection');
  const advBtn = document.getElementById('filterAdvancedToggle');
  if (advSec && advBtn && hasAdvancedActive) {
    advSec.style.display = 'flex';
    advBtn.textContent   = 'Advanced filters ‚ñ¥';
  }
}

function renderScoreFilterGroup() {
  const el = document.getElementById('scoreFilterGroup');
  if (!el) return;
  el.innerHTML = [1, 2, 3, 4, 5].map(s => `
    <label class="filter-option-label">
      <input type="checkbox" value="${s}"
             ${filterState.scores.includes(s) ? 'checked' : ''}
             data-filter="score">
      ‚òÖ${s}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="score"]').forEach(inp => {
    inp.addEventListener('change', () => {
      const checked = [...el.querySelectorAll('input[data-filter="score"]')]
        .filter(i => i.checked).map(i => Number(i.value));
      filterState.scores = checked.length ? checked : [1, 2, 3, 4, 5];
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderDateFilterGroup() {
  const el = document.getElementById('dateFilterGroup');
  if (!el) return;
  const options = [
    { val: 'all',  label: 'All time' },
    { val: '7d',   label: 'Last 7 days' },
    { val: '30d',  label: 'Last 30 days' },
    { val: '90d',  label: 'Last 3 months' },
    { val: '1y',   label: 'Last year' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="dateFilter" value="${o.val}"
             ${filterState.dateRange === o.val ? 'checked' : ''}
             data-filter="date">
      ${o.label}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="date"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.dateRange = inp.value;
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderStatusFilterGroup() {
  const el = document.getElementById('statusFilterGroup');
  if (!el) return;
  const options = [
    { val: 'all',    label: 'All' },
    { val: 'unread', label: 'Unread' },
    { val: 'liked',  label: 'Liked' },
    { val: 'saved',  label: 'Saved' },
    { val: 'hidden', label: 'Hidden' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="statusFilter" value="${o.val}"
             ${filterState.status === o.val ? 'checked' : ''}
             data-filter="status">
      ${o.label}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="status"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.status = inp.value;
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

// Re-renders only the keyword filter group (called when keywords change).
function renderKeywordFilterGroup() {
  const el = document.getElementById('keywordFilterGroup');
  if (!el) return;
  const active = activeKeywords();
  if (active.length === 0) {
    el.innerHTML = '<span style="font-size:0.75rem; color:var(--text-muted)">No active keywords</span>';
    return;
  }
  el.innerHTML = active.map(kw => `
    <label class="filter-option-label">
      <input type="checkbox" value="${esc(kw)}"
             ${filterState.keywords.includes(kw) ? 'checked' : ''}
             data-filter="keyword">
      ${esc(kw)}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="keyword"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.keywords = [...el.querySelectorAll('input[data-filter="keyword"]')]
        .filter(i => i.checked).map(i => i.value);
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderCitationFilterGroup() {
  const el = document.getElementById('citationFilterGroup');
  if (!el) return;
  const options = [
    { val: 0,   label: 'Any' },
    { val: 10,  label: '‚â•10' },
    { val: 50,  label: '‚â•50' },
    { val: 100, label: '‚â•100' },
    { val: 500, label: '‚â•500' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="citationFilter" value="${o.val}"
             ${filterState.citations === o.val ? 'checked' : ''}
             data-filter="citation">
      ${o.label}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="citation"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.citations = Number(inp.value);
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderInflCitationFilterGroup() {
  const el = document.getElementById('inflCitationFilterGroup');
  if (!el) return;
  const options = [
    { val: 0,  label: 'Any' },
    { val: 5,  label: '‚â•5' },
    { val: 10, label: '‚â•10' },
    { val: 25, label: '‚â•25' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="inflCitationFilter" value="${o.val}"
             ${filterState.inflCitations === o.val ? 'checked' : ''}
             data-filter="inflCitation">
      ${o.label}
    </label>
  `).join('');
  el.querySelectorAll('input[data-filter="inflCitation"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.inflCitations = Number(inp.value);
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderVelocityFilterGroup() {
  const el = document.getElementById('velocityFilterGroup');
  if (!el) return;
  const options = [
    { val: 'any',      label: 'Any' },
    { val: 'trending', label: 'üî• Trending (‚â•20/yr)' },
    { val: 'growing',  label: '‚Üó Growing (5‚Äì20/yr)' },
    { val: 'stable',   label: '‚Üí Stable (<5/yr)' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="velocityFilter" value="${o.val}"
             ${filterState.velocity === o.val ? 'checked' : ''}
             data-filter="velocity">
      ${o.label}
    </label>
  `).join('');
  el.querySelectorAll('input[data-filter="velocity"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.velocity = inp.value;
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderOpenAccessFilterGroup() {
  const el = document.getElementById('openAccessFilterGroup');
  if (!el) return;
  el.innerHTML = `
    <label class="filter-option-label">
      <input type="checkbox" data-filter="openAccess"
             ${filterState.openAccess ? 'checked' : ''}>
      üîì Open Access only
    </label>`;
  el.querySelector('input[data-filter="openAccess"]').addEventListener('change', (e) => {
    filterState.openAccess = e.target.checked;
    renderActiveFilterTags();
    applyAndRender();
  });
}

function renderPubTypeFilterGroup() {
  const el = document.getElementById('pubTypeFilterGroup');
  if (!el) return;
  const options = [
    { val: 'all',        label: 'All' },
    { val: 'journal',    label: 'Journal' },
    { val: 'conference', label: 'Conference' },
    { val: 'preprint',   label: 'Preprint' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="pubTypeFilter" value="${o.val}"
             ${filterState.pubType === o.val ? 'checked' : ''}
             data-filter="pubType">
      ${o.label}
    </label>
  `).join('');
  el.querySelectorAll('input[data-filter="pubType"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.pubType = inp.value;
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

// Renders checkboxes for all unique fields of study present in allPapers.
function renderFieldsFilterGroup() {
  const el = document.getElementById('fieldsFilterGroup');
  if (!el) return;

  // Collect unique fields from current allPapers, sorted alphabetically (max 15)
  const fieldSet = new Set();
  allPapers.forEach(p => (p.fieldsOfStudy || []).forEach(f => fieldSet.add(f)));
  const allFields = [...fieldSet].sort().slice(0, 15);

  if (allFields.length === 0) {
    el.innerHTML = '<span style="color:var(--text-muted);font-size:0.78rem">No papers loaded yet</span>';
    return;
  }

  el.innerHTML = allFields.map(f => `
    <label class="filter-option-label">
      <input type="checkbox" data-filter="field" value="${esc(f)}"
             ${filterState.fields.includes(f) ? 'checked' : ''}>
      ${esc(f)}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="field"]').forEach(inp => {
    inp.addEventListener('change', () => {
      if (inp.checked) {
        if (!filterState.fields.includes(inp.value)) {
          filterState.fields = [...filterState.fields, inp.value];
        }
      } else {
        filterState.fields = filterState.fields.filter(f => f !== inp.value);
      }
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

// Build the active filter tag data: each non-default filter gets a pill.
function buildActiveFilterTags() {
  const tags = [];

  if (searchQuery) {
    tags.push({ label: `Search: "${searchQuery}"`, clearFn: clearSearch });
  }
  if (filterState.scores.length < 5) {
    const label = 'Score: ' + filterState.scores.map(s => '‚òÖ' + s).join(' ');
    tags.push({ label, clearFn: () => {
      filterState.scores = [1, 2, 3, 4, 5];
      renderFilterPanel(); applyAndRender();
    }});
  }
  if (filterState.dateRange !== 'all') {
    const labels = { '7d': 'Last 7 days', '30d': 'Last 30 days', '90d': 'Last 3 months', '1y': 'Last year' };
    tags.push({ label: labels[filterState.dateRange] || filterState.dateRange, clearFn: () => {
      filterState.dateRange = 'all'; renderFilterPanel(); applyAndRender();
    }});
  }
  if (filterState.status !== 'all') {
    tags.push({ label: `Status: ${filterState.status}`, clearFn: () => {
      filterState.status = 'all'; renderFilterPanel(); applyAndRender();
    }});
  }
  filterState.keywords.forEach(kw => {
    tags.push({ label: `Keyword: ${kw}`, clearFn: () => {
      filterState.keywords = filterState.keywords.filter(k => k !== kw);
      renderFilterPanel(); applyAndRender();
    }});
  });
  if (filterState.citations > 0) {
    tags.push({ label: `Citations ‚â•${filterState.citations}`, clearFn: () => {
      filterState.citations = 0; renderFilterPanel(); applyAndRender();
    }});
  }
  if (filterState.inflCitations > 0) {
    tags.push({ label: `Influential ‚â•${filterState.inflCitations}`, clearFn: () => {
      filterState.inflCitations = 0; renderFilterPanel(); applyAndRender();
    }});
  }
  if (filterState.velocity !== 'any') {
    const velLabels = { trending: 'üî• Trending', growing: '‚Üó Growing', stable: '‚Üí Stable' };
    tags.push({ label: `Velocity: ${velLabels[filterState.velocity] || filterState.velocity}`, clearFn: () => {
      filterState.velocity = 'any'; renderFilterPanel(); applyAndRender();
    }});
  }
  if (filterState.openAccess) {
    tags.push({ label: 'üîì Open Access only', clearFn: () => {
      filterState.openAccess = false; renderFilterPanel(); applyAndRender();
    }});
  }
  if (filterState.pubType !== 'all') {
    const typeLabels = { journal: 'Journal', conference: 'Conference', preprint: 'Preprint' };
    tags.push({ label: `Type: ${typeLabels[filterState.pubType] || filterState.pubType}`, clearFn: () => {
      filterState.pubType = 'all'; renderFilterPanel(); applyAndRender();
    }});
  }
  filterState.fields.forEach(f => {
    tags.push({ label: `Field: ${f}`, clearFn: () => {
      filterState.fields = filterState.fields.filter(x => x !== f);
      renderFilterPanel(); applyAndRender();
    }});
  });
  return tags;
}

// Render the pill tags row and update badge count.
function renderActiveFilterTags() {
  const container = document.getElementById('activeFilterTags');
  const badge     = document.getElementById('filterActiveCount');
  const clearBtn  = document.getElementById('clearAllFiltersBtn');
  if (!container) return;

  const tags = buildActiveFilterTags();

  if (tags.length === 0) {
    container.innerHTML = '';
    badge.style.display    = 'none';
    clearBtn.style.display = 'none';
    return;
  }

  badge.textContent  = tags.length;
  badge.style.display    = 'inline-block';
  clearBtn.style.display = 'inline-block';

  container.innerHTML = tags.map((t, i) => `
    <span class="filter-tag">
      ${esc(t.label)}
      <button class="filter-tag-remove" data-tag-idx="${i}" aria-label="Remove filter">√ó</button>
    </span>
  `).join('');

  container.querySelectorAll('.filter-tag-remove').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      tags[parseInt(btn.dataset.tagIdx)].clearFn();
    });
  });
}

// Reset all filters and search to defaults.
function clearAllFilters() {
  filterState = {
    scores:        [1, 2, 3, 4, 5],
    dateRange:     'all',
    status:        'all',
    keywords:      [],
    citations:     0,
    inflCitations: 0,
    velocity:      'any',
    openAccess:    false,
    pubType:       'all',
    fields:        [],
  };
  searchQuery = '';
  sortOrder   = 'newest';
  pageIndex   = 0;
  const input = document.getElementById('searchInput');
  if (input) input.value = '';
  document.getElementById('searchClearBtn').style.display = 'none';
  document.getElementById('sortSelect').value = 'newest';
  renderFilterPanel();
  applyAndRender();
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  USER ACTIONS: Like / Save / Hide / Copy citation
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Show a contextual sign-in popover anchored above the clicked action button.
// Triggered when a signed-out user clicks Like, Save, or Hide.
function showSigninPopover(paperId, action) {
  // Remove any existing popover first
  document.querySelectorAll('.signin-popover').forEach(el => el.remove());

  const card = document.querySelector(`[data-paperid="${paperId}"]`);
  if (!card) return;
  const btn = card.querySelector(`[data-action="${action}"]`);
  if (!btn) return;

  const pop = document.createElement('div');
  pop.className = 'signin-popover';
  pop.innerHTML = `Sign in to save your actions &nbsp;<a id="signinPopoverLink">Sign in with Google</a>`;

  // Anchor the popover to the button (button needs relative positioning)
  btn.style.position = 'relative';
  btn.appendChild(pop);

  document.getElementById('signinPopoverLink')?.addEventListener('click', (e) => {
    e.stopPropagation();
    signIn();
    pop.remove();
  });

  // Auto-dismiss after 4s
  const timer = setTimeout(() => pop.remove(), 4000);
  // Dismiss on any outside click
  const dismiss = (e) => {
    if (!pop.contains(e.target)) {
      pop.remove();
      clearTimeout(timer);
      document.removeEventListener('click', dismiss);
    }
  };
  setTimeout(() => document.addEventListener('click', dismiss), 0);
}

// Route an action button click to the correct handler.
function handlePaperAction(paperId, action) {
  if (!currentUser) {
    // Show contextual sign-in prompt instead of silently failing
    showSigninPopover(paperId, action);
    return;
  }

  const paper = allPapers.find(p => p.paperId === paperId);

  if (action === 'like') {
    const current = userActions[paperId]?.liked || false;
    const newVal  = !current;
    saveUserAction(paperId, 'liked', newVal);
    recordSignal(paperId, 'liked', newVal);
    if (newVal && paper) {
      // Like = pure learning signal. The card STAYS in the feed.
      // Keywords are learned and the score is updated in-place.
      addLearnedKeywords(paper);
      const updated = { ...paper, score: scoreWithSignals(paper) };
      allPapers = allPapers.map(p => p.paperId === paperId ? updated : p);
      updateCardActionDisplay(paperId);
      showToast('Liked ‚Äî this helps tune your feed');
    } else if (!newVal) {
      // Un-liking: restore default state
      updateCardActionDisplay(paperId);
      if (filterState.status === 'liked') applyAndRender();
    }
  } else if (action === 'save') {
    const current = userActions[paperId]?.saved || false;
    const newVal  = !current;
    saveUserAction(paperId, 'saved', newVal);
    recordSignal(paperId, 'saved', newVal);
    if (newVal && paper) {
      // Positive signal: learn keywords and rescore
      addLearnedKeywords(paper);
      const updated = { ...paper, score: scoreWithSignals(paper) };
      allPapers = allPapers.map(p => p.paperId === paperId ? updated : p);

      // Save also adds to Reading List and animates card out of feed
      addToReadingList(updated);
      animateCardOut(paperId, () => applyAndRender());

      // Undo toast ‚Äî undo removes from RL + un-saves
      showToastWithUndo('Saved to Reading List', () => {
        removeFromReadingList(paperId, /* silent */ true);
        saveUserAction(paperId, 'saved', false);
        recordSignal(paperId, 'saved', false);
        allPapers = allPapers.map(p => p.paperId === paperId ? { ...p, score: scoreWithSignals(p) } : p);
        applyAndRender();
      });
    } else if (!newVal) {
      // Un-saving manually (e.g. from a future saved-filter view) ‚Äî just update display
      updateCardActionDisplay(paperId);
      if (filterState.status === 'saved') applyAndRender();
    }
  } else if (action === 'hide') {
    const current = userActions[paperId]?.hidden || false;
    const newVal  = !current;
    saveUserAction(paperId, 'hidden', newVal);
    if (newVal) recordSignal(paperId, 'removed', true); // strong negative signal
    if (newVal && !showHidden) {
      // Fade out then remove
      const card = document.querySelector(`[data-paperid="${paperId}"]`);
      if (card) {
        card.classList.add('paper-card--fading');
        setTimeout(() => applyAndRender(), 380);
      }
    } else {
      updateCardActionDisplay(paperId);
      if (filterState.status === 'hidden') applyAndRender();
    }
  } else if (action === 'copy') {
    copyCitation(paperId);
  }
}

// Update just the action buttons of one card without re-rendering the whole feed.
function updateCardActionDisplay(paperId) {
  const card = document.querySelector(`[data-paperid="${paperId}"]`);
  if (!card) return;
  const a = userActions[paperId] || {};
  const isSignedIn = !!currentUser;

  const likeBtn = card.querySelector('.like-btn');
  const saveBtn = card.querySelector('.save-btn');
  const hideBtn = card.querySelector('.hide-btn');

  if (likeBtn) {
    likeBtn.classList.toggle('active', !!a.liked);
    likeBtn.innerHTML = a.liked
      ? `<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg> Liked`
      : `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/></svg> Like`;
  }
  if (saveBtn) {
    saveBtn.classList.toggle('active', !!a.saved);
    saveBtn.innerHTML = a.saved
      ? `<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/></svg> Saved`
      : `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/></svg> Save`;
  }
  if (hideBtn) {
    hideBtn.classList.toggle('active', !!a.hidden);
    hideBtn.innerHTML = a.hidden
      ? `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg> Unhide`
      : `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg> Hide`;
  }
}

// Format an APA-ish citation and copy to clipboard.
function copyCitation(paperId) {
  const paper = allPapers.find(p => p.paperId === paperId);
  if (!paper) return;

  const authors = (paper.authors || []).map(a => a.name).join(', ') || 'Unknown authors';
  const year    = paper.year || 'n.d.';
  const title   = paper.title || 'Untitled';
  const doi     = paper.externalIds?.DOI;
  const url     = doi ? `https://doi.org/${doi}` : paper.url || '';
  const citation = `${authors} (${year}). ${title}.${url ? ' ' + url : ''}`;

  navigator.clipboard.writeText(citation).then(() => {
    const btn = document.querySelector(`[data-paperid="${paperId}"] .copy-btn`);
    if (btn) {
      const orig = btn.textContent;
      btn.textContent = '‚úì Copied!';
      setTimeout(() => { btn.textContent = orig; }, 2000);
    }
  }).catch(err => {
    console.error('Clipboard error:', err);
  });
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  RENDERING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Update the feed header: paper count, unread badge, last refresh time.
function renderFeedHeader() {
  const countEl    = document.getElementById('feedCount');
  const badgeEl    = document.getElementById('unreadBadge');
  const refreshEl  = document.getElementById('feedLastRefreshed');

  if (countEl) {
    countEl.textContent = papers.length === 0
      ? 'No papers'
      : `${papers.length} paper${papers.length !== 1 ? 's' : ''}`;
  }

  // Unread = papers in current allPapers that weren't in last session's seenPaperIds
  const unreadCount = allPapers.filter(p => p.paperId && !seenPaperIds.has(p.paperId)).length;
  // (seenPaperIds is updated AFTER render, so new papers show as unread in this session)
  if (badgeEl) {
    if (unreadCount > 0) {
      badgeEl.textContent  = `${unreadCount} new`;
      badgeEl.style.display = 'inline-block';
    } else {
      badgeEl.style.display = 'none';
    }
  }

  if (refreshEl) {
    try {
      const ts = localStorage.getItem(LAST_FETCH_KEY);
      refreshEl.textContent = ts ? `Updated ${friendlyTime(new Date(ts))}` : '';
    } catch (e) { refreshEl.textContent = ''; }
  }
}

// Build the HTML string for one paper card.
function buildPaperCardHtml(paper) {
  const paperId  = paper.paperId || '';
  const paperUrl = paper.url ||
    (paper.externalIds?.DOI
      ? `https://doi.org/${paper.externalIds.DOI}`
      : `https://www.semanticscholar.org/paper/${paperId}`);

  // ‚îÄ‚îÄ Authors ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const authorsList   = paper.authors || [];
  const firstAuthor   = authorsList[0]?.name || 'Unknown author';
  const firstAuthorId = authorsList[0]?.authorId || '';
  const authorCount   = authorsList.length;
  const authorProfileUrl = firstAuthorId
    ? `https://www.semanticscholar.org/author/${firstAuthorId}`
    : `https://www.semanticscholar.org/search?q=${encodeURIComponent(firstAuthor)}&sort=Relevance`;

  // ‚îÄ‚îÄ Year + "N yrs ago" ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const pubYear = paper.publicationDate
    ? new Date(paper.publicationDate).getFullYear()
    : (paper.year || null);
  const yearDisplay = paper.publicationDate
    ? paper.publicationDate.slice(0, 7)  // "YYYY-MM"
    : (paper.year ? String(paper.year) : 'Year unknown');
  const currentYear = new Date().getFullYear();
  const yearsAgoStr = pubYear && pubYear < currentYear
    ? ` ¬∑ ${currentYear - pubYear} yr${currentYear - pubYear === 1 ? '' : 's'} ago`
    : '';

  // ‚îÄ‚îÄ Open access + PDF ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const isOA   = !!paper.isOpenAccess;
  const pdfUrl = paper.openAccessPdf?.url || null;
  const oaBadge = isOA
    ? `<span class="oa-badge" title="Open Access ‚Äî free to read">üîì</span>`
    : `<span class="oa-badge locked" title="Paywalled">üîí</span>`;
  const pdfLink = pdfUrl
    ? `<a class="pdf-link" href="${esc(pdfUrl)}" target="_blank" rel="noopener">PDF ‚Üó</a>`
    : '';

  // ‚îÄ‚îÄ Score badge ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const scoreClass       = paper.score >= 4 ? 'high' : paper.score >= 2 ? 'mid' : '';
  const scoreExplanation = buildScoreExplanation(paper).join('\n');
  const wildcardTipSeen = localStorage.getItem(WILDCARD_TIP_SEEN_KEY);
  const wildcardBadge   = paper.isWildcard
    ? `<span class="wildcard-badge" title="Explore: outside your usual keywords but highly cited">üîç Explore</span>${
        !wildcardTipSeen
          ? `<span class="wildcard-first-tip">A highly-cited paper outside your keywords, shown for discovery.
               <button onclick="localStorage.setItem('${WILDCARD_TIP_SEEN_KEY}','1');this.closest('.wildcard-first-tip').remove()" title="Dismiss">√ó</button>
             </span>`
          : ''
      }`
    : '';

  // ‚îÄ‚îÄ Citation metrics ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const citeCount  = typeof paper.citationCount          === 'number' ? paper.citationCount          : null;
  const inflCount  = typeof paper.influentialCitationCount === 'number' ? paper.influentialCitationCount : null;
  const refCount   = typeof paper.referenceCount         === 'number' ? paper.referenceCount         : null;

  // Colour tier for total citations
  const citeBadgeClass = citeCount === null ? ''
    : citeCount < 10  ? 'cite-grey'
    : citeCount < 50  ? 'cite-blue'
    : citeCount < 200 ? 'cite-green'
    : 'cite-gold';

  // Citation velocity ‚Äî compute actual rate for the tooltip
  const vel      = velocityLabel(paper);
  const velClass = `velocity-${vel}`;
  const velIcon  = vel === 'trending' ? 'üî•' : vel === 'growing' ? '‚Üó' : '‚Üí';
  const velText  = vel === 'trending' ? 'Trending' : vel === 'growing' ? 'Growing' : 'Stable';
  const velRate  = citationVelocity(paper);
  const velRateStr = velRate >= 10 ? Math.round(velRate) : velRate.toFixed(1);
  const velTooltip = vel === 'trending'
    ? `üî• Trending ‚Äî ${velRateStr} citations/year. This paper is gaining citations rapidly.`
    : vel === 'growing'
    ? `‚Üó Growing ‚Äî ${velRateStr} citations/year. Steadily building impact.`
    : `‚Üí Stable ‚Äî ${velRateStr} citations/year. Cited occasionally but not accelerating.`;

  // Highly influential badge (inflCitations ‚â• 10)
  const highlyInflBadge = (inflCount !== null && inflCount >= 10)
    ? `<span class="metric highly-influential-badge" title="This paper has ‚â•10 influential citations">üèÜ Highly Influential</span>`
    : '';

  // ‚îÄ‚îÄ Venue ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const venueName = paper.publicationVenue?.name || '';
  const venueHtml = venueName
    ? `<span class="metric venue-name" title="${esc(venueName)}">${esc(venueName.length > 45 ? venueName.slice(0, 42) + '‚Ä¶' : venueName)}</span>`
    : '';

  // ‚îÄ‚îÄ Fields of study (max 3 tags) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const fields    = (paper.fieldsOfStudy || []).slice(0, 3);
  const fieldTagsHtml = fields.length
    ? `<div class="field-tags">${fields.map(f => `<span class="field-tag">${esc(f)}</span>`).join('')}</div>`
    : '';

  // ‚îÄ‚îÄ Metrics row ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Citation count ‚Üí SS "cited-by" page; ref count ‚Üí SS references page
  const ssBase      = `https://www.semanticscholar.org/paper/${esc(paperId)}`;
  const citedByUrl  = `${ssBase}#citing-papers`;
  const refsUrl     = `${ssBase}#references`;

  const metricsHtml = `
    <div class="paper-metrics">
      ${citeCount !== null
        ? `<a class="metric metric-link ${citeBadgeClass}" href="${citedByUrl}" target="_blank" rel="noopener"
              title="Cited by ${citeCount} paper${citeCount !== 1 ? 's' : ''} ‚Äî click to see who cited this on Semantic Scholar">üìÑ ${citeCount} cited</a>`
        : ''}
      ${inflCount !== null
        ? `<span class="metric" title="Influential citations ‚Äî ${inflCount} paper${inflCount !== 1 ? 's' : ''} that substantially built on this work (Semantic Scholar calculates this separately from total citations)">‚≠ê ${inflCount} infl.</span>`
        : ''}
      ${refCount  !== null
        ? `<a class="metric metric-link" href="${refsUrl}" target="_blank" rel="noopener"
              title="${refCount} reference${refCount !== 1 ? 's' : ''} ‚Äî click to see what this paper cites on Semantic Scholar">‚Üô ${refCount} refs</a>`
        : ''}
      <span class="metric ${velClass}" title="${esc(velTooltip)}">${velIcon} ${velText}</span>
      ${highlyInflBadge}
      ${venueHtml}
    </div>
    ${fieldTagsHtml}`;

  // ‚îÄ‚îÄ Abstract ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const rawAbstract  = paper.abstract || '';
  const abstractHtml = rawAbstract
    ? highlightSearchTerms(esc(rawAbstract), searchQuery)
    : '<em style="color:var(--text-muted)">No abstract available.</em>';

  // ‚îÄ‚îÄ Title ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const titleHtml = highlightSearchTerms(esc(paper.title || 'Untitled'), searchQuery);

  // ‚îÄ‚îÄ Matched keyword tags ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const matched    = getMatchedKeywords(paper);
  const kwTagsHtml = matched.length
    ? `<div class="paper-keyword-tags">${matched.map(k => `<span class="matched-kw-tag">${esc(k)}</span>`).join('')}</div>`
    : '';

  // ‚îÄ‚îÄ Unread indicator ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const isUnread = paperId && !seenPaperIds.has(paperId);

  // ‚îÄ‚îÄ Action buttons ‚Äî disabled when signed out ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const a           = userActions[paperId] || {};
  const disabledCls = currentUser ? '' : ' disabled-action';

  // SVG icon sets ‚Äî outline = default, filled = active state
  const svgHeart = a.liked
    ? `<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg> Liked`
    : `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/></svg> Like`;

  const svgBookmark = a.saved
    ? `<svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/></svg> Saved`
    : `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/></svg> Save`;

  const svgEye = a.hidden
    ? `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg> Unhide`
    : `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg> Hide`;

  const svgCite = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg> Cite`;

  return `
    <article class="paper-card${isUnread ? ' paper-card--unread' : ''}${paper.isWildcard ? ' paper-card--wildcard' : ''}" data-paperid="${esc(paperId)}">
      <div class="paper-card-top">
        <h2 class="paper-title">
          <a href="${esc(paperUrl)}" target="_blank" rel="noopener">
            ${titleHtml}
          </a>
        </h2>
        <div class="paper-card-badges">
          ${wildcardBadge}
          <span class="score-badge ${scoreClass}" title="Relevance score: ${paper.score}/5 (matches your keywords ‚Äî not a star rating)&#10;${esc(scoreExplanation)}">
            ‚òÖ ${paper.score}/5
          </span>
        </div>
      </div>
      <div class="paper-meta">
        <a class="author-link" href="${esc(authorProfileUrl)}" target="_blank" rel="noopener"
           title="View author profile on Semantic Scholar">${esc(firstAuthor)}</a>${authorCount > 1
          ? ` <span class="author-count">+${authorCount - 1} author${authorCount > 2 ? 's' : ''}</span>` : ''}
        &nbsp;¬∑&nbsp; ${esc(yearDisplay)}${esc(yearsAgoStr)}
        &nbsp; ${oaBadge} ${pdfLink}
      </div>
      <p class="paper-abstract" id="abstract-${esc(paperId)}">${abstractHtml}</p>
      ${rawAbstract.length > 300
        ? `<button class="expand-btn" data-paperid="${esc(paperId)}">Show more</button>`
        : ''}
      ${metricsHtml}
      ${kwTagsHtml}
      <div class="paper-actions">
        <button class="action-btn like-btn${a.liked ? ' active' : ''}${disabledCls}"
                data-paperid="${esc(paperId)}" data-action="like"
                title="Like ‚Äî signals relevance to your interests. Stays in feed.">${svgHeart}</button>
        <button class="action-btn save-btn${a.saved ? ' active' : ''}${disabledCls}"
                data-paperid="${esc(paperId)}" data-action="save"
                title="Save ‚Äî adds to your Reading List. Removes from feed.">
          <span class="action-btn-hint">Moves to Reading List</span>${svgBookmark}</button>
        <button class="action-btn hide-btn${a.hidden ? ' active' : ''}${disabledCls}"
                data-paperid="${esc(paperId)}" data-action="hide">${svgEye}</button>
        <button class="action-btn copy-btn"
                data-paperid="${esc(paperId)}" data-action="copy">${svgCite}</button>
      </div>
    </article>
  `;
}

// Render the current page slice of papers[] into #paperFeed.
function renderPapers() {
  renderFeedHeader();
  const feed = document.getElementById('paperFeed');

  if (papers.length === 0) {
    feed.innerHTML = renderEmptyState();
    return;
  }

  // Show a paginated slice: first (pageIndex+1)*PAGE_SIZE papers
  const rawSlice = papers.slice(0, (pageIndex + 1) * PAGE_SIZE);
  const hasMore  = papers.length > rawSlice.length;

  // Inject a wildcard paper every 10th slot (index 9, 19, 29...) for diversity
  const slice = rawSlice.slice(); // copy so we don't mutate papers[]
  for (let i = 9; i < slice.length; i += 10) {
    const wildcard = pickWildcard(allPapers, slice);
    if (wildcard) slice.splice(i, 0, wildcard); // insert before pushing index further
  }

  feed.innerHTML = slice.map(p => buildPaperCardHtml(p)).join('') +
    (hasMore ? `
      <div class="feed-load-more">
        <button id="loadMoreBtn">Load more (${papers.length - slice.length} remaining)</button>
      </div>
    ` : '');

  // Bind delegated events
  bindCardActions();

  // Wire up expand buttons ‚Äî also record expand as a mild positive signal
  feed.querySelectorAll('.expand-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const pid   = btn.dataset.paperid;
      const absEl = document.getElementById(`abstract-${pid}`);
      if (!absEl) return;
      const expanded = absEl.classList.toggle('expanded');
      btn.textContent = expanded ? 'Show less' : 'Show more';
      if (expanded) recordSignal(pid, 'expanded', true); // mild +1 signal
    });
  });

  // Track title link clicks as a strong positive signal
  if (!feed._titleClickListener) {
    feed._titleClickListener = (e) => {
      const link = e.target.closest('.paper-title a');
      if (!link) return;
      const card = link.closest('[data-paperid]');
      if (card?.dataset.paperid) {
        recordSignal(card.dataset.paperid, 'clicked', true); // +2 signal
      }
    };
    feed.addEventListener('click', feed._titleClickListener);
  }

  // Time-on-screen tracking via IntersectionObserver
  startVisibilityTracking();

  // Load more button
  const loadMoreBtn = document.getElementById('loadMoreBtn');
  if (loadMoreBtn) {
    loadMoreBtn.addEventListener('click', loadMorePapers);
  }

  // First-visit score badge explainer (shown once, gated by localStorage)
  maybeShowScoreExplainer();
}

// Show a one-time callout below the first score badge explaining what ‚òÖ X/5 means.
// Dismisses permanently when the user clicks "Got it".
function maybeShowScoreExplainer() {
  if (localStorage.getItem(SCORE_TIP_SEEN_KEY)) return;
  const firstBadge = document.querySelector('.paper-card .score-badge');
  if (!firstBadge) return;
  const badgesContainer = firstBadge.closest('.paper-card-badges');
  if (!badgesContainer) return;

  const callout = document.createElement('div');
  callout.className = 'score-explainer-callout';
  callout.innerHTML = `
    <strong>‚òÖ X/5</strong> = how closely this paper matches your keywords.
    Not a star rating ‚Äî generated automatically.
    <button class="score-explainer-dismiss" id="scoreDismissBtn">Got it</button>
  `;
  badgesContainer.appendChild(callout);

  document.getElementById('scoreDismissBtn')?.addEventListener('click', () => {
    localStorage.setItem(SCORE_TIP_SEEN_KEY, '1');
    callout.remove();
  });
}

// Returns an appropriate empty-state HTML string.
function renderEmptyState() {
  if (allPapers.length === 0) {
    return `<div class="empty-state">
      <div class="icon">üìÑ</div>
      No papers found for these keywords. Try adding broader terms or click Refresh.
    </div>`;
  }
  // Papers exist but filters removed all of them
  return `<div class="empty-state">
    <div class="icon">üîç</div>
    No papers match the current filters.
    <br><button class="btn-text" onclick="clearAllFilters()" style="margin-top:8px">Clear filters</button>
  </div>`;
}

// Track how long each paper card is visible on screen.
// Uses IntersectionObserver. Cards must be 50% visible for ‚â•5 seconds to record.
let _visibilityObserver = null;
const _visibilityTimers = new Map(); // paperId ‚Üí { startMs, accumulatedMs }

function startVisibilityTracking() {
  // Disconnect old observer if any
  if (_visibilityObserver) _visibilityObserver.disconnect();

  _visibilityObserver = new IntersectionObserver((entries) => {
    for (const entry of entries) {
      const id = entry.target.dataset?.paperid;
      if (!id) continue;
      if (entry.isIntersecting) {
        // Card entered viewport ‚Äî start timer
        const prev = _visibilityTimers.get(id) || { startMs: null, accumulatedMs: 0 };
        _visibilityTimers.set(id, { startMs: Date.now(), accumulatedMs: prev.accumulatedMs });
      } else {
        // Card left viewport ‚Äî accumulate time
        const t = _visibilityTimers.get(id);
        if (t?.startMs) {
          const elapsed = Date.now() - t.startMs;
          const total   = t.accumulatedMs + elapsed;
          _visibilityTimers.set(id, { startMs: null, accumulatedMs: total });
          // Only record signals for meaningful dwell time (‚â•5 seconds total)
          if (total >= 5000) {
            recordSignal(id, 'secondsVisible', Math.floor(total / 1000));
          }
        }
      }
    }
  }, { threshold: 0.5 }); // fire when ‚â•50% of card is visible

  document.querySelectorAll('.paper-card[data-paperid]').forEach(el => {
    _visibilityObserver.observe(el);
  });
}

// Single delegated listener for all action buttons in the feed.
function bindCardActions() {
  const feed = document.getElementById('paperFeed');
  // Remove any existing listener by replacing the node (simplest approach for a full re-render)
  // We use a named function stored on the element to avoid double-binding.
  if (feed._actionListener) {
    feed.removeEventListener('click', feed._actionListener);
  }
  feed._actionListener = (e) => {
    const btn = e.target.closest('[data-action]');
    if (!btn) return;
    const { paperid, action } = btn.dataset;
    if (paperid && action) handlePaperAction(paperid, action);
  };
  feed.addEventListener('click', feed._actionListener);
}

// Increment pageIndex and append the next slice (no scroll reset).
function loadMorePapers() {
  pageIndex++;
  renderPapers();
}


// ‚îÄ‚îÄ Rendering helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function esc(str) {
  return (str || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

function setStatus(msg, isError = false) {
  const el = document.getElementById('statusBar');
  el.textContent = msg;
  el.className   = 'status-bar' + (isError ? ' error' : '');
}

function setRefreshSpinning(on) {
  document.getElementById('refreshIcon').className = on ? 'btn-spinning' : '';
}

function showSkeletons() {
  const feed = document.getElementById('paperFeed');
  feed.innerHTML = Array.from({ length: 4 }, () => `
    <div class="skeleton-card">
      <div class="skeleton-line" style="width:70%; height:18px;"></div>
      <div class="skeleton-line" style="width:40%; height:12px;"></div>
      <div class="skeleton-line" style="width:100%; height:12px;"></div>
      <div class="skeleton-line" style="width:95%; height:12px;"></div>
      <div class="skeleton-line" style="width:80%; height:12px;"></div>
    </div>
  `).join('');
}


// ‚îÄ‚îÄ Render: keyword chips in settings panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// ‚îÄ‚îÄ Research Profile UI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Renders the "Your Research Profile" section in the settings panel.
// Shows learned keywords, top topics, top authors, and a reset button.
function renderInsightsPanel() {
  const container = document.getElementById('insightsPanelBody');
  if (!container) return;

  if (!currentUser) {
    container.innerHTML = '<p class="insights-empty" style="padding:20px 0;color:var(--text-muted);font-size:0.82rem;">Sign in to see your personalised feed insights.</p>';
    return;
  }

  // Build top 5 topics from signal data
  const topicFreq = {};
  for (const [, s] of Object.entries(userSignals)) {
    const hasPositiveSignal = s.liked || s.saved || s.expanded || s.clicked || (s.secondsVisible || 0) >= 10;
    if (!hasPositiveSignal) continue;
    const words = extractKeywords(s.title || '', s.abstract || '', 5);
    for (const w of words) topicFreq[w] = (topicFreq[w] || 0) + 1;
  }
  const topTopics = Object.entries(topicFreq)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([w]) => w);

  // Build top 5 authors from liked/clicked signals
  const authorFreq = {};
  for (const [, s] of Object.entries(userSignals)) {
    if (!(s.liked || s.clicked)) continue;
    const firstAuthor = s.authors?.[0]?.name;
    if (firstAuthor) authorFreq[firstAuthor] = (authorFreq[firstAuthor] || 0) + 1;
  }
  const topAuthors = Object.entries(authorFreq)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([name]) => name);

  // Render learned keywords as removable chips
  const learnedHtml = learnedKeywords.length
    ? learnedKeywords
        .sort((a, b) => b.weight - a.weight)
        .map(lk => `
          <span class="learned-kw-chip" title="Weight: ${lk.weight.toFixed(1)} ‚Äî click √ó to remove">
            ${esc(lk.text)}
            <button class="remove-learned-btn" data-kw="${esc(lk.text)}" aria-label="Remove ${esc(lk.text)}">√ó</button>
          </span>`)
        .join('')
    : '<span class="insights-empty">Like or save papers to start learning.</span>';

  const topicsHtml = topTopics.length
    ? topTopics.map(t => `<span class="insights-chip">${esc(t)}</span>`).join('')
    : '<span class="insights-empty">No engagement data yet.</span>';

  const authorsHtml = topAuthors.length
    ? topAuthors.map(a => `<span class="insights-chip">${esc(a)}</span>`).join('')
    : '<span class="insights-empty">Like or click papers to track authors.</span>';

  container.innerHTML = `
    <div class="insights-section">
      <h3 class="insights-section-title">Keywords Learned for You</h3>
      <p class="insights-hint">Extracted from papers you liked or saved. Click √ó to remove.</p>
      <div class="learned-kw-list" id="learnedKeywordList">${learnedHtml}</div>
    </div>

    <div class="insights-section">
      <h3 class="insights-section-title">Your Top Topics</h3>
      <div class="insights-chips">${topicsHtml}</div>
    </div>

    <div class="insights-section">
      <h3 class="insights-section-title">Authors You Engage With Most</h3>
      <div class="insights-chips">${authorsHtml}</div>
    </div>

    <hr class="insights-divider">
    <div class="insights-reset-area">
      <div id="resetConfirmArea">
        <button class="btn-reset-profile" id="resetProfileBtn">üîÑ Reset learning profile</button>
      </div>
    </div>
  `;

  // Wire up remove learned keyword buttons
  container.querySelectorAll('.remove-learned-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      removeLearnedKeyword(btn.dataset.kw);
    });
  });

  // Wire up reset button (inline confirmation)
  const resetBtn = document.getElementById('resetProfileBtn');
  if (resetBtn) resetBtn.addEventListener('click', showResetConfirmation);
}


function renderKeywordChips() {
  const list = document.getElementById('keywordList');

  if (keywords.length === 0) {
    list.innerHTML = '<span style="color:var(--text-muted);font-size:0.8rem;">No keywords yet.</span>';
    return;
  }

  list.innerHTML = keywords.map((kw, i) => `
    <span class="keyword-chip ${kw.active ? '' : 'off'}"
          data-index="${i}"
          role="button"
          tabindex="0"
          title="${kw.active ? 'Click to disable' : 'Click to enable'}"
          aria-pressed="${kw.active}">
      ${esc(kw.text)}
      <button class="remove-btn"
              data-remove="${i}"
              title="Remove keyword"
              aria-label="Remove ${esc(kw.text)}">√ó</button>
    </span>
  `).join('');

  list.querySelectorAll('.keyword-chip').forEach(chip => {
    chip.addEventListener('click', (e) => {
      if (e.target.classList.contains('remove-btn')) return;
      toggleKeyword(parseInt(chip.dataset.index));
    });
    chip.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        toggleKeyword(parseInt(chip.dataset.index));
      }
    });
  });

  list.querySelectorAll('.remove-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      removeKeyword(parseInt(btn.dataset.remove));
    });
  });
}


// ‚îÄ‚îÄ Render: active keyword tags below header ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function renderActiveKeywordsBar() {
  const bar    = document.getElementById('activeKeywordsBar');
  const active = activeKeywords();

  if (active.length === 0) {
    bar.innerHTML = '<span class="bar-label">No active keywords</span>';
    return;
  }

  bar.innerHTML =
    '<span class="bar-label">Searching:</span>' +
    active.map(k => `<span class="active-kw-tag">${esc(k)}</span>`).join('');
}


// ‚îÄ‚îÄ Start the app ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
init();
renderKeywordChips();
renderActiveKeywordsBar();

</script>
</body>
</html>
