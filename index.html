<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Research Hub â€” HRI Paper Feed</title>

  <!-- â”€â”€ Firebase SDK (compat mode = no bundler needed, works in plain HTML) â”€â”€ -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

  <style>
    /* â”€â”€ CSS Custom Properties (theme variables) â”€â”€ */
    :root {
      --bg:           #f5f4f0;
      --surface:      #ffffff;
      --border:       #ddd9d0;
      --text:         #1a1a1a;
      --text-muted:   #666;
      --accent:       #2c5f8a;
      --accent-light: #e8f0f8;
      --tag-bg:       #eef2f7;
      --tag-off:      #f0f0f0;
      --tag-off-text: #999;
      --score-high:   #2d7a3a;
      --score-mid:    #8a6d2c;
      --score-low:    #999;
      --shadow:       0 1px 3px rgba(0,0,0,0.08);
      --radius:       6px;
      --font-serif:   Georgia, 'Times New Roman', serif;
      --font-sans:    system-ui, -apple-system, sans-serif;
    }

    /* Dark mode variables */
    [data-theme="dark"] {
      --bg:           #1a1a1e;
      --surface:      #25252b;
      --border:       #38383f;
      --text:         #e8e8e8;
      --text-muted:   #999;
      --accent:       #6aabda;
      --accent-light: #1e2d3d;
      --tag-bg:       #2a3540;
      --tag-off:      #2a2a2f;
      --tag-off-text: #666;
      --score-high:   #5cb86a;
      --score-mid:    #c9a84c;
      --score-low:    #666;
      --shadow:       0 1px 4px rgba(0,0,0,0.3);
    }

    /* â”€â”€ Reset & Base â”€â”€ */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: var(--font-sans);
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
      min-height: 100vh;
      transition: background 0.2s, color 0.2s;
    }

    /* â”€â”€ Layout â”€â”€ */
    .app-wrapper {
      max-width: 860px;
      margin: 0 auto;
      padding: 0 16px 60px;
    }

    /* â”€â”€ Header â”€â”€ */
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 24px 0 20px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 24px;
      gap: 12px;
      flex-wrap: wrap;
    }

    .header-title h1 {
      font-family: var(--font-serif);
      font-size: 1.5rem;
      font-weight: normal;
      letter-spacing: -0.01em;
      color: var(--text);
    }

    .header-title p {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    /* â”€â”€ Buttons â”€â”€ */
    button {
      cursor: pointer;
      font-family: var(--font-sans);
      border: none;
      border-radius: var(--radius);
      transition: opacity 0.15s, background 0.15s;
    }

    button:hover { opacity: 0.85; }
    button:active { opacity: 0.7; }

    .btn-primary {
      background: var(--accent);
      color: #fff;
      padding: 7px 14px;
      font-size: 0.85rem;
    }

    .btn-secondary {
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      padding: 7px 14px;
      font-size: 0.85rem;
    }

    .btn-icon {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 7px 10px;
      font-size: 1rem;
      line-height: 1;
    }

    /* Plain text link button */
    .btn-text {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.8rem;
      padding: 4px 6px;
      text-decoration: underline;
      white-space: nowrap;
    }

    /* Spinning animation for refresh button when loading */
    .btn-spinning { animation: spin 0.8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* â”€â”€ Auth area styles â”€â”€ */

    /* Google sign-in button */
    .btn-signin {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 6px 12px;
      font-size: 0.82rem;
      font-weight: 500;
      white-space: nowrap;
      box-shadow: var(--shadow);
    }

    .btn-signin svg {
      flex-shrink: 0;
    }

    /* Signed-in user display */
    .auth-user {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .user-avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      object-fit: cover;
      border: 1px solid var(--border);
      flex-shrink: 0;
    }

    /* Fallback avatar when no photo */
    .user-avatar-fallback {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: var(--accent);
      color: #fff;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .user-name {
      font-size: 0.82rem;
      color: var(--text-muted);
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .btn-signout {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 0.75rem;
      text-decoration: underline;
      padding: 0;
      cursor: pointer;
    }

    .btn-signout:hover { color: var(--text); opacity: 1; }

    /* Hint shown in settings panel when signed out */
    .signin-notice {
      font-style: italic;
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-bottom: 14px;
    }

    /* Dim the add-keyword row when signed out */
    .add-keyword-row.disabled {
      opacity: 0.45;
      pointer-events: none;
    }

    /* â”€â”€ Settings Panel â”€â”€ */
    .settings-panel {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 24px;
      box-shadow: var(--shadow);
      display: none; /* hidden by default, toggled by JS */
    }

    .settings-panel.open { display: block; }

    .settings-panel h2 {
      font-family: var(--font-serif);
      font-size: 1rem;
      font-weight: normal;
      margin-bottom: 14px;
      color: var(--text);
    }

    /* Keyword chips container */
    .keyword-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
      min-height: 36px;
    }

    /* Each keyword is a toggle chip */
    .keyword-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: var(--tag-bg);
      color: var(--accent);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 4px 10px 4px 12px;
      font-size: 0.8rem;
      cursor: pointer;
      user-select: none;
      transition: background 0.15s, color 0.15s;
    }

    /* Disabled/off chip style */
    .keyword-chip.off {
      background: var(--tag-off);
      color: var(--tag-off-text);
      border-color: var(--border);
      text-decoration: line-through;
    }

    /* The Ã— remove button inside each chip */
    .keyword-chip .remove-btn {
      background: none;
      border: none;
      color: inherit;
      font-size: 1rem;
      line-height: 1;
      padding: 0 0 0 2px;
      opacity: 0.5;
      cursor: pointer;
    }

    .keyword-chip .remove-btn:hover { opacity: 1; }

    /* Add keyword input row */
    .add-keyword-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .add-keyword-row input {
      flex: 1;
      font-family: var(--font-sans);
      font-size: 0.85rem;
      padding: 7px 12px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--bg);
      color: var(--text);
      outline: none;
    }

    .add-keyword-row input:focus { border-color: var(--accent); }

    /* â”€â”€ Active keyword tags shown below header â”€â”€ */
    .active-keywords-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 16px;
      align-items: center;
    }

    .active-keywords-bar .bar-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-right: 4px;
    }

    .active-kw-tag {
      background: var(--accent-light);
      color: var(--accent);
      border-radius: 12px;
      padding: 2px 10px;
      font-size: 0.75rem;
    }

    /* â”€â”€ Search bar â”€â”€ */
    .search-bar-container {
      margin-bottom: 12px;
    }

    .search-input-wrapper {
      position: relative;
      display: flex;
      align-items: center;
    }

    .search-icon {
      position: absolute;
      left: 12px;
      font-size: 0.9rem;
      pointer-events: none;
      color: var(--text-muted);
    }

    .search-input {
      width: 100%;
      font-family: var(--font-sans);
      font-size: 0.9rem;
      padding: 9px 36px 9px 36px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--surface);
      color: var(--text);
      outline: none;
      transition: border-color 0.15s;
    }

    .search-input:focus { border-color: var(--accent); }

    .search-clear-btn {
      position: absolute;
      right: 8px;
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 0.85rem;
      padding: 4px 6px;
      line-height: 1;
      cursor: pointer;
    }

    .search-clear-btn:hover { color: var(--text); opacity: 1; }

    /* Search highlight inside paper cards */
    mark.search-highlight {
      background: #fff176;
      color: inherit;
      border-radius: 2px;
      padding: 0 1px;
    }

    [data-theme="dark"] mark.search-highlight {
      background: #7a6d00;
    }

    /* â”€â”€ Filter panel â”€â”€ */
    .filter-panel {
      margin-bottom: 16px;
    }

    .filter-panel-header {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .filter-toggle-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }

    /* Small badge showing how many filters are active */
    .filter-active-count {
      background: var(--accent);
      color: #fff;
      border-radius: 10px;
      font-size: 0.7rem;
      font-weight: 600;
      padding: 1px 6px;
      min-width: 18px;
      text-align: center;
    }

    /* Active filter tag pills in the header row */
    .active-filter-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      flex: 1;
    }

    .filter-tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: var(--accent-light);
      color: var(--accent);
      border: 1px solid var(--accent);
      border-radius: 12px;
      padding: 2px 8px 2px 10px;
      font-size: 0.75rem;
      white-space: nowrap;
    }

    .filter-tag-remove {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.8rem;
      padding: 0;
      line-height: 1;
      cursor: pointer;
      opacity: 0.6;
    }

    .filter-tag-remove:hover { opacity: 1; }

    /* The collapsible body of the filter panel */
    .filter-panel-body {
      margin-top: 12px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
      display: flex;
      flex-wrap: wrap;
      gap: 16px 24px;
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 140px;
    }

    .filter-group-label {
      font-size: 0.72rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
    }

    .filter-check-row,
    .filter-radio-row {
      display: flex;
      flex-wrap: wrap;
      gap: 4px 6px;
    }

    /* Individual filter option labels */
    .filter-option-label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      padding: 3px 8px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--bg);
      color: var(--text);
      user-select: none;
      white-space: nowrap;
      transition: background 0.12s, border-color 0.12s;
    }

    .filter-option-label input[type="checkbox"],
    .filter-option-label input[type="radio"] {
      display: none; /* we style the label itself as the control */
    }

    .filter-option-label:has(input:checked) {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    .sort-select {
      font-family: var(--font-sans);
      font-size: 0.82rem;
      padding: 5px 8px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      outline: none;
    }

    .sort-select:focus { border-color: var(--accent); }

    /* â”€â”€ Status / error messages â”€â”€ */
    .status-bar {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-bottom: 16px;
      min-height: 20px;
    }

    .status-bar.error { color: #c0392b; }

    /* â”€â”€ Feed header â”€â”€ */
    .feed-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 0.8rem;
    }

    .feed-header-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .feed-header-right {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--text-muted);
    }

    .feed-count {
      font-weight: 600;
      color: var(--text);
    }

    /* Unread badge */
    .unread-badge {
      background: var(--accent);
      color: #fff;
      border-radius: 10px;
      font-size: 0.7rem;
      font-weight: 600;
      padding: 1px 7px;
    }

    .feed-last-refreshed {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    /* "Show hidden" toggle label */
    .toggle-label {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      cursor: pointer;
      user-select: none;
      color: var(--text-muted);
    }

    .toggle-label input[type="checkbox"] {
      cursor: pointer;
      accent-color: var(--accent);
    }

    /* â”€â”€ Paper Feed â”€â”€ */
    .paper-feed {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    /* Individual paper card */
    .paper-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px 22px;
      box-shadow: var(--shadow);
      transition: box-shadow 0.15s, opacity 0.35s, transform 0.35s;
    }

    .paper-card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.12); }

    /* Fading out on hide */
    .paper-card--fading {
      opacity: 0;
      transform: translateY(-6px);
      pointer-events: none;
    }

    .paper-card-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 8px;
    }

    .paper-title {
      font-family: var(--font-serif);
      font-size: 1.05rem;
      line-height: 1.4;
      color: var(--text);
      flex: 1;
    }

    .paper-title a {
      color: inherit;
      text-decoration: none;
    }

    .paper-title a:hover { color: var(--accent); text-decoration: underline; }

    /* Score badge */
    .score-badge {
      flex-shrink: 0;
      font-size: 0.75rem;
      font-weight: 600;
      padding: 3px 8px;
      border-radius: 12px;
      background: var(--tag-bg);
      color: var(--score-low);
      white-space: nowrap;
    }

    .score-badge.high { color: var(--score-high); background: #eef6ef; }
    .score-badge.mid  { color: var(--score-mid);  background: #f6f2ea; }

    [data-theme="dark"] .score-badge.high { background: #1a2e1c; }
    [data-theme="dark"] .score-badge.mid  { background: #2c2718; }

    .paper-meta {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-bottom: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 0 4px;
      align-items: center;
    }

    /* Citation count in meta row */
    .citation-count {
      margin-left: 4px;
      color: var(--text-muted);
    }

    .paper-abstract {
      font-size: 0.88rem;
      color: var(--text);
      line-height: 1.65;
      /* Show first ~4 lines, expandable */
      display: -webkit-box;
      -webkit-line-clamp: 4;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .paper-abstract.expanded {
      display: block;
      -webkit-line-clamp: unset;
    }

    .expand-btn {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.78rem;
      padding: 4px 0;
      margin-top: 4px;
      cursor: pointer;
      display: inline-block;
    }

    .expand-btn:hover { text-decoration: underline; opacity: 1; }

    /* Keyword match tags under abstract */
    .paper-keyword-tags {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .matched-kw-tag {
      background: var(--accent-light);
      color: var(--accent);
      border-radius: 10px;
      padding: 1px 8px;
      font-size: 0.72rem;
    }

    /* â”€â”€ Paper action buttons â”€â”€ */
    .paper-actions {
      display: flex;
      gap: 6px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
      flex-wrap: wrap;
    }

    .action-btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text-muted);
      border-radius: 14px;
      padding: 4px 10px;
      font-size: 0.78rem;
      cursor: pointer;
      transition: background 0.12s, color 0.12s, border-color 0.12s;
      user-select: none;
    }

    .action-btn:hover { opacity: 1; background: var(--tag-bg); color: var(--text); }

    /* Active (toggled on) state */
    .action-btn.active { color: #fff; border-color: transparent; }

    .like-btn.active  { background: #e35; }
    .save-btn.active  { background: var(--score-high); }
    .hide-btn.active  { background: #888; }

    /* Disabled when signed out */
    .action-btn.disabled-action {
      opacity: 0.35;
      pointer-events: none;
      cursor: default;
    }

    /* â”€â”€ Pagination load-more â”€â”€ */
    .feed-load-more {
      text-align: center;
      padding: 8px 0 4px;
    }

    .feed-load-more button {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 9px 28px;
      font-size: 0.85rem;
      border-radius: var(--radius);
    }

    .feed-load-more button:hover { background: var(--tag-bg); opacity: 1; }

    /* â”€â”€ Empty / loading states â”€â”€ */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .empty-state .icon { font-size: 2.5rem; margin-bottom: 12px; }

    /* â”€â”€ Skeleton loading cards â”€â”€ */
    .skeleton-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px 22px;
    }

    .skeleton-line {
      background: var(--border);
      border-radius: 4px;
      margin-bottom: 10px;
      animation: pulse 1.4s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50%       { opacity: 0.5; }
    }

    /* â”€â”€ Footer â”€â”€ */
    footer {
      margin-top: 40px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
      font-size: 0.75rem;
      color: var(--text-muted);
      text-align: center;
    }

    /* â”€â”€ Health / system status bar (bottom of page) â”€â”€ */
    .health-bar {
      margin-top: 12px;
      padding: 6px 12px;
      border-radius: var(--radius);
      font-size: 0.72rem;
      display: inline-block;
      background: var(--tag-bg);
      color: var(--text-muted);
      border: 1px solid var(--border);
    }

    .health-bar.ok    { color: var(--score-high); background: #eef6ef; border-color: #c3e0c7; }
    .health-bar.error { color: #c0392b;           background: #fdf0ef; border-color: #f0c4c0; }

    [data-theme="dark"] .health-bar.ok    { background: #1a2e1c; border-color: #2d4d30; }
    [data-theme="dark"] .health-bar.error { background: #2e1a1a; border-color: #4d2d2d; }

    /* â”€â”€ Responsive â”€â”€ */
    @media (max-width: 600px) {
      .header-title h1 { font-size: 1.2rem; }
      .paper-card { padding: 16px; }
      .paper-title { font-size: 0.95rem; }
      .filter-panel-body { gap: 12px; }
    }
  </style>
</head>
<body>

<div class="app-wrapper">

  <!-- â”€â”€ Header â”€â”€ -->
  <header>
    <div class="header-title">
      <h1>Research Hub</h1>
      <p>HRI Paper Feed â€” Semantic Scholar</p>
    </div>
    <div class="header-actions">
      <!-- Auth area: shows sign-in button OR avatar + name + sign-out -->
      <div class="auth-area" id="authArea"></div>
      <!-- Refresh button â€” its inner span spins while loading -->
      <button class="btn-icon" id="refreshBtn" title="Fetch new papers" aria-label="Refresh papers">
        <span id="refreshIcon">â†»</span>
      </button>
      <!-- Dark/light mode toggle -->
      <button class="btn-icon" id="themeBtn" title="Toggle dark/light mode" aria-label="Toggle theme">ğŸŒ™</button>
      <!-- Settings toggle -->
      <button class="btn-secondary" id="settingsToggle">âš™ Keywords</button>
    </div>
  </header>

  <!-- â”€â”€ Settings Panel (hidden by default) â”€â”€ -->
  <section class="settings-panel" id="settingsPanel" aria-label="Keyword settings">
    <h2>Search Keywords</h2>
    <p style="font-size:0.8rem; color:var(--text-muted); margin-bottom:14px;">
      Click a keyword to toggle it on/off. Active keywords are used to fetch and score papers.
      The Ã— button removes a keyword entirely.
    </p>

    <!-- Sign-in hint shown only when signed out -->
    <p class="signin-notice" id="signinNotice" style="display:none;">
      Sign in with Google to save your keywords across devices.
    </p>

    <!-- Keyword chips are rendered here by JS -->
    <div class="keyword-list" id="keywordList"></div>

    <!-- Add new keyword â€” disabled (dimmed) when signed out -->
    <div class="add-keyword-row" id="addKeywordRow">
      <input type="text" id="newKeywordInput" placeholder="Add a keywordâ€¦" maxlength="80" aria-label="New keyword" />
      <button class="btn-primary" id="addKeywordBtn">Add</button>
    </div>
  </section>

  <!-- â”€â”€ Active keyword tags shown in feed view â”€â”€ -->
  <div class="active-keywords-bar" id="activeKeywordsBar"></div>

  <!-- â”€â”€ Search bar â”€â”€ -->
  <div class="search-bar-container" id="searchBarContainer">
    <div class="search-input-wrapper">
      <span class="search-icon">ğŸ”</span>
      <input id="searchInput" class="search-input" type="search"
             placeholder="Search titles, abstracts, authorsâ€¦" maxlength="200" />
      <button id="searchClearBtn" class="search-clear-btn" style="display:none" aria-label="Clear search">âœ•</button>
    </div>
  </div>

  <!-- â”€â”€ Filter panel â”€â”€ -->
  <div id="filterPanel" class="filter-panel">
    <div class="filter-panel-header">
      <button id="filterToggleBtn" class="btn-secondary filter-toggle-btn">
        âš™ Filters <span id="filterActiveCount" class="filter-active-count" style="display:none"></span>
      </button>
      <div id="activeFilterTags" class="active-filter-tags"></div>
      <button id="clearAllFiltersBtn" class="btn-text" style="display:none">Clear all</button>
    </div>
    <div id="filterPanelBody" class="filter-panel-body" style="display:none">
      <div class="filter-group">
        <label class="filter-group-label" for="sortSelect">Sort</label>
        <select id="sortSelect" class="sort-select">
          <option value="newest">Newest first</option>
          <option value="oldest">Oldest first</option>
          <option value="relevance">Highest relevance</option>
          <option value="cited">Most cited</option>
        </select>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Relevance</span>
        <div id="scoreFilterGroup" class="filter-check-row"></div>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Date</span>
        <div id="dateFilterGroup" class="filter-radio-row"></div>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Status</span>
        <div id="statusFilterGroup" class="filter-radio-row"></div>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Keyword</span>
        <div id="keywordFilterGroup" class="filter-check-row"></div>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Citations</span>
        <div id="citationFilterGroup" class="filter-radio-row"></div>
      </div>
    </div>
  </div>

  <!-- â”€â”€ Feed header â”€â”€ -->
  <div id="feedHeader" class="feed-header">
    <div class="feed-header-left">
      <span id="feedCount" class="feed-count"></span>
      <span id="unreadBadge" class="unread-badge" style="display:none"></span>
    </div>
    <div class="feed-header-right">
      <span id="feedLastRefreshed" class="feed-last-refreshed"></span>
      <label class="toggle-label">
        <input type="checkbox" id="showHiddenToggle"> Show hidden
      </label>
    </div>
  </div>

  <!-- â”€â”€ Status line â”€â”€ -->
  <div class="status-bar" id="statusBar"></div>

  <!-- â”€â”€ Paper feed â”€â”€ -->
  <main class="paper-feed" id="paperFeed" aria-live="polite"></main>

  <footer>
    Data from <a href="https://www.semanticscholar.org/" target="_blank" rel="noopener" style="color:var(--accent)">Semantic Scholar</a>
    â€” open and free academic search API.
    <div id="healthBar" class="health-bar" style="display:none;"></div>
  </footer>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Research Hub â€” HRI Paper Feed
//  Single-file vanilla JS app. No frameworks, no build step.
//  Keywords sync to Firestore when signed in.
//  Paper actions (like/save/hide) stored in Firestore subcollection.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ Firebase setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const firebaseConfig = {
  apiKey:            'AIzaSyCGeXjURWaP02MdENQIR5wjQJdmapyAEPo',
  authDomain:        'research-hub-8da6a.firebaseapp.com',
  projectId:         'research-hub-8da6a',
  storageBucket:     'research-hub-8da6a.firebasestorage.app',
  messagingSenderId: '765872653008',
  appId:             '1:765872653008:web:ea08868e0e59e86acb14d5',
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db   = firebase.firestore();

// Holds the signed-in Firebase User object, or null if signed out.
let currentUser = null;


// â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const THEME_KEY       = 'researchhub_theme';
const LAST_FETCH_KEY  = 'researchhub_last_fetch';
const HEALTH_KEY      = 'researchhub_health';
const SEEN_PAPERS_KEY = 'researchhub_seen_papers';
const FETCH_TTL_MS    = 24 * 60 * 60 * 1000;
const PAGE_SIZE       = 20;

const API_BASE     = '/api/papers';
const PAPERS_LIMIT = 30;

const DEFAULT_KEYWORDS = [
  { text: 'social robots',          active: true },
  { text: 'human-robot interaction', active: true },
  { text: 'emotional contagion',    active: true },
  { text: 'priming public spaces',  active: true },
  { text: 'non-humanoid robots',    active: true },
];

// Fields we request from Semantic Scholar â€” includes citationCount and publicationDate
// so we can filter by citations and date ranges.
const API_FIELDS = 'title,abstract,authors,year,publicationDate,externalIds,url,citationCount';


// â”€â”€ App State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let keywords    = [];   // { text, active }[]
let allPapers   = [];   // raw results per fetch â€” never mutated after set
let papers      = [];   // derived filtered+sorted view of allPapers
let loading     = false;

let searchQuery = '';       // current live search string
let searchTimer = null;     // debounce handle

let filterState = {
  scores:    [1, 2, 3, 4, 5],  // active score checkboxes
  dateRange: 'all',             // 'all'|'7d'|'30d'|'90d'|'1y'
  status:    'all',             // 'all'|'unread'|'liked'|'saved'|'hidden'
  keywords:  [],                // [] = no keyword filter; strings = must match one
  citations: 0,                 // minimum citation count: 0|10|50|100|500
};

let sortOrder  = 'newest';  // 'newest'|'oldest'|'relevance'|'cited'
let pageIndex  = 0;

// Cache of { [paperId]: { liked, saved, hidden } } loaded from Firestore
let userActions = {};

// Set of paperIds seen in a previous session (for unread badge)
let seenPaperIds = new Set();

// Whether to include hidden papers in the feed
let showHidden = false;


// â”€â”€ Initialise â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function init() {
  renderAuthUI();
  loadKeywords();
  loadTheme();
  loadSeenPapers();
  bindEvents();
  renderFilterPanel();
  renderHealthBar();
  smartRefresh();
}


// â”€â”€ Auth UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderAuthUI() {
  const area = document.getElementById('authArea');
  if (!area) return;

  if (currentUser) {
    const photo    = currentUser.photoURL;
    const name     = currentUser.displayName || currentUser.email || 'User';
    const initials = name.charAt(0).toUpperCase();

    const avatarHtml = photo
      ? `<img class="user-avatar" src="${esc(photo)}" alt="${esc(name)}" referrerpolicy="no-referrer">`
      : `<span class="user-avatar-fallback">${esc(initials)}</span>`;

    area.innerHTML = `
      <div class="auth-user">
        ${avatarHtml}
        <span class="user-name" title="${esc(name)}">${esc(name)}</span>
        <button class="btn-signout" id="signOutBtn">Sign out</button>
      </div>`;

    document.getElementById('signOutBtn').addEventListener('click', signOut);

    const row    = document.getElementById('addKeywordRow');
    const notice = document.getElementById('signinNotice');
    if (row)    row.classList.remove('disabled');
    if (notice) notice.style.display = 'none';

  } else {
    area.innerHTML = `
      <button class="btn-signin" id="signInBtn">
        <svg width="16" height="16" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
          <path d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844a4.14 4.14 0 0 1-1.796 2.716v2.259h2.908c1.702-1.567 2.684-3.875 2.684-6.615z" fill="#4285F4"/>
          <path d="M9 18c2.43 0 4.467-.806 5.956-2.184l-2.908-2.259c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332A8.997 8.997 0 0 0 9 18z" fill="#34A853"/>
          <path d="M3.964 10.706A5.41 5.41 0 0 1 3.682 9c0-.593.102-1.17.282-1.706V4.962H.957A8.996 8.996 0 0 0 0 9c0 1.452.348 2.827.957 4.038l3.007-2.332z" fill="#FBBC05"/>
          <path d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0A8.997 8.997 0 0 0 .957 4.962L3.964 7.294C4.672 5.163 6.656 3.58 9 3.58z" fill="#EA4335"/>
        </svg>
        Sign in with Google
      </button>`;

    document.getElementById('signInBtn').addEventListener('click', signIn);

    const row    = document.getElementById('addKeywordRow');
    const notice = document.getElementById('signinNotice');
    if (row)    row.classList.add('disabled');
    if (notice) notice.style.display = 'block';
  }
}

function signIn() {
  const provider = new firebase.auth.GoogleAuthProvider();
  auth.signInWithPopup(provider).catch(err => {
    console.error('Sign-in error:', err);
  });
}

function signOut() {
  auth.signOut().catch(err => {
    console.error('Sign-out error:', err);
  });
}


// â”€â”€ Firestore: keywords â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function userDocRef() {
  return db.collection('users').doc(currentUser.uid);
}

async function loadKeywordsFromFirestore() {
  try {
    const snap = await userDocRef().get();
    if (snap.exists && snap.data().keywords) {
      keywords = snap.data().keywords;
    } else {
      keywords = DEFAULT_KEYWORDS.map(k => ({ ...k }));
      await saveKeywordsToFirestore();
    }
  } catch (e) {
    console.error('Firestore load error:', e);
    keywords = DEFAULT_KEYWORDS.map(k => ({ ...k }));
  }
}

async function saveKeywordsToFirestore() {
  try {
    await userDocRef().set({ keywords }, { merge: true });
  } catch (e) {
    console.error('Firestore save error:', e);
  }
}


// â”€â”€ Firestore: user actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Actions are stored in a subcollection: users/{uid}/actions/{paperId}
// Each doc: { liked: bool, saved: bool, hidden: bool, updatedAt: Timestamp }

function userActionsRef() {
  return db.collection('users').doc(currentUser.uid).collection('actions');
}

// Load all action docs for the current user into the userActions cache.
async function loadUserActions() {
  if (!currentUser) return;
  try {
    const snap = await userActionsRef().get();
    userActions = {};
    snap.forEach(doc => {
      userActions[doc.id] = doc.data();
    });
    renderPapers(); // re-render with loaded actions
  } catch (e) {
    console.error('Error loading user actions:', e);
  }
}

// Update one action field for a paper (merges with existing doc).
async function saveUserAction(paperId, key, value) {
  if (!currentUser) return;
  userActions[paperId] = userActions[paperId] || {};
  userActions[paperId][key] = value;
  try {
    await userActionsRef().doc(paperId).set(
      { [key]: value, updatedAt: firebase.firestore.FieldValue.serverTimestamp() },
      { merge: true }
    );
  } catch (e) {
    console.error('Error saving user action:', e);
  }
}


// â”€â”€ Auth state observer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

auth.onAuthStateChanged(async (user) => {
  currentUser = user;

  if (user) {
    await loadKeywordsFromFirestore();
    await loadUserActions();
  } else {
    keywords    = DEFAULT_KEYWORDS.map(k => ({ ...k }));
    userActions = {};
  }

  renderAuthUI();
  renderKeywordChips();
  renderActiveKeywordsBar();
  renderFilterPanel(); // keyword filter group depends on active keywords

  // Re-score papers already on screen with the updated keyword set
  if (allPapers.length > 0) {
    allPapers = allPapers.map(p => ({ ...p, score: scorepaper(p) }));
    papers    = applyFiltersAndSort(allPapers);
    pageIndex = 0;
    renderPapers();
  }
});


// â”€â”€ localStorage helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function loadKeywords() {
  keywords = DEFAULT_KEYWORDS.map(k => ({ ...k }));
}

function saveKeywords() {
  if (currentUser) {
    saveKeywordsToFirestore();
  }
}

function loadTheme() {
  const saved = localStorage.getItem(THEME_KEY) || 'light';
  applyTheme(saved);
}

function applyTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  document.getElementById('themeBtn').textContent = theme === 'dark' ? 'â˜€' : 'ğŸŒ™';
  localStorage.setItem(THEME_KEY, theme);
}


// â”€â”€ Unread tracking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// We store the IDs of papers seen in the last session in localStorage.
// Papers in the current fetch that aren't in seenPaperIds are "new".

function loadSeenPapers() {
  try {
    const raw = localStorage.getItem(SEEN_PAPERS_KEY);
    if (raw) seenPaperIds = new Set(JSON.parse(raw));
  } catch (e) {
    seenPaperIds = new Set();
  }
}

// Save the current allPapers IDs as "seen" (capped at 500).
function updateSeenPapers() {
  const currentIds = allPapers.map(p => p.paperId).filter(Boolean);
  // Merge with previous (keep old seen IDs, add new ones)
  const merged = [...seenPaperIds, ...currentIds];
  const capped  = merged.slice(-500);
  try {
    localStorage.setItem(SEEN_PAPERS_KEY, JSON.stringify(capped));
  } catch (e) { /* quota exceeded â€” skip silently */ }
  // Update the in-memory set to include just-seen papers
  // so they won't be "unread" next session
  // (we set it AFTER renderPapers so the badge shows this session's new papers)
}


// â”€â”€ Smart refresh â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function smartRefresh() {
  fetchPapers();
}

function friendlyTime(date) {
  const diff = Math.floor((Date.now() - date.getTime()) / 1000);
  if (diff < 60)    return 'just now';
  if (diff < 3600)  return `${Math.floor(diff / 60)} min ago`;
  if (diff < 86400) return `${Math.floor(diff / 3600)} hr ago`;
  return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
}


// â”€â”€ Health check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function runHealthCheck() {
  const firstKeyword = activeKeywords()[0];
  if (!firstKeyword) return;

  let ok = false, msg = '';
  try {
    const params = new URLSearchParams({ query: firstKeyword, fields: 'title,year', limit: 1 });
    const res  = await fetch(`${API_BASE}?${params}`);
    const data = await res.json();
    if (res.status === 429 || (data.message && !data.data)) {
      msg = 'API rate-limited';
    } else if (!res.ok) {
      msg = `API error (HTTP ${res.status})`;
    } else if (!data.data || data.data.length === 0) {
      msg = 'API returned no papers';
    } else if (!data.data[0].title) {
      msg = 'API returned malformed data';
    } else {
      ok = true; msg = 'All systems good';
    }
  } catch (e) {
    msg = e.message === 'Failed to fetch' ? 'Cannot reach API' : e.message;
  }
  const result = { ok, msg, ts: new Date().toISOString() };
  localStorage.setItem(HEALTH_KEY, JSON.stringify(result));
  renderHealthBar(result);
}

function renderHealthBar(result) {
  if (!result) {
    try {
      const saved = localStorage.getItem(HEALTH_KEY);
      if (!saved) return;
      result = JSON.parse(saved);
    } catch (e) { return; }
  }
  const el = document.getElementById('healthBar');
  if (!el) return;
  const time = friendlyTime(new Date(result.ts));
  el.style.display = 'inline-block';
  el.className = 'health-bar ' + (result.ok ? 'ok' : 'error');
  el.textContent = result.ok
    ? `âœ… ${result.msg} â€” last checked ${time}`
    : `âŒ ${result.msg} â€” last checked ${time}`;
}


// â”€â”€ Event binding â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function bindEvents() {
  document.getElementById('settingsToggle').addEventListener('click', () => {
    document.getElementById('settingsPanel').classList.toggle('open');
    renderKeywordChips();
  });
  document.getElementById('refreshBtn').addEventListener('click', fetchPapers);
  document.getElementById('themeBtn').addEventListener('click', () => {
    const current = document.documentElement.getAttribute('data-theme');
    applyTheme(current === 'dark' ? 'light' : 'dark');
  });
  document.getElementById('addKeywordBtn').addEventListener('click', addKeyword);
  document.getElementById('newKeywordInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') addKeyword();
  });

  // Search
  document.getElementById('searchInput').addEventListener('input', handleSearchInput);
  document.getElementById('searchClearBtn').addEventListener('click', clearSearch);

  // Filter panel toggle
  document.getElementById('filterToggleBtn').addEventListener('click', () => {
    const body = document.getElementById('filterPanelBody');
    body.style.display = body.style.display === 'none' ? 'flex' : 'none';
  });

  // Clear all filters
  document.getElementById('clearAllFiltersBtn').addEventListener('click', clearAllFilters);

  // Sort select
  document.getElementById('sortSelect').addEventListener('change', (e) => {
    sortOrder = e.target.value;
    applyAndRender();
  });

  // Show hidden toggle
  document.getElementById('showHiddenToggle').addEventListener('change', (e) => {
    showHidden = e.target.checked;
    applyAndRender();
  });
}


// â”€â”€ Keyword management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function addKeyword() {
  const input = document.getElementById('newKeywordInput');
  const text  = input.value.trim().toLowerCase();
  if (!text) return;
  if (keywords.some(k => k.text === text)) { input.value = ''; return; }
  keywords.push({ text, active: true });
  saveKeywords();
  input.value = '';
  renderKeywordChips();
  renderActiveKeywordsBar();
  renderKeywordFilterGroup(); // update filter panel
  fetchPapers();
}

function removeKeyword(index) {
  keywords.splice(index, 1);
  saveKeywords();
  renderKeywordChips();
  renderActiveKeywordsBar();
  renderKeywordFilterGroup();
  fetchPapers();
}

function toggleKeyword(index) {
  keywords[index].active = !keywords[index].active;
  saveKeywords();
  renderKeywordChips();
  renderActiveKeywordsBar();
  renderKeywordFilterGroup();
  fetchPapers();
}

function activeKeywords() {
  return keywords.filter(k => k.active).map(k => k.text);
}


// â”€â”€ Relevance scoring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function scorepaper(paper) {
  const active = activeKeywords();
  if (active.length === 0) return 1;

  const title    = (paper.title    || '').toLowerCase();
  const abstract = (paper.abstract || '').toLowerCase();

  let matches    = 0;
  let matchedKws = 0; // how many keywords appeared at all in this paper

  for (const kw of active) {
    const kwLower    = kw.toLowerCase();
    const inTitle    = title.includes(kwLower);
    const inAbstract = abstract.includes(kwLower);
    if (inTitle || inAbstract) {
      matchedKws++;
      if (inTitle)    matches += 2; // title match worth more
      if (inAbstract) matches += 1;
    }
  }

  // No keyword found in this paper at all â†’ not relevant
  if (matchedKws === 0) return 1;

  // Normalise only against keywords that actually appeared in this paper.
  // This avoids penalising a "social robots" paper for not mentioning
  // "emotional contagion" â€” keywords it was never fetched for.
  // Ratio is always in [0.33, 1.0] when matchedKws > 0.
  const ratio = matches / (matchedKws * 3);

  if (ratio < 0.5)  return 3; // abstract-only match  (1/3 â‰ˆ 0.33)
  if (ratio < 0.75) return 4; // title-only match      (2/3 â‰ˆ 0.67)
  return 5;                   // title + abstract match (3/3 = 1.00)
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FILTER & SORT PIPELINE
//  All pure functions â€” no DOM side effects.
//  Input: allPapers[]  â†’  Output: filtered+sorted papers[]
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Master entry point: recompute papers[] from allPapers[], reset page, re-render.
function applyAndRender() {
  papers    = applyFiltersAndSort(allPapers);
  pageIndex = 0;
  renderPapers();
}

// Chains all 6 filter steps then sort. Returns a new array (never mutates input).
function applyFiltersAndSort(arr) {
  let result = arr.slice(); // shallow copy â€” safe because we never mutate paper objects
  result = applySearchFilter(result, searchQuery);
  result = applyScoreFilter(result, filterState.scores);
  result = applyDateFilter(result, filterState.dateRange);
  result = applyStatusFilter(result, filterState.status, userActions);
  result = applyKeywordFilter(result, filterState.keywords);
  result = applyCitationFilter(result, filterState.citations);
  // Unless "show hidden" is on, remove hidden papers from the default view
  if (!showHidden) {
    result = result.filter(p => !userActions[p.paperId]?.hidden);
  }
  result = applySortOrder(result, sortOrder);
  return result;
}

// Full-text search across title, abstract, authors (case-insensitive substring).
function applySearchFilter(arr, q) {
  if (!q || !q.trim()) return arr;
  const term = q.trim().toLowerCase();
  return arr.filter(p => {
    const title    = (p.title    || '').toLowerCase();
    const abstract = (p.abstract || '').toLowerCase();
    const authors  = (p.authors  || []).map(a => (a.name || '').toLowerCase()).join(' ');
    return title.includes(term) || abstract.includes(term) || authors.includes(term);
  });
}

// Keep only papers whose score is in the allowed scores array.
function applyScoreFilter(arr, scores) {
  if (!scores || scores.length === 5) return arr; // all selected = no filter
  return arr.filter(p => scores.includes(p.score));
}

// Filter by publication date using paper.publicationDate (YYYY-MM-DD).
// Falls back to paper.year if publicationDate is absent.
function applyDateFilter(arr, range) {
  if (range === 'all') return arr;

  const now = Date.now();
  const cutoffMs = {
    '7d':  7  * 24 * 60 * 60 * 1000,
    '30d': 30 * 24 * 60 * 60 * 1000,
    '90d': 90 * 24 * 60 * 60 * 1000,
    '1y':  365 * 24 * 60 * 60 * 1000,
  }[range];

  if (!cutoffMs) return arr;
  const cutoff = now - cutoffMs;

  return arr.filter(p => {
    // Prefer full date, fall back to year-only
    const dateStr = p.publicationDate || (p.year ? `${p.year}-01-01` : null);
    if (!dateStr) return false;
    const ts = new Date(dateStr).getTime();
    return !isNaN(ts) && ts >= cutoff;
  });
}

// Filter by status: all / unread / liked / saved / hidden
function applyStatusFilter(arr, status, actions) {
  if (status === 'all') return arr;
  return arr.filter(p => {
    const a = actions[p.paperId] || {};
    if (status === 'liked')  return !!a.liked;
    if (status === 'saved')  return !!a.saved;
    if (status === 'hidden') return !!a.hidden;
    if (status === 'unread') return !seenPaperIds.has(p.paperId);
    return true;
  });
}

// Keep papers that match at least one of the selected keyword filters.
// Empty array = no keyword filter (show all).
function applyKeywordFilter(arr, kws) {
  if (!kws || kws.length === 0) return arr;
  const kwsLower = kws.map(k => k.toLowerCase());
  return arr.filter(p => {
    const text = ((p.title || '') + ' ' + (p.abstract || '')).toLowerCase();
    return kwsLower.some(kw => text.includes(kw));
  });
}

// Keep papers where citationCount >= min (undefined/null treated as 0).
function applyCitationFilter(arr, min) {
  if (!min || min === 0) return arr;
  return arr.filter(p => (p.citationCount || 0) >= min);
}

// Sort a copy of the array by the given order. Does NOT mutate input.
function applySortOrder(arr, order) {
  const a = arr.slice();
  if (order === 'newest') {
    return a.sort((x, y) => {
      const dx = x.publicationDate || (x.year ? `${x.year}-12-31` : '0000-01-01');
      const dy = y.publicationDate || (y.year ? `${y.year}-12-31` : '0000-01-01');
      return dy.localeCompare(dx);
    });
  }
  if (order === 'oldest') {
    return a.sort((x, y) => {
      const dx = x.publicationDate || (x.year ? `${x.year}-01-01` : '9999-12-31');
      const dy = y.publicationDate || (y.year ? `${y.year}-01-01` : '9999-12-31');
      return dx.localeCompare(dy);
    });
  }
  if (order === 'relevance') {
    return a.sort((x, y) => y.score - x.score);
  }
  if (order === 'cited') {
    return a.sort((x, y) => (y.citationCount || 0) - (x.citationCount || 0));
  }
  return a;
}

// Returns the active keyword phrases found in a paper's title+abstract.
function getMatchedKeywords(paper) {
  const active = activeKeywords();
  if (!active.length) return [];
  const text = ((paper.title || '') + ' ' + (paper.abstract || '')).toLowerCase();
  return active.filter(kw => text.includes(kw.toLowerCase()));
}

// Wrap each occurrence of query in the pre-escaped text with <mark>.
// IMPORTANT: text must already be HTML-escaped before calling this function.
// We never inject user input as HTML â€” only hard-coded <mark> tags are inserted.
function highlightSearchTerms(text, q) {
  if (!q || !q.trim()) return text;
  // Escape regex special characters so they're treated as literals
  const escaped = q.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex   = new RegExp(escaped, 'gi');
  return text.replace(regex, match => `<mark class="search-highlight">${match}</mark>`);
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  API FETCH
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function fetchOneKeyword(keyword) {
  const params = new URLSearchParams({
    query:  keyword,
    fields: API_FIELDS,
    limit:  10,
  });
  const res  = await fetch(`${API_BASE}?${params}`);
  const data = await res.json();
  if (res.status === 429 || (data.message && !data.data)) {
    throw new Error('Rate limited by Semantic Scholar. Wait 30 seconds and click Refresh.');
  }
  if (!res.ok) {
    throw new Error(`Semantic Scholar API error (${res.status}). Try again shortly.`);
  }
  return data.data || [];
}

function wait(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function fetchPapers() {
  if (loading) return;

  const active = activeKeywords();
  if (active.length === 0) {
    setStatus('No active keywords. Enable at least one keyword in settings.', true);
    return;
  }

  loading = true;
  setStatus(`Fetching papers for ${active.length} keyword${active.length > 1 ? 's' : ''}â€¦`);
  showSkeletons();
  setRefreshSpinning(true);

  try {
    const seen    = new Set();
    const results = [];

    for (let i = 0; i < active.length; i++) {
      if (i > 0) await wait(500);
      setStatus(`Fetching papersâ€¦ (${i + 1}/${active.length})`);
      try {
        const batch = await fetchOneKeyword(active[i]);
        for (const paper of batch) {
          if (paper.title && paper.paperId && !seen.has(paper.paperId)) {
            seen.add(paper.paperId);
            results.push(paper);
          }
        }
      } catch (kwErr) {
        console.warn(`Skipping keyword "${active[i]}": ${kwErr.message}`);
      }
    }

    // Score all results and store as immutable allPapers
    allPapers = results.map(p => ({ ...p, score: scorepaper(p) }));

    // Apply filters and sort to derive the view
    papers    = applyFiltersAndSort(allPapers);
    pageIndex = 0;

    if (allPapers.length === 0) {
      setStatus('No papers found. The API may be rate-limited â€” wait 30 seconds and click Refresh.', true);
    } else {
      const now = new Date();
      localStorage.setItem(LAST_FETCH_KEY, now.toISOString());
      setStatus(''); // clear status; feed header shows count
      runHealthCheck();
    }

    // Track unread BEFORE updating seen (so new papers show as unread this session)
    renderPapers();

    // After rendering, mark current papers as seen for next session
    updateSeenPapers();
    // Update the in-memory seenPaperIds so they don't show as unread in this session
    allPapers.forEach(p => { if (p.paperId) seenPaperIds.add(p.paperId); });

    // Load user actions if signed in
    if (currentUser) {
      await loadUserActions(); // will call renderPapers() again with actions
    }

  } catch (err) {
    console.error('Fetch error:', err);
    const msg = err.message === 'Failed to fetch'
      ? 'Could not reach local server. Make sure server.py is running.'
      : err.message;
    setStatus(msg, true);
    document.getElementById('paperFeed').innerHTML = '';
  } finally {
    loading = false;
    setRefreshSpinning(false);
  }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SEARCH BAR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function handleSearchInput(e) {
  const val = e.target.value;
  const clearBtn = document.getElementById('searchClearBtn');
  clearBtn.style.display = val ? 'block' : 'none';

  // Debounce: wait 300ms after typing stops before filtering
  clearTimeout(searchTimer);
  searchTimer = setTimeout(() => {
    searchQuery = val;
    applyAndRender();
  }, 300);
}

function clearSearch() {
  searchQuery = '';
  const input = document.getElementById('searchInput');
  if (input) input.value = '';
  document.getElementById('searchClearBtn').style.display = 'none';
  applyAndRender();
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FILTER PANEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Renders ALL filter groups from scratch.
// Called on init and whenever keyword list changes.
function renderFilterPanel() {
  renderScoreFilterGroup();
  renderDateFilterGroup();
  renderStatusFilterGroup();
  renderKeywordFilterGroup();
  renderCitationFilterGroup();
  renderActiveFilterTags();
}

function renderScoreFilterGroup() {
  const el = document.getElementById('scoreFilterGroup');
  if (!el) return;
  el.innerHTML = [1, 2, 3, 4, 5].map(s => `
    <label class="filter-option-label">
      <input type="checkbox" value="${s}"
             ${filterState.scores.includes(s) ? 'checked' : ''}
             data-filter="score">
      â˜…${s}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="score"]').forEach(inp => {
    inp.addEventListener('change', () => {
      const checked = [...el.querySelectorAll('input[data-filter="score"]')]
        .filter(i => i.checked).map(i => Number(i.value));
      filterState.scores = checked.length ? checked : [1, 2, 3, 4, 5];
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderDateFilterGroup() {
  const el = document.getElementById('dateFilterGroup');
  if (!el) return;
  const options = [
    { val: 'all',  label: 'All time' },
    { val: '7d',   label: 'Last 7 days' },
    { val: '30d',  label: 'Last 30 days' },
    { val: '90d',  label: 'Last 3 months' },
    { val: '1y',   label: 'Last year' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="dateFilter" value="${o.val}"
             ${filterState.dateRange === o.val ? 'checked' : ''}
             data-filter="date">
      ${o.label}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="date"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.dateRange = inp.value;
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderStatusFilterGroup() {
  const el = document.getElementById('statusFilterGroup');
  if (!el) return;
  const options = [
    { val: 'all',    label: 'All' },
    { val: 'unread', label: 'Unread' },
    { val: 'liked',  label: 'â¤ Liked' },
    { val: 'saved',  label: 'ğŸ”– Saved' },
    { val: 'hidden', label: 'ğŸ™ˆ Hidden' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="statusFilter" value="${o.val}"
             ${filterState.status === o.val ? 'checked' : ''}
             data-filter="status">
      ${o.label}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="status"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.status = inp.value;
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

// Re-renders only the keyword filter group (called when keywords change).
function renderKeywordFilterGroup() {
  const el = document.getElementById('keywordFilterGroup');
  if (!el) return;
  const active = activeKeywords();
  if (active.length === 0) {
    el.innerHTML = '<span style="font-size:0.75rem; color:var(--text-muted)">No active keywords</span>';
    return;
  }
  el.innerHTML = active.map(kw => `
    <label class="filter-option-label">
      <input type="checkbox" value="${esc(kw)}"
             ${filterState.keywords.includes(kw) ? 'checked' : ''}
             data-filter="keyword">
      ${esc(kw)}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="keyword"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.keywords = [...el.querySelectorAll('input[data-filter="keyword"]')]
        .filter(i => i.checked).map(i => i.value);
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderCitationFilterGroup() {
  const el = document.getElementById('citationFilterGroup');
  if (!el) return;
  const options = [
    { val: 0,   label: 'Any' },
    { val: 10,  label: 'â‰¥10' },
    { val: 50,  label: 'â‰¥50' },
    { val: 100, label: 'â‰¥100' },
    { val: 500, label: 'â‰¥500' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="citationFilter" value="${o.val}"
             ${filterState.citations === o.val ? 'checked' : ''}
             data-filter="citation">
      ${o.label}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="citation"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.citations = Number(inp.value);
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

// Build the active filter tag data: each non-default filter gets a pill.
function buildActiveFilterTags() {
  const tags = [];

  if (searchQuery) {
    tags.push({ label: `Search: "${searchQuery}"`, clearFn: clearSearch });
  }
  if (filterState.scores.length < 5) {
    const label = 'Score: ' + filterState.scores.map(s => 'â˜…' + s).join(' ');
    tags.push({ label, clearFn: () => {
      filterState.scores = [1, 2, 3, 4, 5];
      renderFilterPanel(); applyAndRender();
    }});
  }
  if (filterState.dateRange !== 'all') {
    const labels = { '7d': 'Last 7 days', '30d': 'Last 30 days', '90d': 'Last 3 months', '1y': 'Last year' };
    tags.push({ label: labels[filterState.dateRange] || filterState.dateRange, clearFn: () => {
      filterState.dateRange = 'all'; renderFilterPanel(); applyAndRender();
    }});
  }
  if (filterState.status !== 'all') {
    tags.push({ label: `Status: ${filterState.status}`, clearFn: () => {
      filterState.status = 'all'; renderFilterPanel(); applyAndRender();
    }});
  }
  filterState.keywords.forEach(kw => {
    tags.push({ label: `Keyword: ${kw}`, clearFn: () => {
      filterState.keywords = filterState.keywords.filter(k => k !== kw);
      renderFilterPanel(); applyAndRender();
    }});
  });
  if (filterState.citations > 0) {
    tags.push({ label: `Citations â‰¥${filterState.citations}`, clearFn: () => {
      filterState.citations = 0; renderFilterPanel(); applyAndRender();
    }});
  }
  return tags;
}

// Render the pill tags row and update badge count.
function renderActiveFilterTags() {
  const container = document.getElementById('activeFilterTags');
  const badge     = document.getElementById('filterActiveCount');
  const clearBtn  = document.getElementById('clearAllFiltersBtn');
  if (!container) return;

  const tags = buildActiveFilterTags();

  if (tags.length === 0) {
    container.innerHTML = '';
    badge.style.display    = 'none';
    clearBtn.style.display = 'none';
    return;
  }

  badge.textContent  = tags.length;
  badge.style.display    = 'inline-block';
  clearBtn.style.display = 'inline-block';

  container.innerHTML = tags.map((t, i) => `
    <span class="filter-tag">
      ${esc(t.label)}
      <button class="filter-tag-remove" data-tag-idx="${i}" aria-label="Remove filter">Ã—</button>
    </span>
  `).join('');

  container.querySelectorAll('.filter-tag-remove').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      tags[parseInt(btn.dataset.tagIdx)].clearFn();
    });
  });
}

// Reset all filters and search to defaults.
function clearAllFilters() {
  filterState = { scores: [1,2,3,4,5], dateRange: 'all', status: 'all', keywords: [], citations: 0 };
  searchQuery = '';
  sortOrder   = 'newest';
  pageIndex   = 0;
  const input = document.getElementById('searchInput');
  if (input) input.value = '';
  document.getElementById('searchClearBtn').style.display = 'none';
  document.getElementById('sortSelect').value = 'newest';
  renderFilterPanel();
  applyAndRender();
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  USER ACTIONS: Like / Save / Hide / Copy citation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Route an action button click to the correct handler.
function handlePaperAction(paperId, action) {
  if (!currentUser) return; // buttons are disabled when signed out

  if (action === 'like') {
    const current = userActions[paperId]?.liked || false;
    saveUserAction(paperId, 'liked', !current);
    updateCardActionDisplay(paperId);
    // If we're filtering by liked, re-render
    if (filterState.status === 'liked') applyAndRender();
  } else if (action === 'save') {
    const current = userActions[paperId]?.saved || false;
    saveUserAction(paperId, 'saved', !current);
    updateCardActionDisplay(paperId);
    if (filterState.status === 'saved') applyAndRender();
  } else if (action === 'hide') {
    const current = userActions[paperId]?.hidden || false;
    const newVal  = !current;
    saveUserAction(paperId, 'hidden', newVal);
    if (newVal && !showHidden) {
      // Fade out then remove
      const card = document.querySelector(`[data-paperid="${paperId}"]`);
      if (card) {
        card.classList.add('paper-card--fading');
        setTimeout(() => applyAndRender(), 380);
      }
    } else {
      updateCardActionDisplay(paperId);
      if (filterState.status === 'hidden') applyAndRender();
    }
  } else if (action === 'copy') {
    copyCitation(paperId);
  }
}

// Update just the action buttons of one card without re-rendering the whole feed.
function updateCardActionDisplay(paperId) {
  const card = document.querySelector(`[data-paperid="${paperId}"]`);
  if (!card) return;
  const a = userActions[paperId] || {};
  const isSignedIn = !!currentUser;

  const likeBtn = card.querySelector('.like-btn');
  const saveBtn = card.querySelector('.save-btn');
  const hideBtn = card.querySelector('.hide-btn');

  if (likeBtn) {
    likeBtn.classList.toggle('active', !!a.liked);
    likeBtn.textContent = a.liked ? 'â¤ Liked' : 'â™¡ Like';
  }
  if (saveBtn) {
    saveBtn.classList.toggle('active', !!a.saved);
    saveBtn.textContent = a.saved ? 'ğŸ”– Saved' : 'ğŸ”– Save';
  }
  if (hideBtn) {
    hideBtn.classList.toggle('active', !!a.hidden);
    hideBtn.textContent = a.hidden ? 'ğŸ‘ Unhide' : 'ğŸ™ˆ Hide';
  }
}

// Format an APA-ish citation and copy to clipboard.
function copyCitation(paperId) {
  const paper = allPapers.find(p => p.paperId === paperId);
  if (!paper) return;

  const authors = (paper.authors || []).map(a => a.name).join(', ') || 'Unknown authors';
  const year    = paper.year || 'n.d.';
  const title   = paper.title || 'Untitled';
  const doi     = paper.externalIds?.DOI;
  const url     = doi ? `https://doi.org/${doi}` : paper.url || '';
  const citation = `${authors} (${year}). ${title}.${url ? ' ' + url : ''}`;

  navigator.clipboard.writeText(citation).then(() => {
    const btn = document.querySelector(`[data-paperid="${paperId}"] .copy-btn`);
    if (btn) {
      const orig = btn.textContent;
      btn.textContent = 'âœ“ Copied!';
      setTimeout(() => { btn.textContent = orig; }, 2000);
    }
  }).catch(err => {
    console.error('Clipboard error:', err);
  });
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Update the feed header: paper count, unread badge, last refresh time.
function renderFeedHeader() {
  const countEl    = document.getElementById('feedCount');
  const badgeEl    = document.getElementById('unreadBadge');
  const refreshEl  = document.getElementById('feedLastRefreshed');

  if (countEl) {
    countEl.textContent = papers.length === 0
      ? 'No papers'
      : `${papers.length} paper${papers.length !== 1 ? 's' : ''}`;
  }

  // Unread = papers in current allPapers that weren't in last session's seenPaperIds
  const unreadCount = allPapers.filter(p => p.paperId && !seenPaperIds.has(p.paperId)).length;
  // (seenPaperIds is updated AFTER render, so new papers show as unread in this session)
  if (badgeEl) {
    if (unreadCount > 0) {
      badgeEl.textContent  = `${unreadCount} new`;
      badgeEl.style.display = 'inline-block';
    } else {
      badgeEl.style.display = 'none';
    }
  }

  if (refreshEl) {
    try {
      const ts = localStorage.getItem(LAST_FETCH_KEY);
      refreshEl.textContent = ts ? `Updated ${friendlyTime(new Date(ts))}` : '';
    } catch (e) { refreshEl.textContent = ''; }
  }
}

// Build the HTML string for one paper card.
function buildPaperCardHtml(paper) {
  const paperId  = paper.paperId || '';
  const paperUrl = paper.url ||
    (paper.externalIds?.DOI
      ? `https://doi.org/${paper.externalIds.DOI}`
      : `https://www.semanticscholar.org/paper/${paperId}`);

  const authors = (paper.authors || []).map(a => a.name);
  const authorStr = authors.length > 4
    ? authors.slice(0, 4).join(', ') + ' et al.'
    : authors.join(', ') || 'Unknown authors';

  const year = paper.publicationDate
    ? paper.publicationDate.slice(0, 7)   // "YYYY-MM"
    : (paper.year || 'Year unknown');

  const scoreClass = paper.score >= 4 ? 'high' : paper.score >= 2 ? 'mid' : '';

  // Citation count
  const citeStr = (typeof paper.citationCount === 'number')
    ? `<span class="citation-count" title="Citations">ğŸ“„ ${paper.citationCount}</span>`
    : '';

  // Abstract with optional search highlight (input is pre-escaped â†’ safe)
  const rawAbstract = paper.abstract || '';
  const abstractHtml = rawAbstract
    ? highlightSearchTerms(esc(rawAbstract), searchQuery)
    : '<em style="color:var(--text-muted)">No abstract available.</em>';

  // Title with optional search highlight
  const titleHtml = highlightSearchTerms(esc(paper.title || 'Untitled'), searchQuery);

  // Matched keyword tags
  const matched   = getMatchedKeywords(paper);
  const kwTagsHtml = matched.length
    ? `<div class="paper-keyword-tags">${matched.map(k => `<span class="matched-kw-tag">${esc(k)}</span>`).join('')}</div>`
    : '';

  // Whether this paper has been seen before
  const isUnread = paperId && !seenPaperIds.has(paperId);

  // Action buttons â€” disabled when signed out
  const a          = userActions[paperId] || {};
  const disabledCls = currentUser ? '' : ' disabled-action';
  const likedLbl   = a.liked  ? 'â¤ Liked'    : 'â™¡ Like';
  const savedLbl   = a.saved  ? 'ğŸ”– Saved'   : 'ğŸ”– Save';
  const hiddenLbl  = a.hidden ? 'ğŸ‘ Unhide'  : 'ğŸ™ˆ Hide';

  return `
    <article class="paper-card${isUnread ? ' paper-card--unread' : ''}" data-paperid="${esc(paperId)}">
      <div class="paper-card-top">
        <h2 class="paper-title">
          <a href="${esc(paperUrl)}" target="_blank" rel="noopener">
            ${titleHtml}
          </a>
        </h2>
        <span class="score-badge ${scoreClass}" title="Relevance score based on keyword matches">
          â˜… ${paper.score}/5
        </span>
      </div>
      <div class="paper-meta">
        ${esc(authorStr)} &nbsp;Â·&nbsp; ${esc(String(year))} ${citeStr}
      </div>
      <p class="paper-abstract" id="abstract-${esc(paperId)}">${abstractHtml}</p>
      ${rawAbstract.length > 300
        ? `<button class="expand-btn" data-paperid="${esc(paperId)}">Show more</button>`
        : ''}
      ${kwTagsHtml}
      <div class="paper-actions">
        <button class="action-btn like-btn${a.liked ? ' active' : ''}${disabledCls}"
                data-paperid="${esc(paperId)}" data-action="like">${likedLbl}</button>
        <button class="action-btn save-btn${a.saved ? ' active' : ''}${disabledCls}"
                data-paperid="${esc(paperId)}" data-action="save">${savedLbl}</button>
        <button class="action-btn hide-btn${a.hidden ? ' active' : ''}${disabledCls}"
                data-paperid="${esc(paperId)}" data-action="hide">${hiddenLbl}</button>
        <button class="action-btn copy-btn"
                data-paperid="${esc(paperId)}" data-action="copy">ğŸ“‹ Cite</button>
      </div>
    </article>
  `;
}

// Render the current page slice of papers[] into #paperFeed.
function renderPapers() {
  renderFeedHeader();
  const feed = document.getElementById('paperFeed');

  if (papers.length === 0) {
    feed.innerHTML = renderEmptyState();
    return;
  }

  // Show a paginated slice: first (pageIndex+1)*PAGE_SIZE papers
  const slice    = papers.slice(0, (pageIndex + 1) * PAGE_SIZE);
  const hasMore  = papers.length > slice.length;

  feed.innerHTML = slice.map(p => buildPaperCardHtml(p)).join('') +
    (hasMore ? `
      <div class="feed-load-more">
        <button id="loadMoreBtn">Load more (${papers.length - slice.length} remaining)</button>
      </div>
    ` : '');

  // Bind delegated events
  bindCardActions();

  // Wire up expand buttons
  feed.querySelectorAll('.expand-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const pid   = btn.dataset.paperid;
      const absEl = document.getElementById(`abstract-${pid}`);
      if (!absEl) return;
      const expanded = absEl.classList.toggle('expanded');
      btn.textContent = expanded ? 'Show less' : 'Show more';
    });
  });

  // Load more button
  const loadMoreBtn = document.getElementById('loadMoreBtn');
  if (loadMoreBtn) {
    loadMoreBtn.addEventListener('click', loadMorePapers);
  }
}

// Returns an appropriate empty-state HTML string.
function renderEmptyState() {
  if (allPapers.length === 0) {
    return `<div class="empty-state">
      <div class="icon">ğŸ“„</div>
      No papers found for these keywords. Try adding broader terms or click Refresh.
    </div>`;
  }
  // Papers exist but filters removed all of them
  return `<div class="empty-state">
    <div class="icon">ğŸ”</div>
    No papers match the current filters.
    <br><button class="btn-text" onclick="clearAllFilters()" style="margin-top:8px">Clear filters</button>
  </div>`;
}

// Single delegated listener for all action buttons in the feed.
function bindCardActions() {
  const feed = document.getElementById('paperFeed');
  // Remove any existing listener by replacing the node (simplest approach for a full re-render)
  // We use a named function stored on the element to avoid double-binding.
  if (feed._actionListener) {
    feed.removeEventListener('click', feed._actionListener);
  }
  feed._actionListener = (e) => {
    const btn = e.target.closest('[data-action]');
    if (!btn) return;
    const { paperid, action } = btn.dataset;
    if (paperid && action) handlePaperAction(paperid, action);
  };
  feed.addEventListener('click', feed._actionListener);
}

// Increment pageIndex and append the next slice (no scroll reset).
function loadMorePapers() {
  pageIndex++;
  renderPapers();
}


// â”€â”€ Rendering helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function esc(str) {
  return (str || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

function setStatus(msg, isError = false) {
  const el = document.getElementById('statusBar');
  el.textContent = msg;
  el.className   = 'status-bar' + (isError ? ' error' : '');
}

function setRefreshSpinning(on) {
  document.getElementById('refreshIcon').className = on ? 'btn-spinning' : '';
}

function showSkeletons() {
  const feed = document.getElementById('paperFeed');
  feed.innerHTML = Array.from({ length: 4 }, () => `
    <div class="skeleton-card">
      <div class="skeleton-line" style="width:70%; height:18px;"></div>
      <div class="skeleton-line" style="width:40%; height:12px;"></div>
      <div class="skeleton-line" style="width:100%; height:12px;"></div>
      <div class="skeleton-line" style="width:95%; height:12px;"></div>
      <div class="skeleton-line" style="width:80%; height:12px;"></div>
    </div>
  `).join('');
}


// â”€â”€ Render: keyword chips in settings panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderKeywordChips() {
  const list = document.getElementById('keywordList');

  if (keywords.length === 0) {
    list.innerHTML = '<span style="color:var(--text-muted);font-size:0.8rem;">No keywords yet.</span>';
    return;
  }

  list.innerHTML = keywords.map((kw, i) => `
    <span class="keyword-chip ${kw.active ? '' : 'off'}"
          data-index="${i}"
          role="button"
          tabindex="0"
          title="${kw.active ? 'Click to disable' : 'Click to enable'}"
          aria-pressed="${kw.active}">
      ${esc(kw.text)}
      <button class="remove-btn"
              data-remove="${i}"
              title="Remove keyword"
              aria-label="Remove ${esc(kw.text)}">Ã—</button>
    </span>
  `).join('');

  list.querySelectorAll('.keyword-chip').forEach(chip => {
    chip.addEventListener('click', (e) => {
      if (e.target.classList.contains('remove-btn')) return;
      toggleKeyword(parseInt(chip.dataset.index));
    });
    chip.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        toggleKeyword(parseInt(chip.dataset.index));
      }
    });
  });

  list.querySelectorAll('.remove-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      removeKeyword(parseInt(btn.dataset.remove));
    });
  });
}


// â”€â”€ Render: active keyword tags below header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderActiveKeywordsBar() {
  const bar    = document.getElementById('activeKeywordsBar');
  const active = activeKeywords();

  if (active.length === 0) {
    bar.innerHTML = '<span class="bar-label">No active keywords</span>';
    return;
  }

  bar.innerHTML =
    '<span class="bar-label">Searching:</span>' +
    active.map(k => `<span class="active-kw-tag">${esc(k)}</span>`).join('');
}


// â”€â”€ Start the app â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
init();
renderKeywordChips();
renderActiveKeywordsBar();

</script>
</body>
</html>
