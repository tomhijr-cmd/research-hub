<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Research Hub â€” HRI Paper Feed</title>

  <!-- â”€â”€ Firebase SDK (compat mode = no bundler needed, works in plain HTML) â”€â”€ -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

  <style>
    /* â”€â”€ CSS Custom Properties (theme variables) â”€â”€ */
    :root {
      --bg:           #f5f4f0;
      --surface:      #ffffff;
      --border:       #ddd9d0;
      --text:         #1a1a1a;
      --text-muted:   #666;
      --accent:       #2c5f8a;
      --accent-light: #e8f0f8;
      --tag-bg:       #eef2f7;
      --tag-off:      #f0f0f0;
      --tag-off-text: #999;
      --score-high:   #2d7a3a;
      --score-mid:    #8a6d2c;
      --score-low:    #999;
      --shadow:       0 1px 3px rgba(0,0,0,0.08);
      --radius:       6px;
      --font-serif:   Georgia, 'Times New Roman', serif;
      --font-sans:    system-ui, -apple-system, sans-serif;
    }

    /* Dark mode variables */
    [data-theme="dark"] {
      --bg:           #1a1a1e;
      --surface:      #25252b;
      --border:       #38383f;
      --text:         #e8e8e8;
      --text-muted:   #999;
      --accent:       #6aabda;
      --accent-light: #1e2d3d;
      --tag-bg:       #2a3540;
      --tag-off:      #2a2a2f;
      --tag-off-text: #666;
      --score-high:   #5cb86a;
      --score-mid:    #c9a84c;
      --score-low:    #666;
      --shadow:       0 1px 4px rgba(0,0,0,0.3);
    }

    /* â”€â”€ Reset & Base â”€â”€ */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: var(--font-sans);
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
      min-height: 100vh;
      transition: background 0.2s, color 0.2s;
    }

    /* â”€â”€ Layout â”€â”€ */
    .app-wrapper {
      max-width: 860px;
      margin: 0 auto;
      padding: 0 16px 60px;
    }

    /* â”€â”€ Header â”€â”€ */
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 24px 0 20px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 24px;
      gap: 12px;
      flex-wrap: wrap;
    }

    .header-title h1 {
      font-family: var(--font-serif);
      font-size: 1.5rem;
      font-weight: normal;
      letter-spacing: -0.01em;
      color: var(--text);
    }

    .header-title p {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .header-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    /* â”€â”€ Buttons â”€â”€ */
    button {
      cursor: pointer;
      font-family: var(--font-sans);
      border: none;
      border-radius: var(--radius);
      transition: opacity 0.15s, background 0.15s;
    }

    button:hover { opacity: 0.85; }
    button:active { opacity: 0.7; }

    .btn-primary {
      background: var(--accent);
      color: #fff;
      padding: 7px 14px;
      font-size: 0.85rem;
    }

    .btn-secondary {
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      padding: 7px 14px;
      font-size: 0.85rem;
    }

    .btn-icon {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 7px 10px;
      font-size: 1rem;
      line-height: 1;
    }

    /* Plain text link button */
    .btn-text {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.8rem;
      padding: 4px 6px;
      text-decoration: underline;
      white-space: nowrap;
    }

    /* Spinning animation for refresh button when loading */
    .btn-spinning { animation: spin 0.8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* â”€â”€ Auth area styles â”€â”€ */

    /* Google sign-in button */
    .btn-signin {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 6px 12px;
      font-size: 0.82rem;
      font-weight: 500;
      white-space: nowrap;
      box-shadow: var(--shadow);
    }

    .btn-signin svg {
      flex-shrink: 0;
    }

    /* Signed-in user display */
    .auth-user {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .user-avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      object-fit: cover;
      border: 1px solid var(--border);
      flex-shrink: 0;
    }

    /* Fallback avatar when no photo */
    .user-avatar-fallback {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: var(--accent);
      color: #fff;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .user-name {
      font-size: 0.82rem;
      color: var(--text-muted);
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .btn-signout {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 0.75rem;
      text-decoration: underline;
      padding: 0;
      cursor: pointer;
    }

    .btn-signout:hover { color: var(--text); opacity: 1; }

    /* Hint shown in settings panel when signed out */
    .signin-notice {
      font-style: italic;
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-bottom: 14px;
    }

    /* Dim the add-keyword row when signed out */
    .add-keyword-row.disabled {
      opacity: 0.45;
      pointer-events: none;
    }

    /* â”€â”€ Settings Panel â”€â”€ */
    .settings-panel {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 24px;
      box-shadow: var(--shadow);
      display: none; /* hidden by default, toggled by JS */
    }

    .settings-panel.open { display: block; }

    .settings-panel h2 {
      font-family: var(--font-serif);
      font-size: 1rem;
      font-weight: normal;
      margin-bottom: 14px;
      color: var(--text);
    }

    /* Keyword chips container */
    .keyword-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
      min-height: 36px;
    }

    /* Each keyword is a toggle chip */
    .keyword-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: var(--tag-bg);
      color: var(--accent);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 4px 10px 4px 12px;
      font-size: 0.8rem;
      cursor: pointer;
      user-select: none;
      transition: background 0.15s, color 0.15s;
    }

    /* Disabled/off chip style */
    .keyword-chip.off {
      background: var(--tag-off);
      color: var(--tag-off-text);
      border-color: var(--border);
      text-decoration: line-through;
    }

    /* The Ã— remove button inside each chip */
    .keyword-chip .remove-btn {
      background: none;
      border: none;
      color: inherit;
      font-size: 1rem;
      line-height: 1;
      padding: 0 0 0 2px;
      opacity: 0.5;
      cursor: pointer;
    }

    .keyword-chip .remove-btn:hover { opacity: 1; }

    /* Add keyword input row */
    .add-keyword-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .add-keyword-row input {
      flex: 1;
      font-family: var(--font-sans);
      font-size: 0.85rem;
      padding: 7px 12px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--bg);
      color: var(--text);
      outline: none;
    }

    .add-keyword-row input:focus { border-color: var(--accent); }

    /* â”€â”€ Active keyword tags shown below header â”€â”€ */
    .active-keywords-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 16px;
      align-items: center;
    }

    .active-keywords-bar .bar-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-right: 4px;
    }

    .active-kw-tag {
      background: var(--accent-light);
      color: var(--accent);
      border-radius: 12px;
      padding: 2px 10px;
      font-size: 0.75rem;
    }

    /* â”€â”€ Search bar â”€â”€ */
    .search-bar-container {
      margin-bottom: 12px;
    }

    .search-input-wrapper {
      position: relative;
      display: flex;
      align-items: center;
    }

    .search-icon {
      position: absolute;
      left: 12px;
      font-size: 0.9rem;
      pointer-events: none;
      color: var(--text-muted);
    }

    .search-input {
      width: 100%;
      font-family: var(--font-sans);
      font-size: 0.9rem;
      padding: 9px 36px 9px 36px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--surface);
      color: var(--text);
      outline: none;
      transition: border-color 0.15s;
    }

    .search-input:focus { border-color: var(--accent); }

    .search-clear-btn {
      position: absolute;
      right: 8px;
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 0.85rem;
      padding: 4px 6px;
      line-height: 1;
      cursor: pointer;
    }

    .search-clear-btn:hover { color: var(--text); opacity: 1; }

    /* Search highlight inside paper cards */
    mark.search-highlight {
      background: #fff176;
      color: inherit;
      border-radius: 2px;
      padding: 0 1px;
    }

    [data-theme="dark"] mark.search-highlight {
      background: #7a6d00;
    }

    /* â”€â”€ Filter panel â”€â”€ */
    .filter-panel {
      margin-bottom: 16px;
    }

    .filter-panel-header {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .filter-toggle-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }

    /* Small badge showing how many filters are active */
    .filter-active-count {
      background: var(--accent);
      color: #fff;
      border-radius: 10px;
      font-size: 0.7rem;
      font-weight: 600;
      padding: 1px 6px;
      min-width: 18px;
      text-align: center;
    }

    /* Active filter tag pills in the header row */
    .active-filter-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      flex: 1;
    }

    .filter-tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: var(--accent-light);
      color: var(--accent);
      border: 1px solid var(--accent);
      border-radius: 12px;
      padding: 2px 8px 2px 10px;
      font-size: 0.75rem;
      white-space: nowrap;
    }

    .filter-tag-remove {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.8rem;
      padding: 0;
      line-height: 1;
      cursor: pointer;
      opacity: 0.6;
    }

    .filter-tag-remove:hover { opacity: 1; }

    /* The collapsible body of the filter panel */
    .filter-panel-body {
      margin-top: 12px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
      display: flex;
      flex-wrap: wrap;
      gap: 16px 24px;
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 140px;
    }

    .filter-group-label {
      font-size: 0.72rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
    }

    .filter-check-row,
    .filter-radio-row {
      display: flex;
      flex-wrap: wrap;
      gap: 4px 6px;
    }

    /* Individual filter option labels */
    .filter-option-label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      padding: 3px 8px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--bg);
      color: var(--text);
      user-select: none;
      white-space: nowrap;
      transition: background 0.12s, border-color 0.12s;
    }

    .filter-option-label input[type="checkbox"],
    .filter-option-label input[type="radio"] {
      display: none; /* we style the label itself as the control */
    }

    .filter-option-label:has(input:checked) {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }

    .sort-select {
      font-family: var(--font-sans);
      font-size: 0.82rem;
      padding: 5px 8px;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      outline: none;
    }

    .sort-select:focus { border-color: var(--accent); }

    /* â”€â”€ Status / error messages â”€â”€ */
    .status-bar {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-bottom: 16px;
      min-height: 20px;
    }

    .status-bar.error { color: #c0392b; }

    /* â”€â”€ Feed header â”€â”€ */
    .feed-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 0.8rem;
    }

    .feed-header-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .feed-header-right {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--text-muted);
    }

    .feed-count {
      font-weight: 600;
      color: var(--text);
    }

    /* Unread badge */
    .unread-badge {
      background: var(--accent);
      color: #fff;
      border-radius: 10px;
      font-size: 0.7rem;
      font-weight: 600;
      padding: 1px 7px;
    }

    .feed-last-refreshed {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    /* "Show hidden" toggle label */
    .toggle-label {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      cursor: pointer;
      user-select: none;
      color: var(--text-muted);
    }

    .toggle-label input[type="checkbox"] {
      cursor: pointer;
      accent-color: var(--accent);
    }

    /* â”€â”€ Paper Feed â”€â”€ */
    .paper-feed {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    /* Individual paper card */
    .paper-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px 22px;
      box-shadow: var(--shadow);
      transition: box-shadow 0.15s, opacity 0.35s, transform 0.35s;
    }

    .paper-card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.12); }

    /* Fading out on hide */
    .paper-card--fading {
      opacity: 0;
      transform: translateY(-6px);
      pointer-events: none;
    }

    .paper-card-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 8px;
    }

    .paper-title {
      font-family: var(--font-serif);
      font-size: 1.05rem;
      line-height: 1.4;
      color: var(--text);
      flex: 1;
    }

    .paper-title a {
      color: inherit;
      text-decoration: none;
    }

    .paper-title a:hover { color: var(--accent); text-decoration: underline; }

    /* Score badge */
    .score-badge {
      flex-shrink: 0;
      font-size: 0.75rem;
      font-weight: 600;
      padding: 3px 8px;
      border-radius: 12px;
      background: var(--tag-bg);
      color: var(--score-low);
      white-space: nowrap;
    }

    .score-badge.high { color: var(--score-high); background: #eef6ef; }
    .score-badge.mid  { color: var(--score-mid);  background: #f6f2ea; }

    [data-theme="dark"] .score-badge.high { background: #1a2e1c; }
    [data-theme="dark"] .score-badge.mid  { background: #2c2718; }

    .paper-meta {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-bottom: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 0 4px;
      align-items: center;
    }

    /* Citation count in meta row (legacy â€” kept for backward compat) */
    .citation-count {
      margin-left: 4px;
      color: var(--text-muted);
    }

    /* â”€â”€ Author link + count â”€â”€ */
    .author-link {
      color: var(--text-muted);
      text-decoration: none;
    }
    .author-link:hover { color: var(--accent); text-decoration: underline; }
    .author-count { font-size: 0.72rem; color: var(--text-muted); }

    /* â”€â”€ Open Access badge + PDF link â”€â”€ */
    .oa-badge { font-size: 0.82rem; vertical-align: middle; }
    .oa-badge.locked { opacity: 0.45; }
    .pdf-link {
      color: var(--accent);
      text-decoration: none;
      font-size: 0.75rem;
      margin-left: 2px;
    }
    .pdf-link:hover { text-decoration: underline; }

    /* â”€â”€ Rich metrics row â”€â”€ */
    .paper-metrics {
      display: flex;
      flex-wrap: wrap;
      gap: 4px 12px;
      margin: 8px 0 4px;
      font-size: 0.75rem;
      color: var(--text-muted);
      align-items: center;
    }

    .metric { display: inline-flex; align-items: center; gap: 3px; }

    /* Clickable metric (citation count, ref count) */
    .metric-link {
      text-decoration: none;
      cursor: pointer;
      border-bottom: 1px dashed currentColor;
      transition: opacity 0.12s;
    }
    .metric-link:hover { opacity: 0.75; }

    /* Citation count colour tiers */
    .cite-grey  { color: var(--text-muted); }
    .cite-blue  { color: #4a90d9; font-weight: 500; }
    .cite-green { color: var(--score-high); font-weight: 500; }
    .cite-gold  { color: #c9930a; font-weight: 700; }

    [data-theme="dark"] .cite-blue  { color: #6aabda; }
    [data-theme="dark"] .cite-gold  { color: #e0a800; }

    /* Citation velocity */
    .velocity-trending { color: #cc3344; font-weight: 600; }
    .velocity-growing  { color: var(--score-high); font-weight: 500; }
    .velocity-stable   { color: var(--text-muted); }

    /* Highly influential badge */
    .highly-influential-badge {
      background: #fff3cd;
      color: #7d5a00;
      border-radius: 10px;
      padding: 1px 8px;
      font-weight: 600;
      font-size: 0.72rem;
    }
    [data-theme="dark"] .highly-influential-badge { background: #2d2300; color: #e0a800; }

    /* Venue name â€” italic, truncated */
    .venue-name {
      font-style: italic;
      color: var(--text-muted);
      max-width: 240px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: inline-block;
      vertical-align: middle;
    }

    /* Fields of study tags */
    .field-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin: 4px 0 6px;
    }
    .field-tag {
      background: var(--tag-off);
      color: var(--tag-off-text);
      border-radius: 10px;
      padding: 1px 8px;
      font-size: 0.70rem;
    }

    /* On mobile, hide venue + field tags to save space */
    @media (max-width: 600px) {
      .venue-name { display: none; }
      .field-tags { display: none; }
    }

    /* â”€â”€ Paper card badges (score + wildcard) â”€â”€ */
    .paper-card-badges {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }

    /* â”€â”€ Wildcard / Explore badge â”€â”€ */
    .wildcard-badge {
      display: inline-block;
      background: #e8f4f8;
      color: #1a6a8a;
      border-radius: 10px;
      padding: 2px 8px;
      font-size: 0.70rem;
      font-weight: 600;
      white-space: nowrap;
    }
    [data-theme="dark"] .wildcard-badge {
      background: #0d2d3a;
      color: #5bbcde;
    }
    .paper-card--wildcard {
      border-left: 3px solid #5bbcde;
    }

    /* â”€â”€ Research Profile section â”€â”€ */
    .research-profile {
      margin-top: 28px;
      border-top: 1px solid var(--border);
      padding-top: 20px;
    }
    .research-profile-inner {}
    .profile-heading {
      font-size: 1rem;
      font-weight: 700;
      margin: 0 0 4px;
      color: var(--text);
    }
    .profile-subtitle {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin: 0 0 16px;
    }
    .profile-section {
      margin-bottom: 16px;
    }
    .profile-section-title {
      font-size: 0.82rem;
      font-weight: 600;
      margin: 0 0 4px;
      color: var(--text);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .profile-hint {
      font-size: 0.74rem;
      color: var(--text-muted);
      margin: 0 0 8px;
    }
    .profile-empty {
      font-size: 0.78rem;
      color: var(--text-muted);
      font-style: italic;
    }
    .profile-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .profile-topic-chip {
      background: var(--tag-off);
      color: var(--tag-off-text);
      border-radius: 10px;
      padding: 2px 10px;
      font-size: 0.75rem;
    }

    /* â”€â”€ Learned keyword chips (with Ã— remove button) â”€â”€ */
    .learned-kw-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 4px;
    }
    .learned-kw-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: #e8f0fe;
      color: #1a3a8a;
      border-radius: 10px;
      padding: 2px 8px 2px 10px;
      font-size: 0.75rem;
      font-weight: 500;
    }
    [data-theme="dark"] .learned-kw-chip {
      background: #1a2a4a;
      color: #7aabde;
    }
    .remove-learned-btn {
      background: none;
      border: none;
      cursor: pointer;
      color: inherit;
      opacity: 0.6;
      font-size: 0.85rem;
      line-height: 1;
      padding: 0 1px;
    }
    .remove-learned-btn:hover { opacity: 1; }

    /* â”€â”€ Reset profile button â”€â”€ */
    .btn-reset-profile {
      margin-top: 8px;
      font-size: 0.78rem;
      padding: 5px 12px;
    }

    .paper-abstract {
      font-size: 0.88rem;
      color: var(--text);
      line-height: 1.65;
      /* Show first ~4 lines, expandable */
      display: -webkit-box;
      -webkit-line-clamp: 4;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .paper-abstract.expanded {
      display: block;
      -webkit-line-clamp: unset;
    }

    .expand-btn {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.78rem;
      padding: 4px 0;
      margin-top: 4px;
      cursor: pointer;
      display: inline-block;
    }

    .expand-btn:hover { text-decoration: underline; opacity: 1; }

    /* Keyword match tags under abstract */
    .paper-keyword-tags {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .matched-kw-tag {
      background: var(--accent-light);
      color: var(--accent);
      border-radius: 10px;
      padding: 1px 8px;
      font-size: 0.72rem;
    }

    /* â”€â”€ Paper action buttons â”€â”€ */
    .paper-actions {
      display: flex;
      gap: 6px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
      flex-wrap: wrap;
    }

    .action-btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text-muted);
      border-radius: 14px;
      padding: 4px 10px;
      font-size: 0.78rem;
      cursor: pointer;
      transition: background 0.12s, color 0.12s, border-color 0.12s;
      user-select: none;
    }

    .action-btn:hover { opacity: 1; background: var(--tag-bg); color: var(--text); }

    /* Active (toggled on) state */
    .action-btn.active { color: #fff; border-color: transparent; }

    .like-btn.active  { background: #e35; }
    .save-btn.active  { background: var(--score-high); }
    .hide-btn.active  { background: #888; }

    /* Disabled when signed out */
    .action-btn.disabled-action {
      opacity: 0.35;
      pointer-events: none;
      cursor: default;
    }

    /* â”€â”€ Pagination load-more â”€â”€ */
    .feed-load-more {
      text-align: center;
      padding: 8px 0 4px;
    }

    .feed-load-more button {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 9px 28px;
      font-size: 0.85rem;
      border-radius: var(--radius);
    }

    .feed-load-more button:hover { background: var(--tag-bg); opacity: 1; }

    /* â”€â”€ Empty / loading states â”€â”€ */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .empty-state .icon { font-size: 2.5rem; margin-bottom: 12px; }

    /* â”€â”€ Skeleton loading cards â”€â”€ */
    .skeleton-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px 22px;
    }

    .skeleton-line {
      background: var(--border);
      border-radius: 4px;
      margin-bottom: 10px;
      animation: pulse 1.4s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50%       { opacity: 0.5; }
    }

    /* â”€â”€ Footer â”€â”€ */
    footer {
      margin-top: 40px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
      font-size: 0.75rem;
      color: var(--text-muted);
      text-align: center;
    }

    /* â”€â”€ Health / system status bar (bottom of page) â”€â”€ */
    .health-bar {
      margin-top: 12px;
      padding: 6px 12px;
      border-radius: var(--radius);
      font-size: 0.72rem;
      display: inline-block;
      background: var(--tag-bg);
      color: var(--text-muted);
      border: 1px solid var(--border);
    }

    .health-bar.ok    { color: var(--score-high); background: #eef6ef; border-color: #c3e0c7; }
    .health-bar.error { color: #c0392b;           background: #fdf0ef; border-color: #f0c4c0; }

    [data-theme="dark"] .health-bar.ok    { background: #1a2e1c; border-color: #2d4d30; }
    [data-theme="dark"] .health-bar.error { background: #2e1a1a; border-color: #4d2d2d; }

    /* â”€â”€ Responsive â”€â”€ */
    @media (max-width: 600px) {
      .header-title h1 { font-size: 1.2rem; }
      .paper-card { padding: 16px; }
      .paper-title { font-size: 0.95rem; }
      .filter-panel-body { gap: 12px; }
    }
  </style>
</head>
<body>

<div class="app-wrapper">

  <!-- â”€â”€ Header â”€â”€ -->
  <header>
    <div class="header-title">
      <h1>Research Hub</h1>
      <p>HRI Paper Feed â€” Semantic Scholar</p>
    </div>
    <div class="header-actions">
      <!-- Auth area: shows sign-in button OR avatar + name + sign-out -->
      <div class="auth-area" id="authArea"></div>
      <!-- Refresh button â€” its inner span spins while loading -->
      <button class="btn-icon" id="refreshBtn" title="Fetch new papers" aria-label="Refresh papers">
        <span id="refreshIcon">â†»</span>
      </button>
      <!-- Dark/light mode toggle -->
      <button class="btn-icon" id="themeBtn" title="Toggle dark/light mode" aria-label="Toggle theme">ğŸŒ™</button>
      <!-- Settings toggle -->
      <button class="btn-secondary" id="settingsToggle">âš™ Keywords</button>
    </div>
  </header>

  <!-- â”€â”€ Settings Panel (hidden by default) â”€â”€ -->
  <section class="settings-panel" id="settingsPanel" aria-label="Keyword settings">
    <h2>Search Keywords</h2>
    <p style="font-size:0.8rem; color:var(--text-muted); margin-bottom:14px;">
      Click a keyword to toggle it on/off. Active keywords are used to fetch and score papers.
      The Ã— button removes a keyword entirely.
    </p>

    <!-- Sign-in hint shown only when signed out -->
    <p class="signin-notice" id="signinNotice" style="display:none;">
      Sign in with Google to save your keywords across devices.
    </p>

    <!-- Keyword chips are rendered here by JS -->
    <div class="keyword-list" id="keywordList"></div>

    <!-- Add new keyword â€” disabled (dimmed) when signed out -->
    <div class="add-keyword-row" id="addKeywordRow">
      <input type="text" id="newKeywordInput" placeholder="Add a keywordâ€¦" maxlength="80" aria-label="New keyword" />
      <button class="btn-primary" id="addKeywordBtn">Add</button>
    </div>

    <!-- Research Profile â€” rendered by renderResearchProfile() when signed in -->
    <div id="researchProfile" class="research-profile" style="display:none;"></div>
  </section>

  <!-- â”€â”€ Active keyword tags shown in feed view â”€â”€ -->
  <div class="active-keywords-bar" id="activeKeywordsBar"></div>

  <!-- â”€â”€ Search bar â”€â”€ -->
  <div class="search-bar-container" id="searchBarContainer">
    <div class="search-input-wrapper">
      <span class="search-icon">ğŸ”</span>
      <input id="searchInput" class="search-input" type="search"
             placeholder="Search titles, abstracts, authorsâ€¦" maxlength="200" />
      <button id="searchClearBtn" class="search-clear-btn" style="display:none" aria-label="Clear search">âœ•</button>
    </div>
  </div>

  <!-- â”€â”€ Filter panel â”€â”€ -->
  <div id="filterPanel" class="filter-panel">
    <div class="filter-panel-header">
      <button id="filterToggleBtn" class="btn-secondary filter-toggle-btn">
        âš™ Filters <span id="filterActiveCount" class="filter-active-count" style="display:none"></span>
      </button>
      <div id="activeFilterTags" class="active-filter-tags"></div>
      <button id="clearAllFiltersBtn" class="btn-text" style="display:none">Clear all</button>
    </div>
    <div id="filterPanelBody" class="filter-panel-body" style="display:none">
      <div class="filter-group">
        <label class="filter-group-label" for="sortSelect">Sort</label>
        <select id="sortSelect" class="sort-select">
          <option value="newest">Newest first</option>
          <option value="oldest">Oldest first</option>
          <option value="relevance">Highest relevance</option>
          <option value="cited">Most cited</option>
          <option value="influential">Most influential citations</option>
          <option value="trending">Trending (citation velocity)</option>
        </select>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Relevance</span>
        <div id="scoreFilterGroup" class="filter-check-row"></div>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Date</span>
        <div id="dateFilterGroup" class="filter-radio-row"></div>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Status</span>
        <div id="statusFilterGroup" class="filter-radio-row"></div>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Keyword</span>
        <div id="keywordFilterGroup" class="filter-check-row"></div>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Citations</span>
        <div id="citationFilterGroup" class="filter-radio-row"></div>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Influential</span>
        <div id="inflCitationFilterGroup" class="filter-radio-row"></div>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Velocity</span>
        <div id="velocityFilterGroup" class="filter-radio-row"></div>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Access</span>
        <div id="openAccessFilterGroup" class="filter-check-row"></div>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Type</span>
        <div id="pubTypeFilterGroup" class="filter-radio-row"></div>
      </div>
      <div class="filter-group">
        <span class="filter-group-label">Field</span>
        <div id="fieldsFilterGroup" class="filter-check-row"></div>
      </div>
    </div>
  </div>

  <!-- â”€â”€ Feed header â”€â”€ -->
  <div id="feedHeader" class="feed-header">
    <div class="feed-header-left">
      <span id="feedCount" class="feed-count"></span>
      <span id="unreadBadge" class="unread-badge" style="display:none"></span>
    </div>
    <div class="feed-header-right">
      <span id="feedLastRefreshed" class="feed-last-refreshed"></span>
      <label class="toggle-label">
        <input type="checkbox" id="showHiddenToggle"> Show hidden
      </label>
    </div>
  </div>

  <!-- â”€â”€ Status line â”€â”€ -->
  <div class="status-bar" id="statusBar"></div>

  <!-- â”€â”€ Paper feed â”€â”€ -->
  <main class="paper-feed" id="paperFeed" aria-live="polite"></main>

  <footer>
    Data from <a href="https://www.semanticscholar.org/" target="_blank" rel="noopener" style="color:var(--accent)">Semantic Scholar</a>
    â€” open and free academic search API.
    <div id="healthBar" class="health-bar" style="display:none;"></div>
  </footer>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Research Hub â€” HRI Paper Feed
//  Single-file vanilla JS app. No frameworks, no build step.
//  Keywords sync to Firestore when signed in.
//  Paper actions (like/save/hide) stored in Firestore subcollection.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ Firebase setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const firebaseConfig = {
  apiKey:            'AIzaSyCGeXjURWaP02MdENQIR5wjQJdmapyAEPo',
  authDomain:        'research-hub-8da6a.firebaseapp.com',
  projectId:         'research-hub-8da6a',
  storageBucket:     'research-hub-8da6a.firebasestorage.app',
  messagingSenderId: '765872653008',
  appId:             '1:765872653008:web:ea08868e0e59e86acb14d5',
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db   = firebase.firestore();

// Holds the signed-in Firebase User object, or null if signed out.
let currentUser = null;


// â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const THEME_KEY       = 'researchhub_theme';
const LAST_FETCH_KEY  = 'researchhub_last_fetch';
const HEALTH_KEY      = 'researchhub_health';
const SEEN_PAPERS_KEY = 'researchhub_seen_papers';
const FETCH_TTL_MS    = 24 * 60 * 60 * 1000;
const PAGE_SIZE       = 20;

const API_BASE     = '/api/papers';
const PAPERS_LIMIT = 30;

// Stop words excluded when extracting topic keywords from paper titles/abstracts.
const STOP_WORDS = new Set([
  'the','a','an','and','or','but','in','on','at','to','for','of','with','by',
  'from','as','is','are','was','were','be','been','being','have','has','had',
  'do','does','did','will','would','could','should','may','might','this','that',
  'these','those','it','its','we','our','they','their','study','paper','research',
  'using','used','results','show','shows','showed','approach','method','methods',
  'system','based','new','also','can','two','one','both','between','more','most',
  'such','than','when','which','who','how','data','model','propose','proposed',
  'present','demonstrate','find','found','analysis','evaluate','evaluation',
  'provide','different','task','tasks','work','works','high','large','small',
  'number','recent','review','effect','effects','related','across','within',
  'toward','through','during','while','where','other','each','into','over',
]);

const DEFAULT_KEYWORDS = [
  { text: 'social robots',          active: true },
  { text: 'human-robot interaction', active: true },
  { text: 'emotional contagion',    active: true },
  { text: 'priming public spaces',  active: true },
  { text: 'non-humanoid robots',    active: true },
];

// Fields we request from Semantic Scholar.
// All fields are returned in a single API response â€” no extra calls needed.
const API_FIELDS = 'title,abstract,authors,year,publicationDate,externalIds,url,' +
  'citationCount,influentialCitationCount,referenceCount,' +
  'isOpenAccess,openAccessPdf,publicationVenue,fieldsOfStudy';


// â”€â”€ App State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let keywords    = [];   // { text, active }[]
let allPapers   = [];   // raw results per fetch â€” never mutated after set
let papers      = [];   // derived filtered+sorted view of allPapers
let loading     = false;

let searchQuery = '';       // current live search string
let searchTimer = null;     // debounce handle

let filterState = {
  scores:        [1, 2, 3, 4, 5],  // active score checkboxes
  dateRange:     'all',             // 'all'|'7d'|'30d'|'90d'|'1y'
  status:        'all',             // 'all'|'unread'|'liked'|'saved'|'hidden'
  keywords:      [],                // [] = no keyword filter; strings = must match one
  citations:     0,                 // minimum total citation count: 0|10|50|100|500
  inflCitations: 0,                 // minimum influential citations: 0|5|10|25
  velocity:      'any',             // 'any'|'trending'|'growing'|'stable'
  openAccess:    false,             // true = open-access papers only
  pubType:       'all',             // 'all'|'journal'|'conference'|'preprint'
  fields:        [],                // [] = all fields; strings = must match at least one
};

let sortOrder  = 'relevance';  // 'newest'|'oldest'|'relevance'|'cited'|'influential'|'trending'
let pageIndex  = 0;

// Cache of { [paperId]: { liked, saved, hidden } } loaded from Firestore
let userActions = {};

// Cache of { [paperId]: { liked, saved, expanded, clicked, secondsVisible, ... } }
// Separate from userActions â€” stores richer behavioral signals for learning
let userSignals = {};

// Learned keywords extracted from papers the user has liked/saved
// { text: string, weight: number }[]  â€” persisted to Firestore users/{uid}.learnedKeywords
let learnedKeywords = [];

// Set of paperIds seen in a previous session (for unread badge)
let seenPaperIds = new Set();

// Whether to include hidden papers in the feed
let showHidden = false;


// â”€â”€ Initialise â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function init() {
  renderAuthUI();
  loadKeywords();
  loadTheme();
  loadSeenPapers();
  bindEvents();
  renderFilterPanel();
  renderHealthBar();
  smartRefresh();
}


// â”€â”€ Auth UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderAuthUI() {
  const area = document.getElementById('authArea');
  if (!area) return;

  if (currentUser) {
    const photo    = currentUser.photoURL;
    const name     = currentUser.displayName || currentUser.email || 'User';
    const initials = name.charAt(0).toUpperCase();

    const avatarHtml = photo
      ? `<img class="user-avatar" src="${esc(photo)}" alt="${esc(name)}" referrerpolicy="no-referrer">`
      : `<span class="user-avatar-fallback">${esc(initials)}</span>`;

    area.innerHTML = `
      <div class="auth-user">
        ${avatarHtml}
        <span class="user-name" title="${esc(name)}">${esc(name)}</span>
        <button class="btn-signout" id="signOutBtn">Sign out</button>
      </div>`;

    document.getElementById('signOutBtn').addEventListener('click', signOut);

    const row    = document.getElementById('addKeywordRow');
    const notice = document.getElementById('signinNotice');
    if (row)    row.classList.remove('disabled');
    if (notice) notice.style.display = 'none';

  } else {
    area.innerHTML = `
      <button class="btn-signin" id="signInBtn">
        <svg width="16" height="16" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
          <path d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844a4.14 4.14 0 0 1-1.796 2.716v2.259h2.908c1.702-1.567 2.684-3.875 2.684-6.615z" fill="#4285F4"/>
          <path d="M9 18c2.43 0 4.467-.806 5.956-2.184l-2.908-2.259c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332A8.997 8.997 0 0 0 9 18z" fill="#34A853"/>
          <path d="M3.964 10.706A5.41 5.41 0 0 1 3.682 9c0-.593.102-1.17.282-1.706V4.962H.957A8.996 8.996 0 0 0 0 9c0 1.452.348 2.827.957 4.038l3.007-2.332z" fill="#FBBC05"/>
          <path d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0A8.997 8.997 0 0 0 .957 4.962L3.964 7.294C4.672 5.163 6.656 3.58 9 3.58z" fill="#EA4335"/>
        </svg>
        Sign in with Google
      </button>`;

    document.getElementById('signInBtn').addEventListener('click', signIn);

    const row    = document.getElementById('addKeywordRow');
    const notice = document.getElementById('signinNotice');
    if (row)    row.classList.add('disabled');
    if (notice) notice.style.display = 'block';
  }
}

function signIn() {
  const provider = new firebase.auth.GoogleAuthProvider();
  auth.signInWithPopup(provider).catch(err => {
    console.error('Sign-in error:', err);
  });
}

function signOut() {
  auth.signOut().catch(err => {
    console.error('Sign-out error:', err);
  });
}


// â”€â”€ Firestore: keywords â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function userDocRef() {
  return db.collection('users').doc(currentUser.uid);
}

async function loadKeywordsFromFirestore() {
  try {
    const snap = await userDocRef().get();
    if (snap.exists && snap.data().keywords) {
      keywords = snap.data().keywords;
    } else {
      keywords = DEFAULT_KEYWORDS.map(k => ({ ...k }));
      await saveKeywordsToFirestore();
    }
  } catch (e) {
    console.error('Firestore load error:', e);
    keywords = DEFAULT_KEYWORDS.map(k => ({ ...k }));
  }
}

async function saveKeywordsToFirestore() {
  try {
    await userDocRef().set({ keywords }, { merge: true });
  } catch (e) {
    console.error('Firestore save error:', e);
  }
}


// â”€â”€ Firestore: user actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Actions are stored in a subcollection: users/{uid}/actions/{paperId}
// Each doc: { liked: bool, saved: bool, hidden: bool, updatedAt: Timestamp }

function userActionsRef() {
  return db.collection('users').doc(currentUser.uid).collection('actions');
}

// Load all action docs for the current user into the userActions cache.
async function loadUserActions() {
  if (!currentUser) return;
  try {
    const snap = await userActionsRef().get();
    userActions = {};
    snap.forEach(doc => {
      userActions[doc.id] = doc.data();
    });
    renderPapers(); // re-render with loaded actions
  } catch (e) {
    console.error('Error loading user actions:', e);
  }
}

// Update one action field for a paper (merges with existing doc).
async function saveUserAction(paperId, key, value) {
  if (!currentUser) return;
  userActions[paperId] = userActions[paperId] || {};
  userActions[paperId][key] = value;
  try {
    await userActionsRef().doc(paperId).set(
      { [key]: value, updatedAt: firebase.firestore.FieldValue.serverTimestamp() },
      { merge: true }
    );
  } catch (e) {
    console.error('Error saving user action:', e);
  }
}


// â”€â”€ Firestore: behavioral signals â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Signals are stored in: users/{uid}/signals/{paperId}
// Separate from 'actions' â€” stores richer behavioral data for learning.
// Each doc: { liked, saved, expanded, clicked, secondsVisible, removed,
//             title, abstract, authors, updatedAt }

function userSignalsRef() {
  return db.collection('users').doc(currentUser.uid).collection('signals');
}

// Load all signal docs into the in-memory userSignals cache.
async function loadUserSignals() {
  if (!currentUser) return;
  try {
    const snap = await userSignalsRef().get();
    userSignals = {};
    snap.forEach(doc => { userSignals[doc.id] = doc.data(); });
  } catch (e) {
    console.error('Error loading user signals:', e);
  }
}

// Write a single field to a signal doc (merge). Also snapshots the paper
// content so we can do keyword extraction later without re-fetching.
async function recordSignal(paperId, field, value) {
  if (!currentUser) return;
  const paper = allPapers.find(p => p.paperId === paperId);
  // Update in-memory cache immediately
  userSignals[paperId] = userSignals[paperId] || {};
  userSignals[paperId][field] = value;
  const doc = {
    [field]: value,
    title:    paper?.title    || userSignals[paperId]?.title    || '',
    abstract: paper?.abstract || userSignals[paperId]?.abstract || '',
    authors:  paper?.authors  || userSignals[paperId]?.authors  || [],
    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
  };
  try {
    await userSignalsRef().doc(paperId).set(doc, { merge: true });
  } catch (e) {
    console.error('Error recording signal:', e);
  }
}

// Compute a signal-based score adjustment for a paper based on past interactions.
// Returns a raw number (positive = boost, negative = penalty). Not clamped yet.
function computeSignalScore(paperId) {
  const s = userSignals[paperId];
  if (!s) return 0;

  // Recency multiplier based on updatedAt timestamp
  const updatedAt = s.updatedAt?.toDate?.() || new Date(0);
  const daysAgo   = (Date.now() - updatedAt.getTime()) / (1000 * 60 * 60 * 24);
  const recency   = daysAgo <= 7 ? 1.0 : daysAgo <= 30 ? 0.7 : 0.4;

  let raw = 0;
  if (s.liked)    raw += 3;
  if (s.saved)    raw += 2;
  if (s.removed)  raw -= 5;
  if (s.expanded) raw += 1;
  if (s.clicked)  raw += 2;
  // Time on screen: +0.5 per 10s, capped at 120s = max +6
  raw += Math.min(s.secondsVisible || 0, 120) / 10 * 0.5;

  return raw * recency;
}


// â”€â”€ Keyword learning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Extract the top N meaningful words from a paper's title + abstract.
// Title is weighted double (concatenated twice) so title words score higher.
function extractKeywords(title, abstract, topN = 3) {
  const text   = `${title} ${title} ${abstract}`.toLowerCase();
  const tokens = text.split(/[^a-z]+/).filter(w => w.length >= 4 && !STOP_WORDS.has(w));
  const freq   = {};
  for (const t of tokens) freq[t] = (freq[t] || 0) + 1;
  return Object.entries(freq)
    .sort((a, b) => b[1] - a[1])
    .slice(0, topN)
    .map(([word]) => word);
}

// Compute a relevance boost (0â€“2) from learned keywords matching this paper.
function scoreLearnedKeywords(paper) {
  if (!learnedKeywords.length) return 0;
  const text = `${paper.title || ''} ${paper.abstract || ''}`.toLowerCase();
  let boost  = 0;
  for (const lk of learnedKeywords) {
    if (text.includes(lk.text.toLowerCase())) {
      boost += lk.weight * 0.3;
    }
  }
  return Math.min(2, boost);
}

// Called when a user likes or saves a paper.
// Extracts keywords and adds/strengthens them in learnedKeywords[].
function addLearnedKeywords(paper) {
  if (!currentUser || !paper) return;
  const extracted = extractKeywords(paper.title || '', paper.abstract || '');
  const manualTexts = keywords.map(k => k.text.toLowerCase());
  let changed = false;

  for (const word of extracted) {
    // Don't learn words already in manual keywords
    if (manualTexts.some(m => m.includes(word) || word.includes(m))) continue;
    const existing = learnedKeywords.find(lk => lk.text === word);
    if (existing) {
      existing.weight = Math.min(3.0, existing.weight + 0.5); // strengthen
    } else {
      learnedKeywords.push({ text: word, weight: 1.0 });
    }
    changed = true;
  }

  if (changed) {
    saveLearnedKeywords();
    renderResearchProfile();
  }
}

// Remove a learned keyword by text (called from settings UI).
function removeLearnedKeyword(text) {
  learnedKeywords = learnedKeywords.filter(lk => lk.text !== text);
  saveLearnedKeywords();
  rescoreAll();
  renderResearchProfile();
}

// Load learnedKeywords from the users/{uid} document.
async function loadLearnedKeywords() {
  if (!currentUser) return;
  try {
    const doc = await db.collection('users').doc(currentUser.uid).get();
    learnedKeywords = doc.data()?.learnedKeywords || [];
  } catch (e) {
    console.error('Error loading learned keywords:', e);
    learnedKeywords = [];
  }
}

// Persist learnedKeywords back to Firestore.
async function saveLearnedKeywords() {
  if (!currentUser) return;
  try {
    await db.collection('users').doc(currentUser.uid).set(
      { learnedKeywords },
      { merge: true }
    );
  } catch (e) {
    console.error('Error saving learned keywords:', e);
  }
}

// Reset the full learning profile: delete all signals + learned keywords.
async function resetLearningProfile() {
  if (!currentUser) return;
  if (!confirm('Reset your learning profile? This will clear all signals and learned keywords. Your manual keywords stay unchanged.')) return;

  try {
    // Batch-delete all signal docs
    const snap = await userSignalsRef().get();
    const batch = db.batch();
    snap.forEach(doc => batch.delete(doc.ref));
    await batch.commit();

    // Clear learned keywords from Firestore
    await db.collection('users').doc(currentUser.uid).set(
      { learnedKeywords: [] },
      { merge: true }
    );
  } catch (e) {
    console.error('Error resetting profile:', e);
  }

  userSignals     = {};
  learnedKeywords = [];
  rescoreAll();
  renderResearchProfile();
}


// â”€â”€ Combined scoring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Full relevance score incorporating keyword match, signal history, and learned keywords.
// Returns integer 1â€“5. This replaces the direct scorepaper() call during fetch.
function scoreWithSignals(paper) {
  const base          = scorepaper(paper);                       // 1â€“5 keyword score
  const learnedBoost  = scoreLearnedKeywords(paper);             // 0â€“2 boost
  const signalBoost   = computeSignalScore(paper.paperId);       // raw signal value

  // Signals contribute up to Â±2 to the score (clamped and scaled)
  const signalContrib = Math.max(-2, Math.min(2, signalBoost * 0.3));

  const raw = base + (learnedBoost * 0.5) + signalContrib;
  return Math.max(1, Math.min(5, Math.round(raw)));
}

// Re-score allPapers[] with the current signals + learned keywords, then re-render.
function rescoreAll() {
  if (allPapers.length === 0) return;
  allPapers = allPapers.map(p => ({ ...p, score: scoreWithSignals(p) }));
  papers    = applyFiltersAndSort(allPapers);
  renderPapers();
}


// â”€â”€ Score explanation (for tooltip) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Returns up to 3 human-readable reasons for a paper's score.
function buildScoreExplanation(paper) {
  const reasons = [];
  const base    = scorepaper(paper);
  const learned = scoreLearnedKeywords(paper);
  const s       = userSignals[paper.paperId];

  if (base >= 4)      reasons.push(`Strong keyword match (base ${base}/5)`);
  else if (base >= 2) reasons.push(`Partial keyword match (base ${base}/5)`);
  else                reasons.push('Outside your main keywords');

  if (s?.liked)                        reasons.push('You liked this paper');
  if (s?.saved)                        reasons.push('You saved this paper');
  if (s?.clicked)                      reasons.push('You previously opened this paper');
  if ((s?.secondsVisible || 0) >= 30)  reasons.push('You spent time reading this');
  if (learned > 0.2)                   reasons.push('Matches topics from papers you liked');
  if (paper.isWildcard)                reasons.push('ğŸ” Explore: highly cited, outside your usual keywords');

  return reasons.slice(0, 3);
}


// â”€â”€ Wildcard paper selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Pick a "wildcard" paper for diversity â€” low keyword match but notably cited.
// Returns a paper object with isWildcard=true, or null if none available.
function pickWildcard(allPapersArr, alreadyShown) {
  const shownIds = new Set(alreadyShown.map(p => p.paperId));
  // Candidates: not already shown, low keyword score, but cited (interesting discovery)
  const candidates = allPapersArr
    .filter(p => !shownIds.has(p.paperId) && p.score <= 2 && (p.influentialCitationCount || 0) >= 3)
    .sort((a, b) => (b.influentialCitationCount || 0) - (a.influentialCitationCount || 0));
  if (!candidates.length) return null;
  return { ...candidates[0], isWildcard: true };
}


// â”€â”€ Auth state observer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

auth.onAuthStateChanged(async (user) => {
  currentUser = user;

  if (user) {
    await loadKeywordsFromFirestore();
    await loadUserActions();
    await loadUserSignals();
    await loadLearnedKeywords();
  } else {
    keywords        = DEFAULT_KEYWORDS.map(k => ({ ...k }));
    userActions     = {};
    userSignals     = {};
    learnedKeywords = [];
  }

  renderAuthUI();
  renderKeywordChips();
  renderActiveKeywordsBar();
  renderFilterPanel(); // keyword filter group depends on active keywords
  renderResearchProfile();

  // Re-score papers already on screen with updated signals + learned keywords
  if (allPapers.length > 0) {
    allPapers = allPapers.map(p => ({ ...p, score: scoreWithSignals(p) }));
    papers    = applyFiltersAndSort(allPapers);
    pageIndex = 0;
    renderPapers();
  }
});


// â”€â”€ localStorage helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function loadKeywords() {
  keywords = DEFAULT_KEYWORDS.map(k => ({ ...k }));
}

function saveKeywords() {
  if (currentUser) {
    saveKeywordsToFirestore();
  }
}

function loadTheme() {
  const saved = localStorage.getItem(THEME_KEY) || 'light';
  applyTheme(saved);
}

function applyTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  document.getElementById('themeBtn').textContent = theme === 'dark' ? 'â˜€' : 'ğŸŒ™';
  localStorage.setItem(THEME_KEY, theme);
}


// â”€â”€ Unread tracking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// We store the IDs of papers seen in the last session in localStorage.
// Papers in the current fetch that aren't in seenPaperIds are "new".

function loadSeenPapers() {
  try {
    const raw = localStorage.getItem(SEEN_PAPERS_KEY);
    if (raw) seenPaperIds = new Set(JSON.parse(raw));
  } catch (e) {
    seenPaperIds = new Set();
  }
}

// Save the current allPapers IDs as "seen" (capped at 500).
function updateSeenPapers() {
  const currentIds = allPapers.map(p => p.paperId).filter(Boolean);
  // Merge with previous (keep old seen IDs, add new ones)
  const merged = [...seenPaperIds, ...currentIds];
  const capped  = merged.slice(-500);
  try {
    localStorage.setItem(SEEN_PAPERS_KEY, JSON.stringify(capped));
  } catch (e) { /* quota exceeded â€” skip silently */ }
  // Update the in-memory set to include just-seen papers
  // so they won't be "unread" next session
  // (we set it AFTER renderPapers so the badge shows this session's new papers)
}


// â”€â”€ Smart refresh â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function smartRefresh() {
  fetchPapers();
}

function friendlyTime(date) {
  const diff = Math.floor((Date.now() - date.getTime()) / 1000);
  if (diff < 60)    return 'just now';
  if (diff < 3600)  return `${Math.floor(diff / 60)} min ago`;
  if (diff < 86400) return `${Math.floor(diff / 3600)} hr ago`;
  return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
}


// â”€â”€ Health check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function runHealthCheck() {
  const firstKeyword = activeKeywords()[0];
  if (!firstKeyword) return;

  let ok = false, msg = '';
  try {
    const params = new URLSearchParams({ query: firstKeyword, fields: 'title,year', limit: 1 });
    const res  = await fetch(`${API_BASE}?${params}`);
    const data = await res.json();
    if (res.status === 429 || (data.message && !data.data)) {
      msg = 'API rate-limited';
    } else if (!res.ok) {
      msg = `API error (HTTP ${res.status})`;
    } else if (!data.data || data.data.length === 0) {
      msg = 'API returned no papers';
    } else if (!data.data[0].title) {
      msg = 'API returned malformed data';
    } else {
      ok = true; msg = 'All systems good';
    }
  } catch (e) {
    msg = e.message === 'Failed to fetch' ? 'Cannot reach API' : e.message;
  }
  const result = { ok, msg, ts: new Date().toISOString() };
  localStorage.setItem(HEALTH_KEY, JSON.stringify(result));
  renderHealthBar(result);
}

function renderHealthBar(result) {
  if (!result) {
    try {
      const saved = localStorage.getItem(HEALTH_KEY);
      if (!saved) return;
      result = JSON.parse(saved);
    } catch (e) { return; }
  }
  const el = document.getElementById('healthBar');
  if (!el) return;
  const time = friendlyTime(new Date(result.ts));
  el.style.display = 'inline-block';
  el.className = 'health-bar ' + (result.ok ? 'ok' : 'error');
  el.textContent = result.ok
    ? `âœ… ${result.msg} â€” last checked ${time}`
    : `âŒ ${result.msg} â€” last checked ${time}`;
}


// â”€â”€ Event binding â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function bindEvents() {
  document.getElementById('settingsToggle').addEventListener('click', () => {
    document.getElementById('settingsPanel').classList.toggle('open');
    renderKeywordChips();
  });
  document.getElementById('refreshBtn').addEventListener('click', fetchPapers);
  document.getElementById('themeBtn').addEventListener('click', () => {
    const current = document.documentElement.getAttribute('data-theme');
    applyTheme(current === 'dark' ? 'light' : 'dark');
  });
  document.getElementById('addKeywordBtn').addEventListener('click', addKeyword);
  document.getElementById('newKeywordInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') addKeyword();
  });

  // Search
  document.getElementById('searchInput').addEventListener('input', handleSearchInput);
  document.getElementById('searchClearBtn').addEventListener('click', clearSearch);

  // Filter panel toggle
  document.getElementById('filterToggleBtn').addEventListener('click', () => {
    const body = document.getElementById('filterPanelBody');
    body.style.display = body.style.display === 'none' ? 'flex' : 'none';
  });

  // Clear all filters
  document.getElementById('clearAllFiltersBtn').addEventListener('click', clearAllFilters);

  // Sort select
  document.getElementById('sortSelect').addEventListener('change', (e) => {
    sortOrder = e.target.value;
    applyAndRender();
  });

  // Show hidden toggle
  document.getElementById('showHiddenToggle').addEventListener('change', (e) => {
    showHidden = e.target.checked;
    applyAndRender();
  });
}


// â”€â”€ Keyword management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function addKeyword() {
  const input = document.getElementById('newKeywordInput');
  const text  = input.value.trim().toLowerCase();
  if (!text) return;
  if (keywords.some(k => k.text === text)) { input.value = ''; return; }
  keywords.push({ text, active: true });
  saveKeywords();
  input.value = '';
  renderKeywordChips();
  renderActiveKeywordsBar();
  renderKeywordFilterGroup(); // update filter panel
  fetchPapers();
}

function removeKeyword(index) {
  keywords.splice(index, 1);
  saveKeywords();
  renderKeywordChips();
  renderActiveKeywordsBar();
  renderKeywordFilterGroup();
  fetchPapers();
}

function toggleKeyword(index) {
  keywords[index].active = !keywords[index].active;
  saveKeywords();
  renderKeywordChips();
  renderActiveKeywordsBar();
  renderKeywordFilterGroup();
  fetchPapers();
}

function activeKeywords() {
  return keywords.filter(k => k.active).map(k => k.text);
}


// â”€â”€ Relevance scoring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function scorepaper(paper) {
  const active = activeKeywords();
  if (active.length === 0) return 1;

  const title    = (paper.title    || '').toLowerCase();
  const abstract = (paper.abstract || '').toLowerCase();

  let depthScore = 0;  // sum of per-keyword depth points (max 3 per kw: 2 title + 1 abstract)
  let matchedKws = 0;  // how many keywords appeared at all in this paper

  for (const kw of active) {
    const kwLower    = kw.toLowerCase();
    const inTitle    = title.includes(kwLower);
    const inAbstract = abstract.includes(kwLower);
    if (inTitle || inAbstract) {
      matchedKws++;
      if (inTitle)    depthScore += 2; // title match worth more
      if (inAbstract) depthScore += 1;
    }
  }

  // No keyword found in this paper at all â†’ not relevant
  if (matchedKws === 0) return 1;

  // Breadth: what fraction of ALL active keywords matched this paper?
  // e.g. 1 of 4 keywords â†’ 0.25; 4 of 4 â†’ 1.0
  const breadth = matchedKws / active.length;

  // Depth: how deeply did the matched keywords hit (title vs abstract)?
  // Always in [0.33, 1.0] when matchedKws > 0.
  const depth = depthScore / (matchedKws * 3);

  // Combined score weighted 70% breadth (coverage) + 30% depth (title/abstract hit).
  // This ensures a paper matching only 1 of 4 keywords cannot score 5/5,
  // even if that one keyword appears in both title and abstract.
  const combined = (breadth * 0.7) + (depth * 0.3);

  if (combined >= 0.75) return 5; // strong multi-keyword match
  if (combined >= 0.50) return 4; // good coverage
  if (combined >= 0.30) return 3; // partial match
  if (combined >= 0.10) return 2; // weak match
  return 1;                       // effectively no match
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FILTER & SORT PIPELINE
//  All pure functions â€” no DOM side effects.
//  Input: allPapers[]  â†’  Output: filtered+sorted papers[]
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Master entry point: recompute papers[] from allPapers[], reset page, re-render.
function applyAndRender() {
  papers    = applyFiltersAndSort(allPapers);
  pageIndex = 0;
  renderPapers();
}

// Chains all 6 filter steps then sort. Returns a new array (never mutates input).
function applyFiltersAndSort(arr) {
  let result = arr.slice(); // shallow copy â€” safe because we never mutate paper objects
  result = applySearchFilter(result, searchQuery);
  result = applyScoreFilter(result, filterState.scores);
  result = applyDateFilter(result, filterState.dateRange);
  result = applyStatusFilter(result, filterState.status, userActions);
  result = applyKeywordFilter(result, filterState.keywords);
  result = applyCitationFilter(result, filterState.citations);
  result = applyInflCitationFilter(result, filterState.inflCitations);
  result = applyVelocityFilter(result, filterState.velocity);
  result = applyOpenAccessFilter(result, filterState.openAccess);
  result = applyPubTypeFilter(result, filterState.pubType);
  result = applyFieldsFilter(result, filterState.fields);
  // Unless "show hidden" is on, remove hidden papers from the default view
  if (!showHidden) {
    result = result.filter(p => !userActions[p.paperId]?.hidden);
  }
  result = applySortOrder(result, sortOrder);
  return result;
}

// Full-text search across title, abstract, authors (case-insensitive substring).
function applySearchFilter(arr, q) {
  if (!q || !q.trim()) return arr;
  const term = q.trim().toLowerCase();
  return arr.filter(p => {
    const title    = (p.title    || '').toLowerCase();
    const abstract = (p.abstract || '').toLowerCase();
    const authors  = (p.authors  || []).map(a => (a.name || '').toLowerCase()).join(' ');
    return title.includes(term) || abstract.includes(term) || authors.includes(term);
  });
}

// Keep only papers whose score is in the allowed scores array.
function applyScoreFilter(arr, scores) {
  if (!scores || scores.length === 5) return arr; // all selected = no filter
  return arr.filter(p => scores.includes(p.score));
}

// Filter by publication date using paper.publicationDate (YYYY-MM-DD).
// Falls back to paper.year if publicationDate is absent.
function applyDateFilter(arr, range) {
  if (range === 'all') return arr;

  const now = Date.now();
  const cutoffMs = {
    '7d':  7  * 24 * 60 * 60 * 1000,
    '30d': 30 * 24 * 60 * 60 * 1000,
    '90d': 90 * 24 * 60 * 60 * 1000,
    '1y':  365 * 24 * 60 * 60 * 1000,
  }[range];

  if (!cutoffMs) return arr;
  const cutoff = now - cutoffMs;

  return arr.filter(p => {
    // Prefer full date, fall back to year-only
    const dateStr = p.publicationDate || (p.year ? `${p.year}-01-01` : null);
    if (!dateStr) return false;
    const ts = new Date(dateStr).getTime();
    return !isNaN(ts) && ts >= cutoff;
  });
}

// Filter by status: all / unread / liked / saved / hidden
function applyStatusFilter(arr, status, actions) {
  if (status === 'all') return arr;
  return arr.filter(p => {
    const a = actions[p.paperId] || {};
    if (status === 'liked')  return !!a.liked;
    if (status === 'saved')  return !!a.saved;
    if (status === 'hidden') return !!a.hidden;
    if (status === 'unread') return !seenPaperIds.has(p.paperId);
    return true;
  });
}

// Keep papers that match at least one of the selected keyword filters.
// Empty array = no keyword filter (show all).
function applyKeywordFilter(arr, kws) {
  if (!kws || kws.length === 0) return arr;
  const kwsLower = kws.map(k => k.toLowerCase());
  return arr.filter(p => {
    const text = ((p.title || '') + ' ' + (p.abstract || '')).toLowerCase();
    return kwsLower.some(kw => text.includes(kw));
  });
}

// Keep papers where citationCount >= min (undefined/null treated as 0).
function applyCitationFilter(arr, min) {
  if (!min || min === 0) return arr;
  return arr.filter(p => (p.citationCount || 0) >= min);
}

// â”€â”€ Citation velocity helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Returns citations per year since publication. Papers published this year
// get a minimum age of 1 to avoid division-by-zero / inflation.
function citationVelocity(paper) {
  const count   = paper.citationCount || 0;
  const pubYear = paper.publicationDate
    ? new Date(paper.publicationDate).getFullYear()
    : (paper.year || null);
  if (!pubYear) return 0;
  const yearsOld = Math.max(1, new Date().getFullYear() - pubYear + 1);
  return count / yearsOld;
}

// Returns 'trending' (â‰¥20/yr) | 'growing' (5-20/yr) | 'stable' (<5/yr)
function velocityLabel(paper) {
  const v = citationVelocity(paper);
  if (v >= 20) return 'trending';
  if (v >= 5)  return 'growing';
  return 'stable';
}

// â”€â”€ New filter functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Keep papers where influentialCitationCount >= min.
function applyInflCitationFilter(arr, min) {
  if (!min || min === 0) return arr;
  return arr.filter(p => (p.influentialCitationCount || 0) >= min);
}

// Keep papers whose citation velocity matches the given label.
// 'any' returns all papers unchanged.
function applyVelocityFilter(arr, v) {
  if (!v || v === 'any') return arr;
  return arr.filter(p => velocityLabel(p) === v);
}

// Keep open-access papers only (when oa === true).
function applyOpenAccessFilter(arr, oa) {
  if (!oa) return arr;
  return arr.filter(p => !!p.isOpenAccess);
}

// Keep papers matching the publication type.
// Uses publicationVenue.type from Semantic Scholar; falls back to ArXiv
// external ID for preprints that have no venue set.
function applyPubTypeFilter(arr, type) {
  if (!type || type === 'all') return arr;
  return arr.filter(p => {
    const venueType = (p.publicationVenue?.type || '').toLowerCase();
    if (type === 'journal')    return venueType.includes('journal');
    if (type === 'conference') return venueType.includes('conference') || venueType.includes('workshop');
    if (type === 'preprint')   return venueType.includes('preprint') || venueType.includes('arxiv') ||
                                      (p.externalIds?.ArXiv && !venueType);
    return true;
  });
}

// Keep papers that have at least one fieldsOfStudy value matching the
// selected fields array. [] = no filter (return all).
function applyFieldsFilter(arr, fields) {
  if (!fields || fields.length === 0) return arr;
  const fLower = fields.map(f => f.toLowerCase());
  return arr.filter(p =>
    (p.fieldsOfStudy || []).some(f => fLower.includes(f.toLowerCase()))
  );
}

// Sort a copy of the array by the given order. Does NOT mutate input.
function applySortOrder(arr, order) {
  const a = arr.slice();
  if (order === 'newest') {
    return a.sort((x, y) => {
      const dx = x.publicationDate || (x.year ? `${x.year}-12-31` : '0000-01-01');
      const dy = y.publicationDate || (y.year ? `${y.year}-12-31` : '0000-01-01');
      return dy.localeCompare(dx);
    });
  }
  if (order === 'oldest') {
    return a.sort((x, y) => {
      const dx = x.publicationDate || (x.year ? `${x.year}-01-01` : '9999-12-31');
      const dy = y.publicationDate || (y.year ? `${y.year}-01-01` : '9999-12-31');
      return dx.localeCompare(dy);
    });
  }
  if (order === 'relevance') {
    return a.sort((x, y) => y.score - x.score);
  }
  if (order === 'cited') {
    return a.sort((x, y) => (y.citationCount || 0) - (x.citationCount || 0));
  }
  if (order === 'influential') {
    return a.sort((x, y) => (y.influentialCitationCount || 0) - (x.influentialCitationCount || 0));
  }
  if (order === 'trending') {
    return a.sort((x, y) => citationVelocity(y) - citationVelocity(x));
  }
  return a;
}

// Returns the active keyword phrases found in a paper's title+abstract.
function getMatchedKeywords(paper) {
  const active = activeKeywords();
  if (!active.length) return [];
  const text = ((paper.title || '') + ' ' + (paper.abstract || '')).toLowerCase();
  return active.filter(kw => text.includes(kw.toLowerCase()));
}

// Wrap each occurrence of query in the pre-escaped text with <mark>.
// IMPORTANT: text must already be HTML-escaped before calling this function.
// We never inject user input as HTML â€” only hard-coded <mark> tags are inserted.
function highlightSearchTerms(text, q) {
  if (!q || !q.trim()) return text;
  // Escape regex special characters so they're treated as literals
  const escaped = q.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex   = new RegExp(escaped, 'gi');
  return text.replace(regex, match => `<mark class="search-highlight">${match}</mark>`);
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  API FETCH
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function fetchOneKeyword(keyword) {
  const params = new URLSearchParams({
    query:  keyword,
    fields: API_FIELDS,
    limit:  10,
  });
  const res  = await fetch(`${API_BASE}?${params}`);
  const data = await res.json();
  if (res.status === 429 || (data.message && !data.data)) {
    throw new Error('Rate limited by Semantic Scholar. Wait 30 seconds and click Refresh.');
  }
  if (!res.ok) {
    throw new Error(`Semantic Scholar API error (${res.status}). Try again shortly.`);
  }
  return data.data || [];
}

function wait(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function fetchPapers() {
  if (loading) return;

  const active = activeKeywords();
  if (active.length === 0) {
    setStatus('No active keywords. Enable at least one keyword in settings.', true);
    return;
  }

  loading = true;
  setStatus(`Fetching papers for ${active.length} keyword${active.length > 1 ? 's' : ''}â€¦`);
  showSkeletons();
  setRefreshSpinning(true);

  try {
    const seen    = new Set();
    const results = [];

    for (let i = 0; i < active.length; i++) {
      if (i > 0) await wait(500);
      setStatus(`Fetching papersâ€¦ (${i + 1}/${active.length})`);
      try {
        const batch = await fetchOneKeyword(active[i]);
        for (const paper of batch) {
          if (paper.title && paper.paperId && !seen.has(paper.paperId)) {
            seen.add(paper.paperId);
            results.push(paper);
          }
        }
      } catch (kwErr) {
        console.warn(`Skipping keyword "${active[i]}": ${kwErr.message}`);
      }
    }

    // Score all results using keyword match + signal history + learned keywords
    allPapers = results.map(p => ({ ...p, score: scoreWithSignals(p) }));

    // Apply filters and sort to derive the view
    papers    = applyFiltersAndSort(allPapers);
    pageIndex = 0;

    if (allPapers.length === 0) {
      setStatus('No papers found. The API may be rate-limited â€” wait 30 seconds and click Refresh.', true);
    } else {
      const now = new Date();
      localStorage.setItem(LAST_FETCH_KEY, now.toISOString());
      setStatus(''); // clear status; feed header shows count
      runHealthCheck();
    }

    // Track unread BEFORE updating seen (so new papers show as unread this session)
    renderPapers();

    // After rendering, mark current papers as seen for next session
    updateSeenPapers();
    // Update the in-memory seenPaperIds so they don't show as unread in this session
    allPapers.forEach(p => { if (p.paperId) seenPaperIds.add(p.paperId); });

    // Load user actions if signed in
    if (currentUser) {
      await loadUserActions(); // will call renderPapers() again with actions
    }

  } catch (err) {
    console.error('Fetch error:', err);
    const msg = err.message === 'Failed to fetch'
      ? 'Could not reach local server. Make sure server.py is running.'
      : err.message;
    setStatus(msg, true);
    document.getElementById('paperFeed').innerHTML = '';
  } finally {
    loading = false;
    setRefreshSpinning(false);
  }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SEARCH BAR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function handleSearchInput(e) {
  const val = e.target.value;
  const clearBtn = document.getElementById('searchClearBtn');
  clearBtn.style.display = val ? 'block' : 'none';

  // Debounce: wait 300ms after typing stops before filtering
  clearTimeout(searchTimer);
  searchTimer = setTimeout(() => {
    searchQuery = val;
    applyAndRender();
  }, 300);
}

function clearSearch() {
  searchQuery = '';
  const input = document.getElementById('searchInput');
  if (input) input.value = '';
  document.getElementById('searchClearBtn').style.display = 'none';
  applyAndRender();
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FILTER PANEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Renders ALL filter groups from scratch.
// Called on init and whenever keyword list changes.
function renderFilterPanel() {
  renderScoreFilterGroup();
  renderDateFilterGroup();
  renderStatusFilterGroup();
  renderKeywordFilterGroup();
  renderCitationFilterGroup();
  renderInflCitationFilterGroup();
  renderVelocityFilterGroup();
  renderOpenAccessFilterGroup();
  renderPubTypeFilterGroup();
  renderFieldsFilterGroup();
  renderActiveFilterTags();
}

function renderScoreFilterGroup() {
  const el = document.getElementById('scoreFilterGroup');
  if (!el) return;
  el.innerHTML = [1, 2, 3, 4, 5].map(s => `
    <label class="filter-option-label">
      <input type="checkbox" value="${s}"
             ${filterState.scores.includes(s) ? 'checked' : ''}
             data-filter="score">
      â˜…${s}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="score"]').forEach(inp => {
    inp.addEventListener('change', () => {
      const checked = [...el.querySelectorAll('input[data-filter="score"]')]
        .filter(i => i.checked).map(i => Number(i.value));
      filterState.scores = checked.length ? checked : [1, 2, 3, 4, 5];
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderDateFilterGroup() {
  const el = document.getElementById('dateFilterGroup');
  if (!el) return;
  const options = [
    { val: 'all',  label: 'All time' },
    { val: '7d',   label: 'Last 7 days' },
    { val: '30d',  label: 'Last 30 days' },
    { val: '90d',  label: 'Last 3 months' },
    { val: '1y',   label: 'Last year' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="dateFilter" value="${o.val}"
             ${filterState.dateRange === o.val ? 'checked' : ''}
             data-filter="date">
      ${o.label}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="date"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.dateRange = inp.value;
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderStatusFilterGroup() {
  const el = document.getElementById('statusFilterGroup');
  if (!el) return;
  const options = [
    { val: 'all',    label: 'All' },
    { val: 'unread', label: 'Unread' },
    { val: 'liked',  label: 'â¤ Liked' },
    { val: 'saved',  label: 'ğŸ”– Saved' },
    { val: 'hidden', label: 'ğŸ™ˆ Hidden' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="statusFilter" value="${o.val}"
             ${filterState.status === o.val ? 'checked' : ''}
             data-filter="status">
      ${o.label}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="status"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.status = inp.value;
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

// Re-renders only the keyword filter group (called when keywords change).
function renderKeywordFilterGroup() {
  const el = document.getElementById('keywordFilterGroup');
  if (!el) return;
  const active = activeKeywords();
  if (active.length === 0) {
    el.innerHTML = '<span style="font-size:0.75rem; color:var(--text-muted)">No active keywords</span>';
    return;
  }
  el.innerHTML = active.map(kw => `
    <label class="filter-option-label">
      <input type="checkbox" value="${esc(kw)}"
             ${filterState.keywords.includes(kw) ? 'checked' : ''}
             data-filter="keyword">
      ${esc(kw)}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="keyword"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.keywords = [...el.querySelectorAll('input[data-filter="keyword"]')]
        .filter(i => i.checked).map(i => i.value);
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderCitationFilterGroup() {
  const el = document.getElementById('citationFilterGroup');
  if (!el) return;
  const options = [
    { val: 0,   label: 'Any' },
    { val: 10,  label: 'â‰¥10' },
    { val: 50,  label: 'â‰¥50' },
    { val: 100, label: 'â‰¥100' },
    { val: 500, label: 'â‰¥500' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="citationFilter" value="${o.val}"
             ${filterState.citations === o.val ? 'checked' : ''}
             data-filter="citation">
      ${o.label}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="citation"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.citations = Number(inp.value);
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderInflCitationFilterGroup() {
  const el = document.getElementById('inflCitationFilterGroup');
  if (!el) return;
  const options = [
    { val: 0,  label: 'Any' },
    { val: 5,  label: 'â‰¥5' },
    { val: 10, label: 'â‰¥10' },
    { val: 25, label: 'â‰¥25' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="inflCitationFilter" value="${o.val}"
             ${filterState.inflCitations === o.val ? 'checked' : ''}
             data-filter="inflCitation">
      ${o.label}
    </label>
  `).join('');
  el.querySelectorAll('input[data-filter="inflCitation"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.inflCitations = Number(inp.value);
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderVelocityFilterGroup() {
  const el = document.getElementById('velocityFilterGroup');
  if (!el) return;
  const options = [
    { val: 'any',      label: 'Any' },
    { val: 'trending', label: 'ğŸ”¥ Trending (â‰¥20/yr)' },
    { val: 'growing',  label: 'â†— Growing (5â€“20/yr)' },
    { val: 'stable',   label: 'â†’ Stable (<5/yr)' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="velocityFilter" value="${o.val}"
             ${filterState.velocity === o.val ? 'checked' : ''}
             data-filter="velocity">
      ${o.label}
    </label>
  `).join('');
  el.querySelectorAll('input[data-filter="velocity"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.velocity = inp.value;
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

function renderOpenAccessFilterGroup() {
  const el = document.getElementById('openAccessFilterGroup');
  if (!el) return;
  el.innerHTML = `
    <label class="filter-option-label">
      <input type="checkbox" data-filter="openAccess"
             ${filterState.openAccess ? 'checked' : ''}>
      ğŸ”“ Open Access only
    </label>`;
  el.querySelector('input[data-filter="openAccess"]').addEventListener('change', (e) => {
    filterState.openAccess = e.target.checked;
    renderActiveFilterTags();
    applyAndRender();
  });
}

function renderPubTypeFilterGroup() {
  const el = document.getElementById('pubTypeFilterGroup');
  if (!el) return;
  const options = [
    { val: 'all',        label: 'All' },
    { val: 'journal',    label: 'Journal' },
    { val: 'conference', label: 'Conference' },
    { val: 'preprint',   label: 'Preprint' },
  ];
  el.innerHTML = options.map(o => `
    <label class="filter-option-label">
      <input type="radio" name="pubTypeFilter" value="${o.val}"
             ${filterState.pubType === o.val ? 'checked' : ''}
             data-filter="pubType">
      ${o.label}
    </label>
  `).join('');
  el.querySelectorAll('input[data-filter="pubType"]').forEach(inp => {
    inp.addEventListener('change', () => {
      filterState.pubType = inp.value;
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

// Renders checkboxes for all unique fields of study present in allPapers.
function renderFieldsFilterGroup() {
  const el = document.getElementById('fieldsFilterGroup');
  if (!el) return;

  // Collect unique fields from current allPapers, sorted alphabetically (max 15)
  const fieldSet = new Set();
  allPapers.forEach(p => (p.fieldsOfStudy || []).forEach(f => fieldSet.add(f)));
  const allFields = [...fieldSet].sort().slice(0, 15);

  if (allFields.length === 0) {
    el.innerHTML = '<span style="color:var(--text-muted);font-size:0.78rem">No papers loaded yet</span>';
    return;
  }

  el.innerHTML = allFields.map(f => `
    <label class="filter-option-label">
      <input type="checkbox" data-filter="field" value="${esc(f)}"
             ${filterState.fields.includes(f) ? 'checked' : ''}>
      ${esc(f)}
    </label>
  `).join('');

  el.querySelectorAll('input[data-filter="field"]').forEach(inp => {
    inp.addEventListener('change', () => {
      if (inp.checked) {
        if (!filterState.fields.includes(inp.value)) {
          filterState.fields = [...filterState.fields, inp.value];
        }
      } else {
        filterState.fields = filterState.fields.filter(f => f !== inp.value);
      }
      renderActiveFilterTags();
      applyAndRender();
    });
  });
}

// Build the active filter tag data: each non-default filter gets a pill.
function buildActiveFilterTags() {
  const tags = [];

  if (searchQuery) {
    tags.push({ label: `Search: "${searchQuery}"`, clearFn: clearSearch });
  }
  if (filterState.scores.length < 5) {
    const label = 'Score: ' + filterState.scores.map(s => 'â˜…' + s).join(' ');
    tags.push({ label, clearFn: () => {
      filterState.scores = [1, 2, 3, 4, 5];
      renderFilterPanel(); applyAndRender();
    }});
  }
  if (filterState.dateRange !== 'all') {
    const labels = { '7d': 'Last 7 days', '30d': 'Last 30 days', '90d': 'Last 3 months', '1y': 'Last year' };
    tags.push({ label: labels[filterState.dateRange] || filterState.dateRange, clearFn: () => {
      filterState.dateRange = 'all'; renderFilterPanel(); applyAndRender();
    }});
  }
  if (filterState.status !== 'all') {
    tags.push({ label: `Status: ${filterState.status}`, clearFn: () => {
      filterState.status = 'all'; renderFilterPanel(); applyAndRender();
    }});
  }
  filterState.keywords.forEach(kw => {
    tags.push({ label: `Keyword: ${kw}`, clearFn: () => {
      filterState.keywords = filterState.keywords.filter(k => k !== kw);
      renderFilterPanel(); applyAndRender();
    }});
  });
  if (filterState.citations > 0) {
    tags.push({ label: `Citations â‰¥${filterState.citations}`, clearFn: () => {
      filterState.citations = 0; renderFilterPanel(); applyAndRender();
    }});
  }
  if (filterState.inflCitations > 0) {
    tags.push({ label: `Influential â‰¥${filterState.inflCitations}`, clearFn: () => {
      filterState.inflCitations = 0; renderFilterPanel(); applyAndRender();
    }});
  }
  if (filterState.velocity !== 'any') {
    const velLabels = { trending: 'ğŸ”¥ Trending', growing: 'â†— Growing', stable: 'â†’ Stable' };
    tags.push({ label: `Velocity: ${velLabels[filterState.velocity] || filterState.velocity}`, clearFn: () => {
      filterState.velocity = 'any'; renderFilterPanel(); applyAndRender();
    }});
  }
  if (filterState.openAccess) {
    tags.push({ label: 'ğŸ”“ Open Access only', clearFn: () => {
      filterState.openAccess = false; renderFilterPanel(); applyAndRender();
    }});
  }
  if (filterState.pubType !== 'all') {
    const typeLabels = { journal: 'Journal', conference: 'Conference', preprint: 'Preprint' };
    tags.push({ label: `Type: ${typeLabels[filterState.pubType] || filterState.pubType}`, clearFn: () => {
      filterState.pubType = 'all'; renderFilterPanel(); applyAndRender();
    }});
  }
  filterState.fields.forEach(f => {
    tags.push({ label: `Field: ${f}`, clearFn: () => {
      filterState.fields = filterState.fields.filter(x => x !== f);
      renderFilterPanel(); applyAndRender();
    }});
  });
  return tags;
}

// Render the pill tags row and update badge count.
function renderActiveFilterTags() {
  const container = document.getElementById('activeFilterTags');
  const badge     = document.getElementById('filterActiveCount');
  const clearBtn  = document.getElementById('clearAllFiltersBtn');
  if (!container) return;

  const tags = buildActiveFilterTags();

  if (tags.length === 0) {
    container.innerHTML = '';
    badge.style.display    = 'none';
    clearBtn.style.display = 'none';
    return;
  }

  badge.textContent  = tags.length;
  badge.style.display    = 'inline-block';
  clearBtn.style.display = 'inline-block';

  container.innerHTML = tags.map((t, i) => `
    <span class="filter-tag">
      ${esc(t.label)}
      <button class="filter-tag-remove" data-tag-idx="${i}" aria-label="Remove filter">Ã—</button>
    </span>
  `).join('');

  container.querySelectorAll('.filter-tag-remove').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      tags[parseInt(btn.dataset.tagIdx)].clearFn();
    });
  });
}

// Reset all filters and search to defaults.
function clearAllFilters() {
  filterState = {
    scores:        [1, 2, 3, 4, 5],
    dateRange:     'all',
    status:        'all',
    keywords:      [],
    citations:     0,
    inflCitations: 0,
    velocity:      'any',
    openAccess:    false,
    pubType:       'all',
    fields:        [],
  };
  searchQuery = '';
  sortOrder   = 'newest';
  pageIndex   = 0;
  const input = document.getElementById('searchInput');
  if (input) input.value = '';
  document.getElementById('searchClearBtn').style.display = 'none';
  document.getElementById('sortSelect').value = 'newest';
  renderFilterPanel();
  applyAndRender();
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  USER ACTIONS: Like / Save / Hide / Copy citation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Route an action button click to the correct handler.
function handlePaperAction(paperId, action) {
  if (!currentUser) return; // buttons are disabled when signed out

  const paper = allPapers.find(p => p.paperId === paperId);

  if (action === 'like') {
    const current = userActions[paperId]?.liked || false;
    const newVal  = !current;
    saveUserAction(paperId, 'liked', newVal);
    recordSignal(paperId, 'liked', newVal);
    if (newVal && paper) {
      // Positive signal: learn keywords from this paper
      addLearnedKeywords(paper);
      // Rescore immediately so score badge updates
      const updated = { ...paper, score: scoreWithSignals(paper) };
      allPapers = allPapers.map(p => p.paperId === paperId ? updated : p);
    }
    updateCardActionDisplay(paperId);
    if (filterState.status === 'liked') applyAndRender();
  } else if (action === 'save') {
    const current = userActions[paperId]?.saved || false;
    const newVal  = !current;
    saveUserAction(paperId, 'saved', newVal);
    recordSignal(paperId, 'saved', newVal);
    if (newVal && paper) {
      addLearnedKeywords(paper);
      const updated = { ...paper, score: scoreWithSignals(paper) };
      allPapers = allPapers.map(p => p.paperId === paperId ? updated : p);
    }
    updateCardActionDisplay(paperId);
    if (filterState.status === 'saved') applyAndRender();
  } else if (action === 'hide') {
    const current = userActions[paperId]?.hidden || false;
    const newVal  = !current;
    saveUserAction(paperId, 'hidden', newVal);
    if (newVal) recordSignal(paperId, 'removed', true); // strong negative signal
    if (newVal && !showHidden) {
      // Fade out then remove
      const card = document.querySelector(`[data-paperid="${paperId}"]`);
      if (card) {
        card.classList.add('paper-card--fading');
        setTimeout(() => applyAndRender(), 380);
      }
    } else {
      updateCardActionDisplay(paperId);
      if (filterState.status === 'hidden') applyAndRender();
    }
  } else if (action === 'copy') {
    copyCitation(paperId);
  }
}

// Update just the action buttons of one card without re-rendering the whole feed.
function updateCardActionDisplay(paperId) {
  const card = document.querySelector(`[data-paperid="${paperId}"]`);
  if (!card) return;
  const a = userActions[paperId] || {};
  const isSignedIn = !!currentUser;

  const likeBtn = card.querySelector('.like-btn');
  const saveBtn = card.querySelector('.save-btn');
  const hideBtn = card.querySelector('.hide-btn');

  if (likeBtn) {
    likeBtn.classList.toggle('active', !!a.liked);
    likeBtn.textContent = a.liked ? 'â¤ Liked' : 'â™¡ Like';
  }
  if (saveBtn) {
    saveBtn.classList.toggle('active', !!a.saved);
    saveBtn.textContent = a.saved ? 'ğŸ”– Saved' : 'ğŸ”– Save';
  }
  if (hideBtn) {
    hideBtn.classList.toggle('active', !!a.hidden);
    hideBtn.textContent = a.hidden ? 'ğŸ‘ Unhide' : 'ğŸ™ˆ Hide';
  }
}

// Format an APA-ish citation and copy to clipboard.
function copyCitation(paperId) {
  const paper = allPapers.find(p => p.paperId === paperId);
  if (!paper) return;

  const authors = (paper.authors || []).map(a => a.name).join(', ') || 'Unknown authors';
  const year    = paper.year || 'n.d.';
  const title   = paper.title || 'Untitled';
  const doi     = paper.externalIds?.DOI;
  const url     = doi ? `https://doi.org/${doi}` : paper.url || '';
  const citation = `${authors} (${year}). ${title}.${url ? ' ' + url : ''}`;

  navigator.clipboard.writeText(citation).then(() => {
    const btn = document.querySelector(`[data-paperid="${paperId}"] .copy-btn`);
    if (btn) {
      const orig = btn.textContent;
      btn.textContent = 'âœ“ Copied!';
      setTimeout(() => { btn.textContent = orig; }, 2000);
    }
  }).catch(err => {
    console.error('Clipboard error:', err);
  });
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Update the feed header: paper count, unread badge, last refresh time.
function renderFeedHeader() {
  const countEl    = document.getElementById('feedCount');
  const badgeEl    = document.getElementById('unreadBadge');
  const refreshEl  = document.getElementById('feedLastRefreshed');

  if (countEl) {
    countEl.textContent = papers.length === 0
      ? 'No papers'
      : `${papers.length} paper${papers.length !== 1 ? 's' : ''}`;
  }

  // Unread = papers in current allPapers that weren't in last session's seenPaperIds
  const unreadCount = allPapers.filter(p => p.paperId && !seenPaperIds.has(p.paperId)).length;
  // (seenPaperIds is updated AFTER render, so new papers show as unread in this session)
  if (badgeEl) {
    if (unreadCount > 0) {
      badgeEl.textContent  = `${unreadCount} new`;
      badgeEl.style.display = 'inline-block';
    } else {
      badgeEl.style.display = 'none';
    }
  }

  if (refreshEl) {
    try {
      const ts = localStorage.getItem(LAST_FETCH_KEY);
      refreshEl.textContent = ts ? `Updated ${friendlyTime(new Date(ts))}` : '';
    } catch (e) { refreshEl.textContent = ''; }
  }
}

// Build the HTML string for one paper card.
function buildPaperCardHtml(paper) {
  const paperId  = paper.paperId || '';
  const paperUrl = paper.url ||
    (paper.externalIds?.DOI
      ? `https://doi.org/${paper.externalIds.DOI}`
      : `https://www.semanticscholar.org/paper/${paperId}`);

  // â”€â”€ Authors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const authorsList   = paper.authors || [];
  const firstAuthor   = authorsList[0]?.name || 'Unknown author';
  const firstAuthorId = authorsList[0]?.authorId || '';
  const authorCount   = authorsList.length;
  const authorProfileUrl = firstAuthorId
    ? `https://www.semanticscholar.org/author/${firstAuthorId}`
    : `https://www.semanticscholar.org/search?q=${encodeURIComponent(firstAuthor)}&sort=Relevance`;

  // â”€â”€ Year + "N yrs ago" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const pubYear = paper.publicationDate
    ? new Date(paper.publicationDate).getFullYear()
    : (paper.year || null);
  const yearDisplay = paper.publicationDate
    ? paper.publicationDate.slice(0, 7)  // "YYYY-MM"
    : (paper.year ? String(paper.year) : 'Year unknown');
  const currentYear = new Date().getFullYear();
  const yearsAgoStr = pubYear && pubYear < currentYear
    ? ` Â· ${currentYear - pubYear} yr${currentYear - pubYear === 1 ? '' : 's'} ago`
    : '';

  // â”€â”€ Open access + PDF â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const isOA   = !!paper.isOpenAccess;
  const pdfUrl = paper.openAccessPdf?.url || null;
  const oaBadge = isOA
    ? `<span class="oa-badge" title="Open Access â€” free to read">ğŸ”“</span>`
    : `<span class="oa-badge locked" title="Paywalled">ğŸ”’</span>`;
  const pdfLink = pdfUrl
    ? `<a class="pdf-link" href="${esc(pdfUrl)}" target="_blank" rel="noopener">PDF â†—</a>`
    : '';

  // â”€â”€ Score badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const scoreClass       = paper.score >= 4 ? 'high' : paper.score >= 2 ? 'mid' : '';
  const scoreExplanation = buildScoreExplanation(paper).join('\n');
  const wildcardBadge    = paper.isWildcard
    ? `<span class="wildcard-badge" title="Explore: outside your usual keywords but highly cited">ğŸ” Explore</span>`
    : '';

  // â”€â”€ Citation metrics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const citeCount  = typeof paper.citationCount          === 'number' ? paper.citationCount          : null;
  const inflCount  = typeof paper.influentialCitationCount === 'number' ? paper.influentialCitationCount : null;
  const refCount   = typeof paper.referenceCount         === 'number' ? paper.referenceCount         : null;

  // Colour tier for total citations
  const citeBadgeClass = citeCount === null ? ''
    : citeCount < 10  ? 'cite-grey'
    : citeCount < 50  ? 'cite-blue'
    : citeCount < 200 ? 'cite-green'
    : 'cite-gold';

  // Citation velocity â€” compute actual rate for the tooltip
  const vel      = velocityLabel(paper);
  const velClass = `velocity-${vel}`;
  const velIcon  = vel === 'trending' ? 'ğŸ”¥' : vel === 'growing' ? 'â†—' : 'â†’';
  const velText  = vel === 'trending' ? 'Trending' : vel === 'growing' ? 'Growing' : 'Stable';
  const velRate  = citationVelocity(paper);
  const velRateStr = velRate >= 10 ? Math.round(velRate) : velRate.toFixed(1);
  const velTooltip = vel === 'trending'
    ? `ğŸ”¥ Trending â€” ${velRateStr} citations/year. This paper is gaining citations rapidly.`
    : vel === 'growing'
    ? `â†— Growing â€” ${velRateStr} citations/year. Steadily building impact.`
    : `â†’ Stable â€” ${velRateStr} citations/year. Cited occasionally but not accelerating.`;

  // Highly influential badge (inflCitations â‰¥ 10)
  const highlyInflBadge = (inflCount !== null && inflCount >= 10)
    ? `<span class="metric highly-influential-badge" title="This paper has â‰¥10 influential citations">ğŸ† Highly Influential</span>`
    : '';

  // â”€â”€ Venue â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const venueName = paper.publicationVenue?.name || '';
  const venueHtml = venueName
    ? `<span class="metric venue-name" title="${esc(venueName)}">${esc(venueName.length > 45 ? venueName.slice(0, 42) + 'â€¦' : venueName)}</span>`
    : '';

  // â”€â”€ Fields of study (max 3 tags) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const fields    = (paper.fieldsOfStudy || []).slice(0, 3);
  const fieldTagsHtml = fields.length
    ? `<div class="field-tags">${fields.map(f => `<span class="field-tag">${esc(f)}</span>`).join('')}</div>`
    : '';

  // â”€â”€ Metrics row â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Citation count â†’ SS "cited-by" page; ref count â†’ SS references page
  const ssBase      = `https://www.semanticscholar.org/paper/${esc(paperId)}`;
  const citedByUrl  = `${ssBase}#citing-papers`;
  const refsUrl     = `${ssBase}#references`;

  const metricsHtml = `
    <div class="paper-metrics">
      ${citeCount !== null
        ? `<a class="metric metric-link ${citeBadgeClass}" href="${citedByUrl}" target="_blank" rel="noopener"
              title="Cited by ${citeCount} paper${citeCount !== 1 ? 's' : ''} â€” click to see who cited this on Semantic Scholar">ğŸ“„ ${citeCount} cited</a>`
        : ''}
      ${inflCount !== null
        ? `<span class="metric" title="Influential citations â€” ${inflCount} paper${inflCount !== 1 ? 's' : ''} that substantially built on this work (Semantic Scholar calculates this separately from total citations)">â­ ${inflCount} infl.</span>`
        : ''}
      ${refCount  !== null
        ? `<a class="metric metric-link" href="${refsUrl}" target="_blank" rel="noopener"
              title="${refCount} reference${refCount !== 1 ? 's' : ''} â€” click to see what this paper cites on Semantic Scholar">â†™ ${refCount} refs</a>`
        : ''}
      <span class="metric ${velClass}" title="${esc(velTooltip)}">${velIcon} ${velText}</span>
      ${highlyInflBadge}
      ${venueHtml}
    </div>
    ${fieldTagsHtml}`;

  // â”€â”€ Abstract â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const rawAbstract  = paper.abstract || '';
  const abstractHtml = rawAbstract
    ? highlightSearchTerms(esc(rawAbstract), searchQuery)
    : '<em style="color:var(--text-muted)">No abstract available.</em>';

  // â”€â”€ Title â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const titleHtml = highlightSearchTerms(esc(paper.title || 'Untitled'), searchQuery);

  // â”€â”€ Matched keyword tags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const matched    = getMatchedKeywords(paper);
  const kwTagsHtml = matched.length
    ? `<div class="paper-keyword-tags">${matched.map(k => `<span class="matched-kw-tag">${esc(k)}</span>`).join('')}</div>`
    : '';

  // â”€â”€ Unread indicator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const isUnread = paperId && !seenPaperIds.has(paperId);

  // â”€â”€ Action buttons â€” disabled when signed out â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const a           = userActions[paperId] || {};
  const disabledCls = currentUser ? '' : ' disabled-action';
  const likedLbl    = a.liked  ? 'â¤ Liked'   : 'â™¡ Like';
  const savedLbl    = a.saved  ? 'ğŸ”– Saved'  : 'ğŸ”– Save';
  const hiddenLbl   = a.hidden ? 'ğŸ‘ Unhide' : 'ğŸ™ˆ Hide';

  return `
    <article class="paper-card${isUnread ? ' paper-card--unread' : ''}${paper.isWildcard ? ' paper-card--wildcard' : ''}" data-paperid="${esc(paperId)}">
      <div class="paper-card-top">
        <h2 class="paper-title">
          <a href="${esc(paperUrl)}" target="_blank" rel="noopener">
            ${titleHtml}
          </a>
        </h2>
        <div class="paper-card-badges">
          ${wildcardBadge}
          <span class="score-badge ${scoreClass}" title="â˜… ${paper.score}/5&#10;${esc(scoreExplanation)}">
            â˜… ${paper.score}/5
          </span>
        </div>
      </div>
      <div class="paper-meta">
        <a class="author-link" href="${esc(authorProfileUrl)}" target="_blank" rel="noopener"
           title="View author profile on Semantic Scholar">${esc(firstAuthor)}</a>${authorCount > 1
          ? ` <span class="author-count">+${authorCount - 1} author${authorCount > 2 ? 's' : ''}</span>` : ''}
        &nbsp;Â·&nbsp; ${esc(yearDisplay)}${esc(yearsAgoStr)}
        &nbsp; ${oaBadge} ${pdfLink}
      </div>
      <p class="paper-abstract" id="abstract-${esc(paperId)}">${abstractHtml}</p>
      ${rawAbstract.length > 300
        ? `<button class="expand-btn" data-paperid="${esc(paperId)}">Show more</button>`
        : ''}
      ${metricsHtml}
      ${kwTagsHtml}
      <div class="paper-actions">
        <button class="action-btn like-btn${a.liked ? ' active' : ''}${disabledCls}"
                data-paperid="${esc(paperId)}" data-action="like">${likedLbl}</button>
        <button class="action-btn save-btn${a.saved ? ' active' : ''}${disabledCls}"
                data-paperid="${esc(paperId)}" data-action="save">${savedLbl}</button>
        <button class="action-btn hide-btn${a.hidden ? ' active' : ''}${disabledCls}"
                data-paperid="${esc(paperId)}" data-action="hide">${hiddenLbl}</button>
        <button class="action-btn copy-btn"
                data-paperid="${esc(paperId)}" data-action="copy">ğŸ“‹ Cite</button>
      </div>
    </article>
  `;
}

// Render the current page slice of papers[] into #paperFeed.
function renderPapers() {
  renderFeedHeader();
  const feed = document.getElementById('paperFeed');

  if (papers.length === 0) {
    feed.innerHTML = renderEmptyState();
    return;
  }

  // Show a paginated slice: first (pageIndex+1)*PAGE_SIZE papers
  const rawSlice = papers.slice(0, (pageIndex + 1) * PAGE_SIZE);
  const hasMore  = papers.length > rawSlice.length;

  // Inject a wildcard paper every 10th slot (index 9, 19, 29...) for diversity
  const slice = rawSlice.slice(); // copy so we don't mutate papers[]
  for (let i = 9; i < slice.length; i += 10) {
    const wildcard = pickWildcard(allPapers, slice);
    if (wildcard) slice.splice(i, 0, wildcard); // insert before pushing index further
  }

  feed.innerHTML = slice.map(p => buildPaperCardHtml(p)).join('') +
    (hasMore ? `
      <div class="feed-load-more">
        <button id="loadMoreBtn">Load more (${papers.length - slice.length} remaining)</button>
      </div>
    ` : '');

  // Bind delegated events
  bindCardActions();

  // Wire up expand buttons â€” also record expand as a mild positive signal
  feed.querySelectorAll('.expand-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const pid   = btn.dataset.paperid;
      const absEl = document.getElementById(`abstract-${pid}`);
      if (!absEl) return;
      const expanded = absEl.classList.toggle('expanded');
      btn.textContent = expanded ? 'Show less' : 'Show more';
      if (expanded) recordSignal(pid, 'expanded', true); // mild +1 signal
    });
  });

  // Track title link clicks as a strong positive signal
  if (!feed._titleClickListener) {
    feed._titleClickListener = (e) => {
      const link = e.target.closest('.paper-title a');
      if (!link) return;
      const card = link.closest('[data-paperid]');
      if (card?.dataset.paperid) {
        recordSignal(card.dataset.paperid, 'clicked', true); // +2 signal
      }
    };
    feed.addEventListener('click', feed._titleClickListener);
  }

  // Time-on-screen tracking via IntersectionObserver
  startVisibilityTracking();

  // Load more button
  const loadMoreBtn = document.getElementById('loadMoreBtn');
  if (loadMoreBtn) {
    loadMoreBtn.addEventListener('click', loadMorePapers);
  }
}

// Returns an appropriate empty-state HTML string.
function renderEmptyState() {
  if (allPapers.length === 0) {
    return `<div class="empty-state">
      <div class="icon">ğŸ“„</div>
      No papers found for these keywords. Try adding broader terms or click Refresh.
    </div>`;
  }
  // Papers exist but filters removed all of them
  return `<div class="empty-state">
    <div class="icon">ğŸ”</div>
    No papers match the current filters.
    <br><button class="btn-text" onclick="clearAllFilters()" style="margin-top:8px">Clear filters</button>
  </div>`;
}

// Track how long each paper card is visible on screen.
// Uses IntersectionObserver. Cards must be 50% visible for â‰¥5 seconds to record.
let _visibilityObserver = null;
const _visibilityTimers = new Map(); // paperId â†’ { startMs, accumulatedMs }

function startVisibilityTracking() {
  // Disconnect old observer if any
  if (_visibilityObserver) _visibilityObserver.disconnect();

  _visibilityObserver = new IntersectionObserver((entries) => {
    for (const entry of entries) {
      const id = entry.target.dataset?.paperid;
      if (!id) continue;
      if (entry.isIntersecting) {
        // Card entered viewport â€” start timer
        const prev = _visibilityTimers.get(id) || { startMs: null, accumulatedMs: 0 };
        _visibilityTimers.set(id, { startMs: Date.now(), accumulatedMs: prev.accumulatedMs });
      } else {
        // Card left viewport â€” accumulate time
        const t = _visibilityTimers.get(id);
        if (t?.startMs) {
          const elapsed = Date.now() - t.startMs;
          const total   = t.accumulatedMs + elapsed;
          _visibilityTimers.set(id, { startMs: null, accumulatedMs: total });
          // Only record signals for meaningful dwell time (â‰¥5 seconds total)
          if (total >= 5000) {
            recordSignal(id, 'secondsVisible', Math.floor(total / 1000));
          }
        }
      }
    }
  }, { threshold: 0.5 }); // fire when â‰¥50% of card is visible

  document.querySelectorAll('.paper-card[data-paperid]').forEach(el => {
    _visibilityObserver.observe(el);
  });
}

// Single delegated listener for all action buttons in the feed.
function bindCardActions() {
  const feed = document.getElementById('paperFeed');
  // Remove any existing listener by replacing the node (simplest approach for a full re-render)
  // We use a named function stored on the element to avoid double-binding.
  if (feed._actionListener) {
    feed.removeEventListener('click', feed._actionListener);
  }
  feed._actionListener = (e) => {
    const btn = e.target.closest('[data-action]');
    if (!btn) return;
    const { paperid, action } = btn.dataset;
    if (paperid && action) handlePaperAction(paperid, action);
  };
  feed.addEventListener('click', feed._actionListener);
}

// Increment pageIndex and append the next slice (no scroll reset).
function loadMorePapers() {
  pageIndex++;
  renderPapers();
}


// â”€â”€ Rendering helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function esc(str) {
  return (str || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

function setStatus(msg, isError = false) {
  const el = document.getElementById('statusBar');
  el.textContent = msg;
  el.className   = 'status-bar' + (isError ? ' error' : '');
}

function setRefreshSpinning(on) {
  document.getElementById('refreshIcon').className = on ? 'btn-spinning' : '';
}

function showSkeletons() {
  const feed = document.getElementById('paperFeed');
  feed.innerHTML = Array.from({ length: 4 }, () => `
    <div class="skeleton-card">
      <div class="skeleton-line" style="width:70%; height:18px;"></div>
      <div class="skeleton-line" style="width:40%; height:12px;"></div>
      <div class="skeleton-line" style="width:100%; height:12px;"></div>
      <div class="skeleton-line" style="width:95%; height:12px;"></div>
      <div class="skeleton-line" style="width:80%; height:12px;"></div>
    </div>
  `).join('');
}


// â”€â”€ Render: keyword chips in settings panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€ Research Profile UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Renders the "Your Research Profile" section in the settings panel.
// Shows learned keywords, top topics, top authors, and a reset button.
function renderResearchProfile() {
  const container = document.getElementById('researchProfile');
  if (!container) return;

  if (!currentUser) {
    container.style.display = 'none';
    return;
  }

  container.style.display = 'block';

  // Build top 5 topics from signal data
  const topicFreq = {};
  for (const [, s] of Object.entries(userSignals)) {
    const hasPositiveSignal = s.liked || s.saved || s.expanded || s.clicked || (s.secondsVisible || 0) >= 10;
    if (!hasPositiveSignal) continue;
    const words = extractKeywords(s.title || '', s.abstract || '', 5);
    for (const w of words) topicFreq[w] = (topicFreq[w] || 0) + 1;
  }
  const topTopics = Object.entries(topicFreq)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([w]) => w);

  // Build top 5 authors from liked/clicked signals
  const authorFreq = {};
  for (const [, s] of Object.entries(userSignals)) {
    if (!(s.liked || s.clicked)) continue;
    const firstAuthor = s.authors?.[0]?.name;
    if (firstAuthor) authorFreq[firstAuthor] = (authorFreq[firstAuthor] || 0) + 1;
  }
  const topAuthors = Object.entries(authorFreq)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([name]) => name);

  // Render learned keywords as removable chips
  const learnedHtml = learnedKeywords.length
    ? learnedKeywords
        .sort((a, b) => b.weight - a.weight)
        .map(lk => `
          <span class="learned-kw-chip" title="Weight: ${lk.weight.toFixed(1)} â€” click Ã— to remove">
            ${esc(lk.text)}
            <button class="remove-learned-btn" data-kw="${esc(lk.text)}" aria-label="Remove ${esc(lk.text)}">Ã—</button>
          </span>`)
        .join('')
    : '<span class="profile-empty">Like or save papers to start learning.</span>';

  const topicsHtml = topTopics.length
    ? topTopics.map(t => `<span class="profile-topic-chip">${esc(t)}</span>`).join('')
    : '<span class="profile-empty">No engagement data yet.</span>';

  const authorsHtml = topAuthors.length
    ? topAuthors.map(a => `<span class="profile-topic-chip">${esc(a)}</span>`).join('')
    : '<span class="profile-empty">Like or click papers to track authors.</span>';

  container.innerHTML = `
    <div class="research-profile-inner">
      <h3 class="profile-heading">Your Research Profile</h3>
      <p class="profile-subtitle">Learned from your interactions â€” helps personalise your feed.</p>

      <div class="profile-section">
        <h4 class="profile-section-title">Keywords Learned for You</h4>
        <p class="profile-hint">From papers you liked or saved. Click Ã— to remove.</p>
        <div class="learned-kw-list" id="learnedKeywordList">${learnedHtml}</div>
      </div>

      <div class="profile-section">
        <h4 class="profile-section-title">Your Top Topics</h4>
        <div class="profile-chips">${topicsHtml}</div>
      </div>

      <div class="profile-section">
        <h4 class="profile-section-title">Authors You Engage With Most</h4>
        <div class="profile-chips">${authorsHtml}</div>
      </div>

      <button class="btn-secondary btn-reset-profile" id="resetProfileBtn">
        ğŸ”„ Reset my learning profile
      </button>
    </div>
  `;

  // Wire up remove learned keyword buttons
  container.querySelectorAll('.remove-learned-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      removeLearnedKeyword(btn.dataset.kw);
    });
  });

  // Wire up reset button
  const resetBtn = document.getElementById('resetProfileBtn');
  if (resetBtn) resetBtn.addEventListener('click', resetLearningProfile);
}


function renderKeywordChips() {
  const list = document.getElementById('keywordList');

  if (keywords.length === 0) {
    list.innerHTML = '<span style="color:var(--text-muted);font-size:0.8rem;">No keywords yet.</span>';
    return;
  }

  list.innerHTML = keywords.map((kw, i) => `
    <span class="keyword-chip ${kw.active ? '' : 'off'}"
          data-index="${i}"
          role="button"
          tabindex="0"
          title="${kw.active ? 'Click to disable' : 'Click to enable'}"
          aria-pressed="${kw.active}">
      ${esc(kw.text)}
      <button class="remove-btn"
              data-remove="${i}"
              title="Remove keyword"
              aria-label="Remove ${esc(kw.text)}">Ã—</button>
    </span>
  `).join('');

  list.querySelectorAll('.keyword-chip').forEach(chip => {
    chip.addEventListener('click', (e) => {
      if (e.target.classList.contains('remove-btn')) return;
      toggleKeyword(parseInt(chip.dataset.index));
    });
    chip.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        toggleKeyword(parseInt(chip.dataset.index));
      }
    });
  });

  list.querySelectorAll('.remove-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      removeKeyword(parseInt(btn.dataset.remove));
    });
  });
}


// â”€â”€ Render: active keyword tags below header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderActiveKeywordsBar() {
  const bar    = document.getElementById('activeKeywordsBar');
  const active = activeKeywords();

  if (active.length === 0) {
    bar.innerHTML = '<span class="bar-label">No active keywords</span>';
    return;
  }

  bar.innerHTML =
    '<span class="bar-label">Searching:</span>' +
    active.map(k => `<span class="active-kw-tag">${esc(k)}</span>`).join('');
}


// â”€â”€ Start the app â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
init();
renderKeywordChips();
renderActiveKeywordsBar();

</script>
</body>
</html>
