<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Research Hub — Test Suite</title>
  <style>
    body { font-family: system-ui, sans-serif; max-width: 800px; margin: 40px auto; padding: 0 20px; background: #f5f4f0; }
    h1   { font-size: 1.4rem; margin-bottom: 4px; }
    p.sub { color: #666; font-size: 0.85rem; margin-bottom: 24px; }

    #summary {
      padding: 12px 16px; border-radius: 6px; margin-bottom: 20px;
      font-weight: 600; font-size: 0.95rem;
    }
    #summary.pass { background: #eef6ef; color: #2d7a3a; border: 1px solid #c3e0c7; }
    #summary.fail { background: #fdf0ef; color: #c0392b; border: 1px solid #f0c4c0; }
    #summary.running { background: #e8f0f8; color: #2c5f8a; border: 1px solid #b0ccec; }

    table { width: 100%; border-collapse: collapse; background: #fff; border-radius: 6px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.08); }
    th { background: #f0eeea; text-align: left; padding: 10px 14px; font-size: 0.8rem; color: #666; }
    td { padding: 10px 14px; border-top: 1px solid #eee; font-size: 0.85rem; vertical-align: top; }
    tr.pass td:first-child { border-left: 3px solid #2d7a3a; }
    tr.fail td:first-child { border-left: 3px solid #c0392b; }
    tr.skip td:first-child { border-left: 3px solid #999; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; font-weight: 600; }
    .badge.pass { background: #eef6ef; color: #2d7a3a; }
    .badge.fail { background: #fdf0ef; color: #c0392b; }
    .badge.skip { background: #f0f0f0; color: #999; }
    .error-msg { color: #c0392b; font-size: 0.8rem; margin-top: 4px; font-family: monospace; }
    button#runBtn {
      background: #2c5f8a; color: #fff; border: none; padding: 9px 20px;
      border-radius: 6px; font-size: 0.9rem; cursor: pointer; margin-bottom: 20px;
    }
    button#runBtn:hover { opacity: 0.85; }
    .section-header td { background: #f8f7f4; font-weight: 600; color: #444; font-size: 0.8rem; padding: 8px 14px; }
  </style>
</head>
<body>

<h1>Research Hub — Test Suite</h1>
<p class="sub">Run this file at <strong>http://127.0.0.1:8000/tests.html</strong> to test the app logic without Firebase or the API.</p>

<div id="summary" class="running">⏳ Click "Run Tests" to start…</div>
<button id="runBtn">▶ Run Tests</button>

<table>
  <thead>
    <tr>
      <th style="width:40%">Test</th>
      <th style="width:10%">Result</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody id="results"></tbody>
</table>

<script>
// ════════════════════════════════════════════════════════════
//  Research Hub Test Suite
//  Tests core app logic in isolation — no Firebase, no API.
//  Open at http://127.0.0.1:8000/tests.html to run.
// ════════════════════════════════════════════════════════════

// ── Minimal stubs so we can load the app logic without Firebase or DOM ──

// Stub Firebase globals so the app script doesn't crash on load
window.firebase = {
  initializeApp: () => {},
  auth: () => ({
    onAuthStateChanged: () => {},
    signInWithPopup: () => Promise.resolve(),
    signOut: () => Promise.resolve(),
  }),
  firestore: () => ({
    collection: () => ({ doc: () => ({
      get: () => Promise.resolve({ exists: false }),
      set: () => Promise.resolve(),
    }) }),
  }),
};
// Prevent auth observer from running during tests
window.__TEST_MODE__ = true;

// ── Test runner ──────────────────────────────────────────────

const results = [];

function test(section, name, fn) {
  results.push({ section, name, fn });
}

async function runAll() {
  const tbody = document.getElementById('results');
  const summary = document.getElementById('summary');
  tbody.innerHTML = '';
  summary.className = 'running';
  summary.textContent = '⏳ Running…';

  let passed = 0, failed = 0;
  let lastSection = '';

  for (const t of results) {
    // Section header row
    if (t.section !== lastSection) {
      lastSection = t.section;
      const hdr = document.createElement('tr');
      hdr.innerHTML = `<td class="section-header" colspan="3">${t.section}</td>`;
      tbody.appendChild(hdr);
    }

    const row = document.createElement('tr');
    try {
      await t.fn();
      passed++;
      row.className = 'pass';
      row.innerHTML = `
        <td>${t.name}</td>
        <td><span class="badge pass">PASS</span></td>
        <td>—</td>`;
    } catch (e) {
      failed++;
      row.className = 'fail';
      row.innerHTML = `
        <td>${t.name}</td>
        <td><span class="badge fail">FAIL</span></td>
        <td><div class="error-msg">${e.message}</div></td>`;
    }
    tbody.appendChild(row);
  }

  summary.className = failed === 0 ? 'pass' : 'fail';
  summary.textContent = failed === 0
    ? `✅ All ${passed} tests passed`
    : `❌ ${failed} failed, ${passed} passed`;
}

function assert(condition, msg) {
  if (!condition) throw new Error(msg || 'Assertion failed');
}
function assertEqual(a, b, msg) {
  if (a !== b) throw new Error((msg || 'Expected equal') + `: got ${JSON.stringify(a)}, expected ${JSON.stringify(b)}`);
}
function assertLength(arr, n, msg) {
  if (!Array.isArray(arr) || arr.length !== n) throw new Error((msg || 'Wrong length') + `: got ${arr ? arr.length : 'non-array'}, expected ${n}`);
}


// ════════════════════════════════════════════════════════════
//  SECTION 1 — Keyword management (core logic, no DOM)
// ════════════════════════════════════════════════════════════

// We replicate the pure logic functions here so tests run without
// the full app DOM. If you change these functions in index.html,
// update them here too.

function makeKeywords() {
  return [
    { text: 'social robots',          active: true  },
    { text: 'human-robot interaction', active: true  },
    { text: 'emotional contagion',    active: false },
  ];
}

function getActive(kws) {
  return kws.filter(k => k.active).map(k => k.text);
}

test('Keyword Logic', 'activeKeywords returns only active ones', () => {
  const kws = makeKeywords();
  const active = getActive(kws);
  assertLength(active, 2, 'active keywords count');
  assert(active.includes('social robots'), 'social robots should be active');
  assert(!active.includes('emotional contagion'), 'emotional contagion should be inactive');
});

test('Keyword Logic', 'toggleKeyword flips active state', () => {
  const kws = makeKeywords();
  kws[2].active = !kws[2].active; // toggle emotional contagion ON
  assert(kws[2].active, 'should be active after toggle');
  kws[2].active = !kws[2].active; // toggle back OFF
  assert(!kws[2].active, 'should be inactive after second toggle');
});

test('Keyword Logic', 'addKeyword adds to array', () => {
  const kws = makeKeywords();
  const text = 'carry-over effect';
  if (!kws.some(k => k.text === text)) kws.push({ text, active: true });
  assertLength(kws, 4, 'should have 4 keywords after add');
  assert(kws[3].active, 'new keyword should be active');
  assertEqual(kws[3].text, text, 'new keyword text');
});

test('Keyword Logic', 'addKeyword ignores duplicates', () => {
  const kws = makeKeywords();
  const text = 'social robots'; // already exists
  if (!kws.some(k => k.text === text)) kws.push({ text, active: true });
  assertLength(kws, 3, 'should still have 3 keywords (no duplicate)');
});

test('Keyword Logic', 'removeKeyword removes correct item', () => {
  const kws = makeKeywords();
  kws.splice(1, 1); // remove index 1 (human-robot interaction)
  assertLength(kws, 2, 'should have 2 keywords after remove');
  assert(!kws.some(k => k.text === 'human-robot interaction'), 'removed keyword should be gone');
  assert(kws.some(k => k.text === 'social robots'), 'other keywords should remain');
});

test('Keyword Logic', 'removeKeyword then addKeyword works correctly', () => {
  // This is the regression test for the bug where remove then add was broken
  const kws = makeKeywords();
  kws.splice(0, 1); // remove 'social robots'
  assertLength(kws, 2, 'should have 2 after remove');
  const newText = 'priming';
  if (!kws.some(k => k.text === newText)) kws.push({ text: newText, active: true });
  assertLength(kws, 3, 'should have 3 after adding new keyword');
  assert(kws.some(k => k.text === 'priming'), 'new keyword should exist');
  assert(!kws.some(k => k.text === 'social robots'), 'removed keyword should not exist');
});

test('Keyword Logic', 'getActive returns empty array when all off', () => {
  const kws = makeKeywords().map(k => ({ ...k, active: false }));
  const active = getActive(kws);
  assertLength(active, 0, 'no active keywords');
});


// ════════════════════════════════════════════════════════════
//  SECTION 2 — Relevance scoring
// ════════════════════════════════════════════════════════════

function scorepaperTest(paper, activeKws) {
  if (activeKws.length === 0) return 1;
  const title    = (paper.title    || '').toLowerCase();
  const abstract = (paper.abstract || '').toLowerCase();
  let matches    = 0;
  let matchedKws = 0;
  for (const kw of activeKws) {
    const kwLower    = kw.toLowerCase();
    const inTitle    = title.includes(kwLower);
    const inAbstract = abstract.includes(kwLower);
    if (inTitle || inAbstract) {
      matchedKws++;
      if (inTitle)    matches += 2;
      if (inAbstract) matches += 1;
    }
  }
  if (matchedKws === 0) return 1;
  const ratio = matches / (matchedKws * 3);
  if (ratio < 0.5)  return 3;
  if (ratio < 0.75) return 4;
  return 5;
}

test('Scoring', 'keyword in title scores higher than abstract only', () => {
  const kws = ['social robots'];
  const titleMatch    = { title: 'Social Robots in Education', abstract: 'This paper discusses learning.' };
  const abstractMatch = { title: 'Robots in Education', abstract: 'We study social robots in schools.' };
  const s1 = scorepaperTest(titleMatch, kws);
  const s2 = scorepaperTest(abstractMatch, kws);
  // title-only → 4, abstract-only → 3
  assertEqual(s1, 4, 'title-only match should score 4');
  assertEqual(s2, 3, 'abstract-only match should score 3');
  assert(s1 > s2, `title match (${s1}) should score higher than abstract-only match (${s2})`);
});

test('Scoring', 'no keyword match scores 1', () => {
  const score = scorepaperTest({ title: 'Quantum Physics', abstract: 'Laser beams.' }, ['social robots']);
  assertEqual(score, 1, 'unrelated paper should score 1');
});

test('Scoring', 'keyword in both title and abstract scores 5', () => {
  const kws = ['social robots'];
  const paper = { title: 'Social Robots in Education', abstract: 'Social robots improve outcomes.' };
  assertEqual(scorepaperTest(paper, kws), 5, 'title + abstract match should score 5');
});

test('Scoring', 'multiple keyword matches scores higher', () => {
  const kws = ['social robots', 'emotional contagion'];
  const rich = { title: 'Social Robots and Emotional Contagion', abstract: 'Social robots spread emotional contagion.' };
  const poor = { title: 'Social Robots', abstract: 'A review.' };
  assert(scorepaperTest(rich, kws) > scorepaperTest(poor, kws), 'more matches = higher score');
});

test('Scoring', 'no active keywords returns 1', () => {
  const score = scorepaperTest({ title: 'Any Paper', abstract: 'Any abstract.' }, []);
  assertEqual(score, 1, 'no active keywords should return 1');
});

test('Scoring', 'score is always 1, 3, 4, or 5 (2 removed)', () => {
  const papers = [
    { title: 'Social Robots and HRI', abstract: 'Social robots for human-robot interaction.' },
    { title: 'Nothing relevant', abstract: 'Nothing here.' },
    { title: '', abstract: '' },
    { title: 'Social robots', abstract: 'Social robots are studied here.' },
  ];
  const kws = ['social robots', 'human-robot interaction'];
  for (const p of papers) {
    const s = scorepaperTest(p, kws);
    assert(s >= 1 && s <= 5, `score ${s} out of range for "${p.title}"`);
    assert(s !== 2, `score 2 should never occur (got ${s} for "${p.title}")`);
  }
});


// ════════════════════════════════════════════════════════════
//  SECTION 3 — HTML escaping (XSS prevention)
// ════════════════════════════════════════════════════════════

function esc(str) {
  return (str || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

test('Security', 'esc() escapes < and >', () => {
  assertEqual(esc('<script>'), '&lt;script&gt;', 'angle brackets');
});

test('Security', 'esc() escapes double quotes', () => {
  assertEqual(esc('"hello"'), '&quot;hello&quot;', 'double quotes');
});

test('Security', 'esc() escapes ampersands', () => {
  assertEqual(esc('a & b'), 'a &amp; b', 'ampersand');
});

test('Security', 'esc() handles null/undefined safely', () => {
  assertEqual(esc(null), '', 'null should return empty string');
  assertEqual(esc(undefined), '', 'undefined should return empty string');
});

test('Security', 'esc() leaves normal text unchanged', () => {
  assertEqual(esc('hello world 123'), 'hello world 123', 'normal text unchanged');
});


// ════════════════════════════════════════════════════════════
//  SECTION 4 — Data model integrity
// ════════════════════════════════════════════════════════════

test('Data Model', 'keyword schema has text and active fields', () => {
  const kw = { text: 'social robots', active: true };
  assert(typeof kw.text === 'string', 'text should be string');
  assert(typeof kw.active === 'boolean', 'active should be boolean');
});

test('Data Model', 'DEFAULT_KEYWORDS all have text and active', () => {
  const defaults = [
    { text: 'social robots',          active: true },
    { text: 'human-robot interaction', active: true },
    { text: 'emotional contagion',    active: true },
    { text: 'priming public spaces',  active: true },
    { text: 'non-humanoid robots',    active: true },
  ];
  for (const kw of defaults) {
    assert(typeof kw.text === 'string' && kw.text.length > 0, `keyword text invalid: ${JSON.stringify(kw)}`);
    assert(typeof kw.active === 'boolean', `keyword active invalid: ${JSON.stringify(kw)}`);
  }
});

test('Data Model', 'keyword text is always lowercase', () => {
  const text = '  Social Robots  ';
  const normalised = text.trim().toLowerCase();
  assertEqual(normalised, 'social robots', 'should be lowercased and trimmed');
});

test('Data Model', 'duplicate detection is case-insensitive', () => {
  const kws = [{ text: 'social robots', active: true }];
  const incoming = 'Social Robots'.trim().toLowerCase();
  const isDuplicate = kws.some(k => k.text === incoming);
  assert(isDuplicate, 'should detect duplicate regardless of case');
});


// ════════════════════════════════════════════════════════════
//  SECTION 5 — friendlyTime formatting
// ════════════════════════════════════════════════════════════

function friendlyTime(date) {
  const diff = Math.floor((Date.now() - date.getTime()) / 1000);
  if (diff < 60)    return 'just now';
  if (diff < 3600)  return `${Math.floor(diff / 60)} min ago`;
  if (diff < 86400) return `${Math.floor(diff / 3600)} hr ago`;
  return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
}

test('Formatting', 'friendlyTime: just now for <60s', () => {
  assertEqual(friendlyTime(new Date(Date.now() - 10000)), 'just now', '<60s should be "just now"');
});

test('Formatting', 'friendlyTime: minutes for <1hr', () => {
  const result = friendlyTime(new Date(Date.now() - 5 * 60 * 1000));
  assertEqual(result, '5 min ago', '5 minutes ago');
});

test('Formatting', 'friendlyTime: hours for <24hr', () => {
  const result = friendlyTime(new Date(Date.now() - 3 * 3600 * 1000));
  assertEqual(result, '3 hr ago', '3 hours ago');
});

test('Formatting', 'friendlyTime: date string for >24hr', () => {
  const old = new Date(Date.now() - 2 * 86400 * 1000);
  const result = friendlyTime(old);
  assert(typeof result === 'string' && result.length > 0, 'should return a date string for old dates');
  assert(!result.includes('ago'), 'should not say "ago" for dates > 24hr');
});


// ════════════════════════════════════════════════════════════
//  SECTION 6 — Search filter (applySearchFilter)
// ════════════════════════════════════════════════════════════

// Replicated from index.html — update both if logic changes
function applySearchFilter(arr, q) {
  if (!q || !q.trim()) return arr;
  const term = q.trim().toLowerCase();
  return arr.filter(p => {
    const title    = (p.title    || '').toLowerCase();
    const abstract = (p.abstract || '').toLowerCase();
    const authors  = (p.authors  || []).map(a => (a.name || '').toLowerCase()).join(' ');
    return title.includes(term) || abstract.includes(term) || authors.includes(term);
  });
}

const samplePapers = [
  { paperId: 'p1', title: 'Social Robots in Public Spaces', abstract: 'We study robots.', authors: [{ name: 'Alice Smith' }] },
  { paperId: 'p2', title: 'Emotional Contagion',           abstract: 'About social robots and emotions.', authors: [{ name: 'Bob Jones' }] },
  { paperId: 'p3', title: 'Quantum Physics',               abstract: 'Laser beams and quarks.',            authors: [{ name: 'Carol White' }] },
];

test('Search Filter', 'empty query returns all papers', () => {
  assertLength(applySearchFilter(samplePapers, ''), 3, 'empty query = all');
});

test('Search Filter', 'null query returns all papers', () => {
  assertLength(applySearchFilter(samplePapers, null), 3, 'null query = all');
});

test('Search Filter', 'title match returns correct paper', () => {
  const res = applySearchFilter(samplePapers, 'quantum');
  assertLength(res, 1, 'one title match');
  assertEqual(res[0].paperId, 'p3', 'correct paper id');
});

test('Search Filter', 'abstract match returns correct paper', () => {
  const res = applySearchFilter(samplePapers, 'emotions');
  assertLength(res, 1, 'one abstract match');
  assertEqual(res[0].paperId, 'p2', 'correct paper id');
});

test('Search Filter', 'author name match returns correct paper', () => {
  const res = applySearchFilter(samplePapers, 'carol');
  assertLength(res, 1, 'one author match');
  assertEqual(res[0].paperId, 'p3', 'correct paper id');
});

test('Search Filter', 'search is case-insensitive', () => {
  const res = applySearchFilter(samplePapers, 'SOCIAL ROBOTS');
  assert(res.length >= 1, 'case-insensitive match should work');
});

test('Search Filter', 'no match returns empty array', () => {
  assertLength(applySearchFilter(samplePapers, 'zzznomatch'), 0, 'no match = empty');
});

test('Search Filter', 'regex special chars are treated as literals', () => {
  // Query contains regex special chars — should not throw, just return 0 matches
  let threw = false;
  try { applySearchFilter(samplePapers, '(robots|lasers)'); }
  catch (e) { threw = true; }
  assert(!threw, 'regex special chars should not throw');
});


// ════════════════════════════════════════════════════════════
//  SECTION 7 — Filter functions
// ════════════════════════════════════════════════════════════

// applyScoreFilter
function applyScoreFilter(arr, scores) {
  if (!scores || scores.length === 5) return arr;
  return arr.filter(p => scores.includes(p.score));
}

// applyDateFilter
function applyDateFilter(arr, range) {
  if (range === 'all') return arr;
  const now = Date.now();
  const cutoffMs = { '7d': 7*24*60*60*1000, '30d': 30*24*60*60*1000, '90d': 90*24*60*60*1000, '1y': 365*24*60*60*1000 }[range];
  if (!cutoffMs) return arr;
  const cutoff = now - cutoffMs;
  return arr.filter(p => {
    const dateStr = p.publicationDate || (p.year ? `${p.year}-01-01` : null);
    if (!dateStr) return false;
    const ts = new Date(dateStr).getTime();
    return !isNaN(ts) && ts >= cutoff;
  });
}

// applyKeywordFilter
function applyKeywordFilter(arr, kws) {
  if (!kws || kws.length === 0) return arr;
  const kwsLower = kws.map(k => k.toLowerCase());
  return arr.filter(p => {
    const text = ((p.title || '') + ' ' + (p.abstract || '')).toLowerCase();
    return kwsLower.some(kw => text.includes(kw));
  });
}

// applyCitationFilter
function applyCitationFilter(arr, min) {
  if (!min || min === 0) return arr;
  return arr.filter(p => (p.citationCount || 0) >= min);
}

const scoredPapers = [
  { paperId: 'a', score: 5, publicationDate: null, year: 2024, citationCount: 200, title: 'social robots', abstract: '' },
  { paperId: 'b', score: 3, publicationDate: null, year: 2020, citationCount: 5,   title: 'robots',        abstract: '' },
  { paperId: 'c', score: 1, publicationDate: null, year: 2015, citationCount: 0,   title: 'lasers',        abstract: '' },
];

test('Filter Logic', 'applyScoreFilter keeps matching scores', () => {
  const res = applyScoreFilter(scoredPapers, [5]);
  assertLength(res, 1, 'only score-5 papers');
  assertEqual(res[0].paperId, 'a', 'correct paper');
});

test('Filter Logic', 'applyScoreFilter with all 5 scores returns all', () => {
  assertLength(applyScoreFilter(scoredPapers, [1,2,3,4,5]), 3, 'all scores = all papers');
});

test('Filter Logic', 'applyDateFilter all returns all papers', () => {
  assertLength(applyDateFilter(scoredPapers, 'all'), 3, '"all" returns everything');
});

test('Filter Logic', 'applyDateFilter 7d excludes old papers', () => {
  // Year 2015 paper should be excluded by 7d filter
  const res = applyDateFilter(scoredPapers, '7d');
  assert(!res.some(p => p.paperId === 'c'), 'old paper excluded by 7d filter');
});

test('Filter Logic', 'applyKeywordFilter matches keyword in title', () => {
  const res = applyKeywordFilter(scoredPapers, ['social robots']);
  assertLength(res, 1, 'one title match');
  assertEqual(res[0].paperId, 'a', 'correct paper');
});

test('Filter Logic', 'applyKeywordFilter empty array returns all', () => {
  assertLength(applyKeywordFilter(scoredPapers, []), 3, 'empty kw filter = all');
});

test('Filter Logic', 'applyCitationFilter min=0 returns all', () => {
  assertLength(applyCitationFilter(scoredPapers, 0), 3, 'min=0 = all');
});

test('Filter Logic', 'applyCitationFilter min=100 filters correctly', () => {
  const res = applyCitationFilter(scoredPapers, 100);
  assertLength(res, 1, 'only paper with >=100 citations');
  assertEqual(res[0].paperId, 'a', 'correct paper');
});

test('Filter Logic', 'applyCitationFilter treats missing citationCount as 0', () => {
  const papers = [{ paperId: 'x', title: 'test' }]; // no citationCount field
  assertLength(applyCitationFilter(papers, 10), 0, 'missing citationCount treated as 0');
});

test('Filter Logic', 'applyDateFilter uses publicationDate when available', () => {
  // Paper with publicationDate set to today should survive 7d filter
  const today = new Date().toISOString().slice(0, 10);
  const recentPaper = [{ paperId: 'r', publicationDate: today, title: 'test' }];
  const res = applyDateFilter(recentPaper, '7d');
  assertLength(res, 1, 'today\'s paper survives 7d filter');
});


// ════════════════════════════════════════════════════════════
//  SECTION 8 — Status filter (applyStatusFilter)
// ════════════════════════════════════════════════════════════

function applyStatusFilter(arr, status, actions, seenIds) {
  if (status === 'all') return arr;
  return arr.filter(p => {
    const a = actions[p.paperId] || {};
    if (status === 'liked')  return !!a.liked;
    if (status === 'saved')  return !!a.saved;
    if (status === 'hidden') return !!a.hidden;
    if (status === 'unread') return !seenIds.has(p.paperId);
    return true;
  });
}

const actionPapers = [
  { paperId: 'x1', title: 'Paper 1' },
  { paperId: 'x2', title: 'Paper 2' },
  { paperId: 'x3', title: 'Paper 3' },
];
const testActions = {
  x1: { liked: true, saved: false, hidden: false },
  x2: { liked: false, saved: true, hidden: false },
  x3: { liked: false, saved: false, hidden: true },
};
const testSeenIds = new Set(['x1', 'x2']); // x3 is unread

test('Status Filter', 'status=all returns all papers', () => {
  assertLength(applyStatusFilter(actionPapers, 'all', testActions, testSeenIds), 3, 'all status = all papers');
});

test('Status Filter', 'status=liked returns only liked papers', () => {
  const res = applyStatusFilter(actionPapers, 'liked', testActions, testSeenIds);
  assertLength(res, 1, 'one liked paper');
  assertEqual(res[0].paperId, 'x1', 'correct paper');
});

test('Status Filter', 'status=saved returns only saved papers', () => {
  const res = applyStatusFilter(actionPapers, 'saved', testActions, testSeenIds);
  assertLength(res, 1, 'one saved paper');
  assertEqual(res[0].paperId, 'x2', 'correct paper');
});

test('Status Filter', 'status=hidden returns only hidden papers', () => {
  const res = applyStatusFilter(actionPapers, 'hidden', testActions, testSeenIds);
  assertLength(res, 1, 'one hidden paper');
  assertEqual(res[0].paperId, 'x3', 'correct paper');
});

test('Status Filter', 'status=unread returns papers not in seenIds', () => {
  const res = applyStatusFilter(actionPapers, 'unread', testActions, testSeenIds);
  assertLength(res, 1, 'one unread paper');
  assertEqual(res[0].paperId, 'x3', 'x3 is unread');
});

test('Status Filter', 'signed-out: no action data shows all papers as unread', () => {
  // With empty actions and empty seenIds, all papers are unread
  const emptyActions = {};
  const emptySeenIds = new Set();
  const res = applyStatusFilter(actionPapers, 'unread', emptyActions, emptySeenIds);
  assertLength(res, 3, 'all papers unread when no seen IDs');
});


// ════════════════════════════════════════════════════════════
//  SECTION 9 — Sort order (applySortOrder)
// ════════════════════════════════════════════════════════════

function applySortOrder(arr, order) {
  const a = arr.slice();
  if (order === 'newest') {
    return a.sort((x, y) => {
      const dx = x.publicationDate || (x.year ? `${x.year}-12-31` : '0000-01-01');
      const dy = y.publicationDate || (y.year ? `${y.year}-12-31` : '0000-01-01');
      return dy.localeCompare(dx);
    });
  }
  if (order === 'oldest') {
    return a.sort((x, y) => {
      const dx = x.publicationDate || (x.year ? `${x.year}-01-01` : '9999-12-31');
      const dy = y.publicationDate || (y.year ? `${y.year}-01-01` : '9999-12-31');
      return dx.localeCompare(dy);
    });
  }
  if (order === 'relevance') return a.sort((x, y) => y.score - x.score);
  if (order === 'cited')     return a.sort((x, y) => (y.citationCount || 0) - (x.citationCount || 0));
  return a;
}

const sortablePapers = [
  { paperId: 's1', score: 5, year: 2023, publicationDate: '2023-06-01', citationCount: 50  },
  { paperId: 's2', score: 3, year: 2021, publicationDate: '2021-03-15', citationCount: 200 },
  { paperId: 's3', score: 1, year: 2024, publicationDate: '2024-11-20', citationCount: 10  },
];

test('Sort Logic', 'newest sort puts most recent first', () => {
  const res = applySortOrder(sortablePapers, 'newest');
  assertEqual(res[0].paperId, 's3', 'most recent (2024) first');
  assertEqual(res[2].paperId, 's2', 'oldest (2021) last');
});

test('Sort Logic', 'oldest sort puts earliest first', () => {
  const res = applySortOrder(sortablePapers, 'oldest');
  assertEqual(res[0].paperId, 's2', 'oldest (2021) first');
  assertEqual(res[2].paperId, 's3', 'most recent (2024) last');
});

test('Sort Logic', 'relevance sort puts highest score first', () => {
  const res = applySortOrder(sortablePapers, 'relevance');
  assertEqual(res[0].paperId, 's1', 'score-5 first');
  assertEqual(res[2].paperId, 's3', 'score-1 last');
});

test('Sort Logic', 'cited sort puts most cited first', () => {
  const res = applySortOrder(sortablePapers, 'cited');
  assertEqual(res[0].paperId, 's2', 'most cited (200) first');
  assertEqual(res[2].paperId, 's3', 'least cited (10) last');
});

test('Sort Logic', 'sort does not mutate input array', () => {
  const original = [...sortablePapers];
  applySortOrder(sortablePapers, 'newest');
  for (let i = 0; i < original.length; i++) {
    assertEqual(sortablePapers[i].paperId, original[i].paperId, `input[${i}] should be unchanged`);
  }
});

test('Sort Logic', 'unknown order returns array unchanged (copy)', () => {
  const res = applySortOrder(sortablePapers, 'mystery');
  assertLength(res, sortablePapers.length, 'same length');
});


// ════════════════════════════════════════════════════════════
//  SECTION 10 — Search highlight (highlightSearchTerms)
// ════════════════════════════════════════════════════════════

function highlightSearchTerms(text, q) {
  if (!q || !q.trim()) return text;
  const escaped = q.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex   = new RegExp(escaped, 'gi');
  return text.replace(regex, match => `<mark class="search-highlight">${match}</mark>`);
}

test('Highlight', 'empty query returns text unchanged', () => {
  const text = 'Social robots in public spaces';
  assertEqual(highlightSearchTerms(text, ''), text, 'empty query unchanged');
});

test('Highlight', 'null query returns text unchanged', () => {
  const text = 'Social robots';
  assertEqual(highlightSearchTerms(text, null), text, 'null query unchanged');
});

test('Highlight', 'matching term is wrapped in <mark>', () => {
  const res = highlightSearchTerms('Social robots', 'robots');
  assert(res.includes('<mark class="search-highlight">'), 'mark tag present');
  assert(res.includes('</mark>'), 'closing mark present');
});

test('Highlight', 'highlight is case-insensitive', () => {
  const res = highlightSearchTerms('Social Robots', 'robots');
  assert(res.includes('<mark'), 'case-insensitive match highlighted');
});

test('Highlight', 'multiple occurrences are all highlighted', () => {
  const res = highlightSearchTerms('robots and robots', 'robots');
  const count = (res.match(/<mark/g) || []).length;
  assertEqual(count, 2, 'two occurrences should be highlighted');
});

test('Highlight', 'pre-escaped HTML entities survive highlighting', () => {
  // Input is already HTML-escaped. The function should not double-escape.
  const escaped = 'A &lt;script&gt; tag';
  const res = highlightSearchTerms(escaped, 'script');
  // The entity &lt;script&gt; does contain the literal text "script" (after the semicolon/lt)
  // so the mark should appear around "script" within the entity sequence
  assert(!res.includes('<script>'), 'raw script tag should not appear');
});

test('Highlight', 'regex special chars in query do not throw', () => {
  let threw = false;
  try { highlightSearchTerms('test (robots)', '(robots)'); }
  catch (e) { threw = true; }
  assert(!threw, 'regex special chars should not throw');
});


// ════════════════════════════════════════════════════════════
//  SECTION 11 — Pagination
// ════════════════════════════════════════════════════════════

const PAGE_SIZE_TEST = 20;

function getPageSlice(papersArr, pageIdx) {
  return papersArr.slice(0, (pageIdx + 1) * PAGE_SIZE_TEST);
}

// Make N fake papers
function makePapers(n) {
  return Array.from({ length: n }, (_, i) => ({ paperId: `paper-${i}`, title: `Paper ${i}` }));
}

test('Pagination', 'first page (pageIndex=0) shows PAGE_SIZE papers', () => {
  const all = makePapers(50);
  assertLength(getPageSlice(all, 0), PAGE_SIZE_TEST, 'first page = PAGE_SIZE');
});

test('Pagination', 'load more (pageIndex=1) shows 2*PAGE_SIZE papers', () => {
  const all = makePapers(50);
  assertLength(getPageSlice(all, 1), 2 * PAGE_SIZE_TEST, 'second page = 2*PAGE_SIZE');
});

test('Pagination', 'fewer than PAGE_SIZE papers shows all', () => {
  const all = makePapers(7);
  assertLength(getPageSlice(all, 0), 7, 'all 7 shown when fewer than PAGE_SIZE');
});

test('Pagination', 'load more does not exceed total paper count', () => {
  const all = makePapers(25);
  const slice = getPageSlice(all, 1); // would be 40, but only 25 exist
  assertLength(slice, 25, 'capped at total count');
});


// ── Wire up the run button ───────────────────────────────────
document.getElementById('runBtn').addEventListener('click', runAll);

// Auto-run on load
runAll();
</script>
</body>
</html>
