<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Research Hub — Test Suite</title>
  <style>
    body { font-family: system-ui, sans-serif; max-width: 800px; margin: 40px auto; padding: 0 20px; background: #f5f4f0; }
    h1   { font-size: 1.4rem; margin-bottom: 4px; }
    p.sub { color: #666; font-size: 0.85rem; margin-bottom: 24px; }

    #summary {
      padding: 12px 16px; border-radius: 6px; margin-bottom: 20px;
      font-weight: 600; font-size: 0.95rem;
    }
    #summary.pass { background: #eef6ef; color: #2d7a3a; border: 1px solid #c3e0c7; }
    #summary.fail { background: #fdf0ef; color: #c0392b; border: 1px solid #f0c4c0; }
    #summary.running { background: #e8f0f8; color: #2c5f8a; border: 1px solid #b0ccec; }

    table { width: 100%; border-collapse: collapse; background: #fff; border-radius: 6px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.08); }
    th { background: #f0eeea; text-align: left; padding: 10px 14px; font-size: 0.8rem; color: #666; }
    td { padding: 10px 14px; border-top: 1px solid #eee; font-size: 0.85rem; vertical-align: top; }
    tr.pass td:first-child { border-left: 3px solid #2d7a3a; }
    tr.fail td:first-child { border-left: 3px solid #c0392b; }
    tr.skip td:first-child { border-left: 3px solid #999; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; font-weight: 600; }
    .badge.pass { background: #eef6ef; color: #2d7a3a; }
    .badge.fail { background: #fdf0ef; color: #c0392b; }
    .badge.skip { background: #f0f0f0; color: #999; }
    .error-msg { color: #c0392b; font-size: 0.8rem; margin-top: 4px; font-family: monospace; }
    button#runBtn {
      background: #2c5f8a; color: #fff; border: none; padding: 9px 20px;
      border-radius: 6px; font-size: 0.9rem; cursor: pointer; margin-bottom: 20px;
    }
    button#runBtn:hover { opacity: 0.85; }
    .section-header td { background: #f8f7f4; font-weight: 600; color: #444; font-size: 0.8rem; padding: 8px 14px; }
  </style>
</head>
<body>

<h1>Research Hub — Test Suite</h1>
<p class="sub">Run this file at <strong>http://127.0.0.1:8000/tests.html</strong> to test the app logic without Firebase or the API.</p>

<div id="summary" class="running">⏳ Click "Run Tests" to start…</div>
<button id="runBtn">▶ Run Tests</button>

<table>
  <thead>
    <tr>
      <th style="width:40%">Test</th>
      <th style="width:10%">Result</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody id="results"></tbody>
</table>

<script>
// ════════════════════════════════════════════════════════════
//  Research Hub Test Suite
//  Tests core app logic in isolation — no Firebase, no API.
//  Open at http://127.0.0.1:8000/tests.html to run.
// ════════════════════════════════════════════════════════════

// ── Minimal stubs so we can load the app logic without Firebase or DOM ──

// Stub Firebase globals so the app script doesn't crash on load
window.firebase = {
  initializeApp: () => {},
  auth: () => ({
    onAuthStateChanged: () => {},
    signInWithPopup: () => Promise.resolve(),
    signOut: () => Promise.resolve(),
  }),
  firestore: () => ({
    collection: () => ({ doc: () => ({
      get: () => Promise.resolve({ exists: false }),
      set: () => Promise.resolve(),
    }) }),
  }),
};
// Prevent auth observer from running during tests
window.__TEST_MODE__ = true;

// ── Test runner ──────────────────────────────────────────────

const results = [];

function test(section, name, fn) {
  results.push({ section, name, fn });
}

async function runAll() {
  const tbody = document.getElementById('results');
  const summary = document.getElementById('summary');
  tbody.innerHTML = '';
  summary.className = 'running';
  summary.textContent = '⏳ Running…';

  let passed = 0, failed = 0;
  let lastSection = '';

  for (const t of results) {
    // Section header row
    if (t.section !== lastSection) {
      lastSection = t.section;
      const hdr = document.createElement('tr');
      hdr.innerHTML = `<td class="section-header" colspan="3">${t.section}</td>`;
      tbody.appendChild(hdr);
    }

    const row = document.createElement('tr');
    try {
      await t.fn();
      passed++;
      row.className = 'pass';
      row.innerHTML = `
        <td>${t.name}</td>
        <td><span class="badge pass">PASS</span></td>
        <td>—</td>`;
    } catch (e) {
      failed++;
      row.className = 'fail';
      row.innerHTML = `
        <td>${t.name}</td>
        <td><span class="badge fail">FAIL</span></td>
        <td><div class="error-msg">${e.message}</div></td>`;
    }
    tbody.appendChild(row);
  }

  summary.className = failed === 0 ? 'pass' : 'fail';
  summary.textContent = failed === 0
    ? `✅ All ${passed} tests passed`
    : `❌ ${failed} failed, ${passed} passed`;
}

function assert(condition, msg) {
  if (!condition) throw new Error(msg || 'Assertion failed');
}
function assertEqual(a, b, msg) {
  if (a !== b) throw new Error((msg || 'Expected equal') + `: got ${JSON.stringify(a)}, expected ${JSON.stringify(b)}`);
}
function assertLength(arr, n, msg) {
  if (!Array.isArray(arr) || arr.length !== n) throw new Error((msg || 'Wrong length') + `: got ${arr ? arr.length : 'non-array'}, expected ${n}`);
}


// ════════════════════════════════════════════════════════════
//  SECTION 1 — Keyword management (core logic, no DOM)
// ════════════════════════════════════════════════════════════

// We replicate the pure logic functions here so tests run without
// the full app DOM. If you change these functions in index.html,
// update them here too.

function makeKeywords() {
  return [
    { text: 'social robots',          active: true  },
    { text: 'human-robot interaction', active: true  },
    { text: 'emotional contagion',    active: false },
  ];
}

function getActive(kws) {
  return kws.filter(k => k.active).map(k => k.text);
}

test('Keyword Logic', 'activeKeywords returns only active ones', () => {
  const kws = makeKeywords();
  const active = getActive(kws);
  assertLength(active, 2, 'active keywords count');
  assert(active.includes('social robots'), 'social robots should be active');
  assert(!active.includes('emotional contagion'), 'emotional contagion should be inactive');
});

test('Keyword Logic', 'toggleKeyword flips active state', () => {
  const kws = makeKeywords();
  kws[2].active = !kws[2].active; // toggle emotional contagion ON
  assert(kws[2].active, 'should be active after toggle');
  kws[2].active = !kws[2].active; // toggle back OFF
  assert(!kws[2].active, 'should be inactive after second toggle');
});

test('Keyword Logic', 'addKeyword adds to array', () => {
  const kws = makeKeywords();
  const text = 'carry-over effect';
  if (!kws.some(k => k.text === text)) kws.push({ text, active: true });
  assertLength(kws, 4, 'should have 4 keywords after add');
  assert(kws[3].active, 'new keyword should be active');
  assertEqual(kws[3].text, text, 'new keyword text');
});

test('Keyword Logic', 'addKeyword ignores duplicates', () => {
  const kws = makeKeywords();
  const text = 'social robots'; // already exists
  if (!kws.some(k => k.text === text)) kws.push({ text, active: true });
  assertLength(kws, 3, 'should still have 3 keywords (no duplicate)');
});

test('Keyword Logic', 'removeKeyword removes correct item', () => {
  const kws = makeKeywords();
  kws.splice(1, 1); // remove index 1 (human-robot interaction)
  assertLength(kws, 2, 'should have 2 keywords after remove');
  assert(!kws.some(k => k.text === 'human-robot interaction'), 'removed keyword should be gone');
  assert(kws.some(k => k.text === 'social robots'), 'other keywords should remain');
});

test('Keyword Logic', 'removeKeyword then addKeyword works correctly', () => {
  // This is the regression test for the bug where remove then add was broken
  const kws = makeKeywords();
  kws.splice(0, 1); // remove 'social robots'
  assertLength(kws, 2, 'should have 2 after remove');
  const newText = 'priming';
  if (!kws.some(k => k.text === newText)) kws.push({ text: newText, active: true });
  assertLength(kws, 3, 'should have 3 after adding new keyword');
  assert(kws.some(k => k.text === 'priming'), 'new keyword should exist');
  assert(!kws.some(k => k.text === 'social robots'), 'removed keyword should not exist');
});

test('Keyword Logic', 'getActive returns empty array when all off', () => {
  const kws = makeKeywords().map(k => ({ ...k, active: false }));
  const active = getActive(kws);
  assertLength(active, 0, 'no active keywords');
});


// ════════════════════════════════════════════════════════════
//  SECTION 2 — Relevance scoring
// ════════════════════════════════════════════════════════════

function scorepaperTest(paper, activeKws) {
  // Mirror of scorepaper() in index.html — must be kept in sync.
  if (activeKws.length === 0) return 1;
  const title    = (paper.title    || '').toLowerCase();
  const abstract = (paper.abstract || '').toLowerCase();
  let depthScore = 0;
  let matchedKws = 0;
  for (const kw of activeKws) {
    const kwLower    = kw.toLowerCase();
    const inTitle    = title.includes(kwLower);
    const inAbstract = abstract.includes(kwLower);
    if (inTitle || inAbstract) {
      matchedKws++;
      if (inTitle)    depthScore += 2;
      if (inAbstract) depthScore += 1;
    }
  }
  if (matchedKws === 0) return 1;
  const breadth  = matchedKws / activeKws.length;
  const depth    = depthScore / (matchedKws * 3);
  const combined = (breadth * 0.7) + (depth * 0.3);
  if (combined >= 0.75) return 5;
  if (combined >= 0.50) return 4;
  if (combined >= 0.30) return 3;
  if (combined >= 0.10) return 2;
  return 1;
}

test('Scoring', 'keyword in title scores higher than abstract only (multi-keyword)', () => {
  // With multiple keywords, breadth penalises partial matches.
  // Use 4 keywords; paper only matches 1 via title vs 1 via abstract.
  const kws = ['social robots', 'human robot interaction', 'priming', 'carryover'];
  const titleMatch    = { title: 'Social Robots in Education', abstract: 'This paper discusses learning.' };
  const abstractMatch = { title: 'Robots in Education', abstract: 'We study social robots in schools.' };
  const s1 = scorepaperTest(titleMatch, kws);
  const s2 = scorepaperTest(abstractMatch, kws);
  // breadth = 1/4 = 0.25 for both; depth differs (title=0.667 vs abstract=0.333)
  // s1: combined = 0.25×0.7 + 0.667×0.3 = 0.175+0.200 = 0.375 → 3
  // s2: combined = 0.25×0.7 + 0.333×0.3 = 0.175+0.100 = 0.275 → 2
  assert(s1 > s2, `title match (${s1}) should score higher than abstract-only match (${s2})`);
  assert(s1 >= 2 && s1 <= 5, `title match score ${s1} should be in range 2-5`);
  assert(s2 >= 1 && s2 <= 5, `abstract match score ${s2} should be in range 1-5`);
});

test('Scoring', 'no keyword match scores 1', () => {
  const score = scorepaperTest({ title: 'Quantum Physics', abstract: 'Laser beams.' }, ['social robots']);
  assertEqual(score, 1, 'unrelated paper should score 1');
});

test('Scoring', 'single keyword in both title and abstract scores 5', () => {
  // With only 1 keyword, breadth=1.0, depth=1.0, combined=1.0 → 5
  const kws = ['social robots'];
  const paper = { title: 'Social Robots in Education', abstract: 'Social robots improve outcomes.' };
  assertEqual(scorepaperTest(paper, kws), 5, 'title + abstract match (1 keyword) should score 5');
});

test('Scoring', 'multiple keyword matches scores higher', () => {
  const kws = ['social robots', 'emotional contagion'];
  const rich = { title: 'Social Robots and Emotional Contagion', abstract: 'Social robots spread emotional contagion.' };
  const poor = { title: 'Social Robots', abstract: 'A review.' };
  assert(scorepaperTest(rich, kws) > scorepaperTest(poor, kws), 'more matches = higher score');
});

test('Scoring', '1-of-4 keywords match does not score 5 (breadth penalty)', () => {
  // Core requirement: a paper matching only 1 of 4 active keywords cannot score 5/5,
  // even if that keyword appears in both title and abstract.
  const kws = ['human robot interaction', 'social modeling', 'social robots', 'carryover in hri'];
  const oneMatch = { title: 'Social Modeling in Teams', abstract: 'Social modeling drives group behaviour.' };
  const score = scorepaperTest(oneMatch, kws);
  // breadth = 1/4 = 0.25, depth = 1.0 → combined = 0.475 → score 3 (not 5)
  assert(score < 5, `1-of-4 keyword match should score < 5, got ${score}`);
  assert(score >= 2, `1-of-4 keyword match should score >= 2, got ${score}`);
});

test('Scoring', 'matching all 4 keywords scores 5', () => {
  const kws = ['human robot interaction', 'social modeling', 'social robots', 'carryover in hri'];
  const allMatch = {
    title: 'Human Robot Interaction: Social Robots, Social Modeling and Carryover in HRI',
    abstract: 'We examine human robot interaction alongside social modeling, social robots and carryover in hri.'
  };
  assertEqual(scorepaperTest(allMatch, kws), 5, 'all 4 keywords matched should score 5');
});

test('Scoring', 'no active keywords returns 1', () => {
  const score = scorepaperTest({ title: 'Any Paper', abstract: 'Any abstract.' }, []);
  assertEqual(score, 1, 'no active keywords should return 1');
});

test('Scoring', 'score is always between 1 and 5', () => {
  // New formula can produce all values 1-5 depending on breadth+depth
  const papers = [
    { title: 'Social Robots and HRI', abstract: 'Social robots for human-robot interaction.' },
    { title: 'Nothing relevant', abstract: 'Nothing here.' },
    { title: '', abstract: '' },
    { title: 'Social robots', abstract: 'Social robots are studied here.' },
  ];
  const kws = ['social robots', 'human-robot interaction'];
  for (const p of papers) {
    const s = scorepaperTest(p, kws);
    assert(s >= 1 && s <= 5, `score ${s} out of range for "${p.title}"`);
  }
});


// ════════════════════════════════════════════════════════════
//  SECTION 3 — HTML escaping (XSS prevention)
// ════════════════════════════════════════════════════════════

function esc(str) {
  return (str || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

test('Security', 'esc() escapes < and >', () => {
  assertEqual(esc('<script>'), '&lt;script&gt;', 'angle brackets');
});

test('Security', 'esc() escapes double quotes', () => {
  assertEqual(esc('"hello"'), '&quot;hello&quot;', 'double quotes');
});

test('Security', 'esc() escapes ampersands', () => {
  assertEqual(esc('a & b'), 'a &amp; b', 'ampersand');
});

test('Security', 'esc() handles null/undefined safely', () => {
  assertEqual(esc(null), '', 'null should return empty string');
  assertEqual(esc(undefined), '', 'undefined should return empty string');
});

test('Security', 'esc() leaves normal text unchanged', () => {
  assertEqual(esc('hello world 123'), 'hello world 123', 'normal text unchanged');
});


// ════════════════════════════════════════════════════════════
//  SECTION 4 — Data model integrity
// ════════════════════════════════════════════════════════════

test('Data Model', 'keyword schema has text and active fields', () => {
  const kw = { text: 'social robots', active: true };
  assert(typeof kw.text === 'string', 'text should be string');
  assert(typeof kw.active === 'boolean', 'active should be boolean');
});

test('Data Model', 'DEFAULT_KEYWORDS all have text and active', () => {
  const defaults = [
    { text: 'social robots',          active: true },
    { text: 'human-robot interaction', active: true },
    { text: 'emotional contagion',    active: true },
    { text: 'priming public spaces',  active: true },
    { text: 'non-humanoid robots',    active: true },
  ];
  for (const kw of defaults) {
    assert(typeof kw.text === 'string' && kw.text.length > 0, `keyword text invalid: ${JSON.stringify(kw)}`);
    assert(typeof kw.active === 'boolean', `keyword active invalid: ${JSON.stringify(kw)}`);
  }
});

test('Data Model', 'keyword text is always lowercase', () => {
  const text = '  Social Robots  ';
  const normalised = text.trim().toLowerCase();
  assertEqual(normalised, 'social robots', 'should be lowercased and trimmed');
});

test('Data Model', 'duplicate detection is case-insensitive', () => {
  const kws = [{ text: 'social robots', active: true }];
  const incoming = 'Social Robots'.trim().toLowerCase();
  const isDuplicate = kws.some(k => k.text === incoming);
  assert(isDuplicate, 'should detect duplicate regardless of case');
});


// ════════════════════════════════════════════════════════════
//  SECTION 5 — friendlyTime formatting
// ════════════════════════════════════════════════════════════

function friendlyTime(date) {
  const diff = Math.floor((Date.now() - date.getTime()) / 1000);
  if (diff < 60)    return 'just now';
  if (diff < 3600)  return `${Math.floor(diff / 60)} min ago`;
  if (diff < 86400) return `${Math.floor(diff / 3600)} hr ago`;
  return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
}

test('Formatting', 'friendlyTime: just now for <60s', () => {
  assertEqual(friendlyTime(new Date(Date.now() - 10000)), 'just now', '<60s should be "just now"');
});

test('Formatting', 'friendlyTime: minutes for <1hr', () => {
  const result = friendlyTime(new Date(Date.now() - 5 * 60 * 1000));
  assertEqual(result, '5 min ago', '5 minutes ago');
});

test('Formatting', 'friendlyTime: hours for <24hr', () => {
  const result = friendlyTime(new Date(Date.now() - 3 * 3600 * 1000));
  assertEqual(result, '3 hr ago', '3 hours ago');
});

test('Formatting', 'friendlyTime: date string for >24hr', () => {
  const old = new Date(Date.now() - 2 * 86400 * 1000);
  const result = friendlyTime(old);
  assert(typeof result === 'string' && result.length > 0, 'should return a date string for old dates');
  assert(!result.includes('ago'), 'should not say "ago" for dates > 24hr');
});


// ════════════════════════════════════════════════════════════
//  SECTION 6 — Search filter (applySearchFilter)
// ════════════════════════════════════════════════════════════

// Replicated from index.html — update both if logic changes
function applySearchFilter(arr, q) {
  if (!q || !q.trim()) return arr;
  const term = q.trim().toLowerCase();
  return arr.filter(p => {
    const title    = (p.title    || '').toLowerCase();
    const abstract = (p.abstract || '').toLowerCase();
    const authors  = (p.authors  || []).map(a => (a.name || '').toLowerCase()).join(' ');
    return title.includes(term) || abstract.includes(term) || authors.includes(term);
  });
}

const samplePapers = [
  { paperId: 'p1', title: 'Social Robots in Public Spaces', abstract: 'We study robots.', authors: [{ name: 'Alice Smith' }] },
  { paperId: 'p2', title: 'Emotional Contagion',           abstract: 'About social robots and emotions.', authors: [{ name: 'Bob Jones' }] },
  { paperId: 'p3', title: 'Quantum Physics',               abstract: 'Laser beams and quarks.',            authors: [{ name: 'Carol White' }] },
];

test('Search Filter', 'empty query returns all papers', () => {
  assertLength(applySearchFilter(samplePapers, ''), 3, 'empty query = all');
});

test('Search Filter', 'null query returns all papers', () => {
  assertLength(applySearchFilter(samplePapers, null), 3, 'null query = all');
});

test('Search Filter', 'title match returns correct paper', () => {
  const res = applySearchFilter(samplePapers, 'quantum');
  assertLength(res, 1, 'one title match');
  assertEqual(res[0].paperId, 'p3', 'correct paper id');
});

test('Search Filter', 'abstract match returns correct paper', () => {
  const res = applySearchFilter(samplePapers, 'emotions');
  assertLength(res, 1, 'one abstract match');
  assertEqual(res[0].paperId, 'p2', 'correct paper id');
});

test('Search Filter', 'author name match returns correct paper', () => {
  const res = applySearchFilter(samplePapers, 'carol');
  assertLength(res, 1, 'one author match');
  assertEqual(res[0].paperId, 'p3', 'correct paper id');
});

test('Search Filter', 'search is case-insensitive', () => {
  const res = applySearchFilter(samplePapers, 'SOCIAL ROBOTS');
  assert(res.length >= 1, 'case-insensitive match should work');
});

test('Search Filter', 'no match returns empty array', () => {
  assertLength(applySearchFilter(samplePapers, 'zzznomatch'), 0, 'no match = empty');
});

test('Search Filter', 'regex special chars are treated as literals', () => {
  // Query contains regex special chars — should not throw, just return 0 matches
  let threw = false;
  try { applySearchFilter(samplePapers, '(robots|lasers)'); }
  catch (e) { threw = true; }
  assert(!threw, 'regex special chars should not throw');
});


// ════════════════════════════════════════════════════════════
//  SECTION 7 — Filter functions
// ════════════════════════════════════════════════════════════

// applyScoreFilter
function applyScoreFilter(arr, scores) {
  if (!scores || scores.length === 5) return arr;
  return arr.filter(p => scores.includes(p.score));
}

// applyDateFilter
function applyDateFilter(arr, range) {
  if (range === 'all') return arr;
  const now = Date.now();
  const cutoffMs = { '7d': 7*24*60*60*1000, '30d': 30*24*60*60*1000, '90d': 90*24*60*60*1000, '1y': 365*24*60*60*1000 }[range];
  if (!cutoffMs) return arr;
  const cutoff = now - cutoffMs;
  return arr.filter(p => {
    const dateStr = p.publicationDate || (p.year ? `${p.year}-01-01` : null);
    if (!dateStr) return false;
    const ts = new Date(dateStr).getTime();
    return !isNaN(ts) && ts >= cutoff;
  });
}

// applyKeywordFilter
function applyKeywordFilter(arr, kws) {
  if (!kws || kws.length === 0) return arr;
  const kwsLower = kws.map(k => k.toLowerCase());
  return arr.filter(p => {
    const text = ((p.title || '') + ' ' + (p.abstract || '')).toLowerCase();
    return kwsLower.some(kw => text.includes(kw));
  });
}

// applyCitationFilter
function applyCitationFilter(arr, min) {
  if (!min || min === 0) return arr;
  return arr.filter(p => (p.citationCount || 0) >= min);
}

const scoredPapers = [
  { paperId: 'a', score: 5, publicationDate: null, year: 2024, citationCount: 200, title: 'social robots', abstract: '' },
  { paperId: 'b', score: 3, publicationDate: null, year: 2020, citationCount: 5,   title: 'robots',        abstract: '' },
  { paperId: 'c', score: 1, publicationDate: null, year: 2015, citationCount: 0,   title: 'lasers',        abstract: '' },
];

test('Filter Logic', 'applyScoreFilter keeps matching scores', () => {
  const res = applyScoreFilter(scoredPapers, [5]);
  assertLength(res, 1, 'only score-5 papers');
  assertEqual(res[0].paperId, 'a', 'correct paper');
});

test('Filter Logic', 'applyScoreFilter with all 5 scores returns all', () => {
  assertLength(applyScoreFilter(scoredPapers, [1,2,3,4,5]), 3, 'all scores = all papers');
});

test('Filter Logic', 'applyDateFilter all returns all papers', () => {
  assertLength(applyDateFilter(scoredPapers, 'all'), 3, '"all" returns everything');
});

test('Filter Logic', 'applyDateFilter 7d excludes old papers', () => {
  // Year 2015 paper should be excluded by 7d filter
  const res = applyDateFilter(scoredPapers, '7d');
  assert(!res.some(p => p.paperId === 'c'), 'old paper excluded by 7d filter');
});

test('Filter Logic', 'applyKeywordFilter matches keyword in title', () => {
  const res = applyKeywordFilter(scoredPapers, ['social robots']);
  assertLength(res, 1, 'one title match');
  assertEqual(res[0].paperId, 'a', 'correct paper');
});

test('Filter Logic', 'applyKeywordFilter empty array returns all', () => {
  assertLength(applyKeywordFilter(scoredPapers, []), 3, 'empty kw filter = all');
});

test('Filter Logic', 'applyCitationFilter min=0 returns all', () => {
  assertLength(applyCitationFilter(scoredPapers, 0), 3, 'min=0 = all');
});

test('Filter Logic', 'applyCitationFilter min=100 filters correctly', () => {
  const res = applyCitationFilter(scoredPapers, 100);
  assertLength(res, 1, 'only paper with >=100 citations');
  assertEqual(res[0].paperId, 'a', 'correct paper');
});

test('Filter Logic', 'applyCitationFilter treats missing citationCount as 0', () => {
  const papers = [{ paperId: 'x', title: 'test' }]; // no citationCount field
  assertLength(applyCitationFilter(papers, 10), 0, 'missing citationCount treated as 0');
});

test('Filter Logic', 'applyDateFilter uses publicationDate when available', () => {
  // Paper with publicationDate set to today should survive 7d filter
  const today = new Date().toISOString().slice(0, 10);
  const recentPaper = [{ paperId: 'r', publicationDate: today, title: 'test' }];
  const res = applyDateFilter(recentPaper, '7d');
  assertLength(res, 1, 'today\'s paper survives 7d filter');
});


// ════════════════════════════════════════════════════════════
//  SECTION 8 — Status filter (applyStatusFilter)
// ════════════════════════════════════════════════════════════

function applyStatusFilter(arr, status, actions, seenIds) {
  if (status === 'all') return arr;
  return arr.filter(p => {
    const a = actions[p.paperId] || {};
    if (status === 'liked')  return !!a.liked;
    if (status === 'saved')  return !!a.saved;
    if (status === 'hidden') return !!a.hidden;
    if (status === 'unread') return !seenIds.has(p.paperId);
    return true;
  });
}

const actionPapers = [
  { paperId: 'x1', title: 'Paper 1' },
  { paperId: 'x2', title: 'Paper 2' },
  { paperId: 'x3', title: 'Paper 3' },
];
const testActions = {
  x1: { liked: true, saved: false, hidden: false },
  x2: { liked: false, saved: true, hidden: false },
  x3: { liked: false, saved: false, hidden: true },
};
const testSeenIds = new Set(['x1', 'x2']); // x3 is unread

test('Status Filter', 'status=all returns all papers', () => {
  assertLength(applyStatusFilter(actionPapers, 'all', testActions, testSeenIds), 3, 'all status = all papers');
});

test('Status Filter', 'status=liked returns only liked papers', () => {
  const res = applyStatusFilter(actionPapers, 'liked', testActions, testSeenIds);
  assertLength(res, 1, 'one liked paper');
  assertEqual(res[0].paperId, 'x1', 'correct paper');
});

test('Status Filter', 'status=saved returns only saved papers', () => {
  const res = applyStatusFilter(actionPapers, 'saved', testActions, testSeenIds);
  assertLength(res, 1, 'one saved paper');
  assertEqual(res[0].paperId, 'x2', 'correct paper');
});

test('Status Filter', 'status=hidden returns only hidden papers', () => {
  const res = applyStatusFilter(actionPapers, 'hidden', testActions, testSeenIds);
  assertLength(res, 1, 'one hidden paper');
  assertEqual(res[0].paperId, 'x3', 'correct paper');
});

test('Status Filter', 'status=unread returns papers not in seenIds', () => {
  const res = applyStatusFilter(actionPapers, 'unread', testActions, testSeenIds);
  assertLength(res, 1, 'one unread paper');
  assertEqual(res[0].paperId, 'x3', 'x3 is unread');
});

test('Status Filter', 'signed-out: no action data shows all papers as unread', () => {
  // With empty actions and empty seenIds, all papers are unread
  const emptyActions = {};
  const emptySeenIds = new Set();
  const res = applyStatusFilter(actionPapers, 'unread', emptyActions, emptySeenIds);
  assertLength(res, 3, 'all papers unread when no seen IDs');
});


// ════════════════════════════════════════════════════════════
//  SECTION 9 — Sort order (applySortOrder)
// ════════════════════════════════════════════════════════════

function applySortOrder(arr, order) {
  const a = arr.slice();
  if (order === 'newest') {
    return a.sort((x, y) => {
      const dx = x.publicationDate || (x.year ? `${x.year}-12-31` : '0000-01-01');
      const dy = y.publicationDate || (y.year ? `${y.year}-12-31` : '0000-01-01');
      return dy.localeCompare(dx);
    });
  }
  if (order === 'oldest') {
    return a.sort((x, y) => {
      const dx = x.publicationDate || (x.year ? `${x.year}-01-01` : '9999-12-31');
      const dy = y.publicationDate || (y.year ? `${y.year}-01-01` : '9999-12-31');
      return dx.localeCompare(dy);
    });
  }
  if (order === 'relevance') return a.sort((x, y) => y.score - x.score);
  if (order === 'cited')     return a.sort((x, y) => (y.citationCount || 0) - (x.citationCount || 0));
  return a;
}

const sortablePapers = [
  { paperId: 's1', score: 5, year: 2023, publicationDate: '2023-06-01', citationCount: 50  },
  { paperId: 's2', score: 3, year: 2021, publicationDate: '2021-03-15', citationCount: 200 },
  { paperId: 's3', score: 1, year: 2024, publicationDate: '2024-11-20', citationCount: 10  },
];

test('Sort Logic', 'newest sort puts most recent first', () => {
  const res = applySortOrder(sortablePapers, 'newest');
  assertEqual(res[0].paperId, 's3', 'most recent (2024) first');
  assertEqual(res[2].paperId, 's2', 'oldest (2021) last');
});

test('Sort Logic', 'oldest sort puts earliest first', () => {
  const res = applySortOrder(sortablePapers, 'oldest');
  assertEqual(res[0].paperId, 's2', 'oldest (2021) first');
  assertEqual(res[2].paperId, 's3', 'most recent (2024) last');
});

test('Sort Logic', 'relevance sort puts highest score first', () => {
  const res = applySortOrder(sortablePapers, 'relevance');
  assertEqual(res[0].paperId, 's1', 'score-5 first');
  assertEqual(res[2].paperId, 's3', 'score-1 last');
});

test('Sort Logic', 'cited sort puts most cited first', () => {
  const res = applySortOrder(sortablePapers, 'cited');
  assertEqual(res[0].paperId, 's2', 'most cited (200) first');
  assertEqual(res[2].paperId, 's3', 'least cited (10) last');
});

test('Sort Logic', 'sort does not mutate input array', () => {
  const original = [...sortablePapers];
  applySortOrder(sortablePapers, 'newest');
  for (let i = 0; i < original.length; i++) {
    assertEqual(sortablePapers[i].paperId, original[i].paperId, `input[${i}] should be unchanged`);
  }
});

test('Sort Logic', 'unknown order returns array unchanged (copy)', () => {
  const res = applySortOrder(sortablePapers, 'mystery');
  assertLength(res, sortablePapers.length, 'same length');
});


// ════════════════════════════════════════════════════════════
//  SECTION 10 — Search highlight (highlightSearchTerms)
// ════════════════════════════════════════════════════════════

function highlightSearchTerms(text, q) {
  if (!q || !q.trim()) return text;
  const escaped = q.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex   = new RegExp(escaped, 'gi');
  return text.replace(regex, match => `<mark class="search-highlight">${match}</mark>`);
}

test('Highlight', 'empty query returns text unchanged', () => {
  const text = 'Social robots in public spaces';
  assertEqual(highlightSearchTerms(text, ''), text, 'empty query unchanged');
});

test('Highlight', 'null query returns text unchanged', () => {
  const text = 'Social robots';
  assertEqual(highlightSearchTerms(text, null), text, 'null query unchanged');
});

test('Highlight', 'matching term is wrapped in <mark>', () => {
  const res = highlightSearchTerms('Social robots', 'robots');
  assert(res.includes('<mark class="search-highlight">'), 'mark tag present');
  assert(res.includes('</mark>'), 'closing mark present');
});

test('Highlight', 'highlight is case-insensitive', () => {
  const res = highlightSearchTerms('Social Robots', 'robots');
  assert(res.includes('<mark'), 'case-insensitive match highlighted');
});

test('Highlight', 'multiple occurrences are all highlighted', () => {
  const res = highlightSearchTerms('robots and robots', 'robots');
  const count = (res.match(/<mark/g) || []).length;
  assertEqual(count, 2, 'two occurrences should be highlighted');
});

test('Highlight', 'pre-escaped HTML entities survive highlighting', () => {
  // Input is already HTML-escaped. The function should not double-escape.
  const escaped = 'A &lt;script&gt; tag';
  const res = highlightSearchTerms(escaped, 'script');
  // The entity &lt;script&gt; does contain the literal text "script" (after the semicolon/lt)
  // so the mark should appear around "script" within the entity sequence
  assert(!res.includes('<script>'), 'raw script tag should not appear');
});

test('Highlight', 'regex special chars in query do not throw', () => {
  let threw = false;
  try { highlightSearchTerms('test (robots)', '(robots)'); }
  catch (e) { threw = true; }
  assert(!threw, 'regex special chars should not throw');
});


// ════════════════════════════════════════════════════════════
//  SECTION 11 — Pagination
// ════════════════════════════════════════════════════════════

const PAGE_SIZE_TEST = 20;

function getPageSlice(papersArr, pageIdx) {
  return papersArr.slice(0, (pageIdx + 1) * PAGE_SIZE_TEST);
}

// Make N fake papers
function makePapers(n) {
  return Array.from({ length: n }, (_, i) => ({ paperId: `paper-${i}`, title: `Paper ${i}` }));
}

test('Pagination', 'first page (pageIndex=0) shows PAGE_SIZE papers', () => {
  const all = makePapers(50);
  assertLength(getPageSlice(all, 0), PAGE_SIZE_TEST, 'first page = PAGE_SIZE');
});

test('Pagination', 'load more (pageIndex=1) shows 2*PAGE_SIZE papers', () => {
  const all = makePapers(50);
  assertLength(getPageSlice(all, 1), 2 * PAGE_SIZE_TEST, 'second page = 2*PAGE_SIZE');
});

test('Pagination', 'fewer than PAGE_SIZE papers shows all', () => {
  const all = makePapers(7);
  assertLength(getPageSlice(all, 0), 7, 'all 7 shown when fewer than PAGE_SIZE');
});

test('Pagination', 'load more does not exceed total paper count', () => {
  const all = makePapers(25);
  const slice = getPageSlice(all, 1); // would be 40, but only 25 exist
  assertLength(slice, 25, 'capped at total count');
});


// ════════════════════════════════════════════════════════════
//  SECTION 12 — Citation velocity helpers
// ════════════════════════════════════════════════════════════

// Replicated from index.html — update both if logic changes
function citationVelocityTest(paper) {
  const count   = paper.citationCount || 0;
  const pubYear = paper.publicationDate
    ? new Date(paper.publicationDate).getFullYear()
    : (paper.year || null);
  if (!pubYear) return 0;
  const yearsOld = Math.max(1, new Date().getFullYear() - pubYear + 1);
  return count / yearsOld;
}

function velocityLabelTest(paper) {
  const v = citationVelocityTest(paper);
  if (v >= 20) return 'trending';
  if (v >= 5)  return 'growing';
  return 'stable';
}

const currentYear = new Date().getFullYear();

test('Citation Velocity', 'paper with 100 citations in current year is trending', () => {
  const p = { citationCount: 100, year: currentYear };
  // yearsOld = max(1, currentYear - currentYear + 1) = 1 → 100/1 = 100 ≥ 20
  assertEqual(velocityLabelTest(p), 'trending', 'current-year paper with 100 citations = trending');
});

test('Citation Velocity', 'old paper with low citation rate is stable', () => {
  // 30 citations over 10+ years = ~2.7/yr < 5
  const p = { citationCount: 30, year: currentYear - 10 };
  assertEqual(velocityLabelTest(p), 'stable', '30 cites over 10+ years = stable');
});

test('Citation Velocity', 'paper with 0 citations is stable', () => {
  const p = { citationCount: 0, year: 2020 };
  assertEqual(velocityLabelTest(p), 'stable', '0 citations = stable');
});

test('Citation Velocity', 'paper with no year returns 0 velocity', () => {
  const p = { citationCount: 500 }; // no year, no publicationDate
  assertEqual(citationVelocityTest(p), 0, 'missing year = 0 velocity');
});

test('Citation Velocity', 'paper in growing range', () => {
  // 50 citations, published 5 years ago → 50/6 ≈ 8.3/yr → growing
  const p = { citationCount: 50, year: currentYear - 5 };
  assertEqual(velocityLabelTest(p), 'growing', '~8/yr = growing');
});

test('Citation Velocity', 'publicationDate takes precedence over year', () => {
  // citationCount=25, published exactly currentYear → velocity = 25/1 = 25 ≥ 20 → trending
  const today = new Date().toISOString().slice(0, 10);
  const p = { citationCount: 25, year: 2000, publicationDate: today };
  assertEqual(velocityLabelTest(p), 'trending', 'publicationDate wins over year field');
});


// ════════════════════════════════════════════════════════════
//  SECTION 13 — New filter functions
// ════════════════════════════════════════════════════════════

function applyInflCitationFilter(arr, min) {
  if (!min || min === 0) return arr;
  return arr.filter(p => (p.influentialCitationCount || 0) >= min);
}

function applyVelocityFilter(arr, v) {
  if (!v || v === 'any') return arr;
  return arr.filter(p => velocityLabelTest(p) === v);
}

function applyOpenAccessFilter(arr, oa) {
  if (!oa) return arr;
  return arr.filter(p => !!p.isOpenAccess);
}

function applyPubTypeFilter(arr, type) {
  if (!type || type === 'all') return arr;
  return arr.filter(p => {
    const venueType = (p.publicationVenue?.type || '').toLowerCase();
    if (type === 'journal')    return venueType.includes('journal');
    if (type === 'conference') return venueType.includes('conference') || venueType.includes('workshop');
    if (type === 'preprint')   return venueType.includes('preprint') || venueType.includes('arxiv') ||
                                      (p.externalIds?.ArXiv && !venueType);
    return true;
  });
}

function applyFieldsFilter(arr, fields) {
  if (!fields || fields.length === 0) return arr;
  const fLower = fields.map(f => f.toLowerCase());
  return arr.filter(p =>
    (p.fieldsOfStudy || []).some(f => fLower.includes(f.toLowerCase()))
  );
}

const newFilterPapers = [
  {
    paperId: 'n1',
    citationCount: 200, influentialCitationCount: 20,
    year: currentYear - 2, isOpenAccess: true,
    publicationVenue: { type: 'journal', name: 'Nature' },
    fieldsOfStudy: ['Computer Science', 'Psychology'],
  },
  {
    paperId: 'n2',
    citationCount: 5, influentialCitationCount: 2,
    year: 2015, isOpenAccess: false,
    publicationVenue: { type: 'conference', name: 'HRI 2015' },
    fieldsOfStudy: ['Robotics'],
  },
  {
    paperId: 'n3',
    citationCount: 0, influentialCitationCount: 0,
    year: currentYear, isOpenAccess: false,
    publicationVenue: null,
    externalIds: { ArXiv: '2301.12345' },
    fieldsOfStudy: ['Psychology'],
  },
];

test('New Filters', 'applyInflCitationFilter min=0 returns all', () => {
  assertLength(applyInflCitationFilter(newFilterPapers, 0), 3, 'min=0 = all');
});

test('New Filters', 'applyInflCitationFilter min=10 filters correctly', () => {
  const res = applyInflCitationFilter(newFilterPapers, 10);
  assertLength(res, 1, 'only n1 has ≥10 influential citations');
  assertEqual(res[0].paperId, 'n1', 'correct paper');
});

test('New Filters', 'applyVelocityFilter any returns all', () => {
  assertLength(applyVelocityFilter(newFilterPapers, 'any'), 3, 'any = all');
});

test('New Filters', 'applyVelocityFilter trending returns only trending papers', () => {
  // n1: 200 cites / 3 yrs ≈ 67/yr → trending
  // n3: 0 cites → stable
  const res = applyVelocityFilter(newFilterPapers, 'trending');
  assert(res.some(p => p.paperId === 'n1'), 'n1 is trending');
  assert(!res.some(p => p.paperId === 'n2'), 'n2 is not trending');
});

test('New Filters', 'applyOpenAccessFilter false returns all', () => {
  assertLength(applyOpenAccessFilter(newFilterPapers, false), 3, 'false = all');
});

test('New Filters', 'applyOpenAccessFilter true returns only OA papers', () => {
  const res = applyOpenAccessFilter(newFilterPapers, true);
  assertLength(res, 1, 'one OA paper');
  assertEqual(res[0].paperId, 'n1', 'n1 is OA');
});

test('New Filters', 'applyPubTypeFilter all returns all', () => {
  assertLength(applyPubTypeFilter(newFilterPapers, 'all'), 3, 'all = all');
});

test('New Filters', 'applyPubTypeFilter journal returns only journal papers', () => {
  const res = applyPubTypeFilter(newFilterPapers, 'journal');
  assertLength(res, 1, 'one journal paper');
  assertEqual(res[0].paperId, 'n1', 'n1 is a journal paper');
});

test('New Filters', 'applyPubTypeFilter conference returns only conference papers', () => {
  const res = applyPubTypeFilter(newFilterPapers, 'conference');
  assertLength(res, 1, 'one conference paper');
  assertEqual(res[0].paperId, 'n2', 'n2 is a conference paper');
});

test('New Filters', 'applyFieldsFilter empty returns all', () => {
  assertLength(applyFieldsFilter(newFilterPapers, []), 3, 'empty fields = all');
});

test('New Filters', 'applyFieldsFilter Computer Science returns matching papers', () => {
  const res = applyFieldsFilter(newFilterPapers, ['Computer Science']);
  assertLength(res, 1, 'one CS paper');
  assertEqual(res[0].paperId, 'n1', 'n1 has Computer Science field');
});

test('New Filters', 'applyFieldsFilter multi-field returns union', () => {
  // Robotics OR Psychology → n2 and n3 (both have Psychology or Robotics)
  const res = applyFieldsFilter(newFilterPapers, ['Robotics', 'Psychology']);
  assert(res.length >= 2, 'at least 2 papers match Robotics or Psychology');
});

test('New Filters', 'applyFieldsFilter is case-insensitive', () => {
  const res = applyFieldsFilter(newFilterPapers, ['computer science']);
  assertLength(res, 1, 'case-insensitive match works');
  assertEqual(res[0].paperId, 'n1', 'correct paper');
});


// ════════════════════════════════════════════════════════════
//  SECTION 14 — New sort options (influential, trending)
// ════════════════════════════════════════════════════════════

// Extends the existing applySortOrder test helper
function applySortOrderFull(arr, order) {
  const a = arr.slice();
  if (order === 'newest') {
    return a.sort((x, y) => {
      const dx = x.publicationDate || (x.year ? `${x.year}-12-31` : '0000-01-01');
      const dy = y.publicationDate || (y.year ? `${y.year}-12-31` : '0000-01-01');
      return dy.localeCompare(dx);
    });
  }
  if (order === 'oldest') {
    return a.sort((x, y) => {
      const dx = x.publicationDate || (x.year ? `${x.year}-01-01` : '9999-12-31');
      const dy = y.publicationDate || (y.year ? `${y.year}-01-01` : '9999-12-31');
      return dx.localeCompare(dy);
    });
  }
  if (order === 'relevance') return a.sort((x, y) => y.score - x.score);
  if (order === 'cited')     return a.sort((x, y) => (y.citationCount || 0) - (x.citationCount || 0));
  if (order === 'influential') return a.sort((x, y) => (y.influentialCitationCount || 0) - (x.influentialCitationCount || 0));
  if (order === 'trending')  return a.sort((x, y) => citationVelocityTest(y) - citationVelocityTest(x));
  return a;
}

const sortablePapersFull = [
  { paperId: 'f1', score: 5, year: 2023, publicationDate: '2023-06-01', citationCount: 50,  influentialCitationCount: 20 },
  { paperId: 'f2', score: 3, year: 2021, publicationDate: '2021-03-15', citationCount: 200, influentialCitationCount: 5  },
  { paperId: 'f3', score: 1, year: currentYear, publicationDate: `${currentYear}-01-01`, citationCount: 80,  influentialCitationCount: 30 },
];

test('New Sort Options', 'influential sort puts highest influentialCitationCount first', () => {
  const res = applySortOrderFull(sortablePapersFull, 'influential');
  assertEqual(res[0].paperId, 'f3', 'f3 has most influential citations (30)');
  assertEqual(res[2].paperId, 'f2', 'f2 has fewest influential citations (5)');
});

test('New Sort Options', 'trending sort puts highest citation velocity first', () => {
  // f3: 80 cites in 1 year = 80/yr
  // f1: 50 cites in ~3 years ≈ 17/yr
  // f2: 200 cites in ~5 years ≈ 40/yr
  const res = applySortOrderFull(sortablePapersFull, 'trending');
  assertEqual(res[0].paperId, 'f3', 'f3 has highest velocity (80+/yr)');
});

test('New Sort Options', 'sort does not mutate input array', () => {
  const original = [...sortablePapersFull];
  applySortOrderFull(sortablePapersFull, 'influential');
  for (let i = 0; i < original.length; i++) {
    assertEqual(sortablePapersFull[i].paperId, original[i].paperId, `input[${i}] unchanged`);
  }
});

test('New Sort Options', 'existing cited sort still works after adding new sorts', () => {
  const res = applySortOrderFull(sortablePapersFull, 'cited');
  assertEqual(res[0].paperId, 'f2', 'f2 has most total citations (200)');
  assertEqual(res[2].paperId, 'f1', 'f1 has fewest total citations (50)');
});


// ════════════════════════════════════════════════════════════
//  SECTION 15 — Smart Relevance Learning Algorithm
//  Tests pure functions only (Firebase calls excluded).
// ════════════════════════════════════════════════════════════

// ── Mirror STOP_WORDS from index.html ────────────────────────
const STOP_WORDS_TEST = new Set([
  'the','a','an','and','or','but','in','on','at','to','for','of','with','by',
  'from','as','is','are','was','were','be','been','being','have','has','had',
  'do','does','did','will','would','could','should','may','might','this','that',
  'these','those','it','its','we','our','they','their','study','paper','research',
  'using','used','results','show','shows','showed','approach','method','methods',
  'system','based','new','also','can','two','one','both','between','more','most',
  'such','than','when','which','who','how','data','model','propose','proposed',
  'present','demonstrate','find','found','analysis','evaluate','evaluation',
  'provide','different','task','tasks','work','works','high','large','small',
  'number','recent','review','effect','effects','related','across','within',
  'toward','through','during','while','where','other','each','into','over',
]);

function extractKeywordsTest(title, abstract, topN = 3) {
  const text   = `${title} ${title} ${abstract}`.toLowerCase();
  const tokens = text.split(/[^a-z]+/).filter(w => w.length >= 4 && !STOP_WORDS_TEST.has(w));
  const freq   = {};
  for (const t of tokens) freq[t] = (freq[t] || 0) + 1;
  return Object.entries(freq)
    .sort((a, b) => b[1] - a[1])
    .slice(0, topN)
    .map(([word]) => word);
}

// ── extractKeywords tests ─────────────────────────────────────

test('Learning Algorithm', 'extractKeywords removes stop words', () => {
  const result = extractKeywordsTest('The Study of Robots', 'This paper is about robots and the study', 3);
  assert(!result.includes('the'), 'should not include "the"');
  assert(!result.includes('study'), 'should not include "study" (stop word)');
  assert(!result.includes('paper'), 'should not include "paper" (stop word)');
});

test('Learning Algorithm', 'extractKeywords respects topN limit', () => {
  const result = extractKeywordsTest('social robots human interaction priming contagion', '', 3);
  assertEqual(result.length, 3, 'should return exactly 3 keywords');
});

test('Learning Algorithm', 'extractKeywords weights title higher than abstract', () => {
  // "robot" appears 2x in title (doubled) + 1x in abstract = 3x
  // "emotion" appears only 1x in abstract = 1x
  const result = extractKeywordsTest('robot interaction robot', 'emotion drives human behavior', 2);
  assertEqual(result[0], 'robot', 'title word "robot" should rank higher than abstract-only word');
});

test('Learning Algorithm', 'extractKeywords filters short words', () => {
  const result = extractKeywordsTest('AI robots HCI', 'HRI is key for UX', 5);
  assert(result.every(w => w.length >= 4), 'all extracted words should be ≥4 chars');
});

test('Learning Algorithm', 'extractKeywords handles empty strings', () => {
  const result = extractKeywordsTest('', '', 3);
  assertEqual(result.length, 0, 'empty input yields no keywords');
});

// ── computeSignalScore tests ──────────────────────────────────

function computeSignalScoreTest(signal) {
  if (!signal) return 0;
  const updatedAt = signal._fakeDate || new Date(0);
  const daysAgo   = (Date.now() - updatedAt.getTime()) / (1000 * 60 * 60 * 24);
  const recency   = daysAgo <= 7 ? 1.0 : daysAgo <= 30 ? 0.7 : 0.4;
  let raw = 0;
  if (signal.liked)    raw += 3;
  if (signal.saved)    raw += 2;
  if (signal.removed)  raw -= 5;
  if (signal.expanded) raw += 1;
  if (signal.clicked)  raw += 2;
  raw += Math.min(signal.secondsVisible || 0, 120) / 10 * 0.5;
  return raw * recency;
}

test('Learning Algorithm', 'computeSignalScore: liked + saved = +5', () => {
  const score = computeSignalScoreTest({ liked: true, saved: true, _fakeDate: new Date() });
  assertEqual(score, 5, 'liked(+3) + saved(+2) = 5 with full recency');
});

test('Learning Algorithm', 'computeSignalScore: removed = strong negative', () => {
  const score = computeSignalScoreTest({ removed: true, _fakeDate: new Date() });
  assertEqual(score, -5, 'removed should give -5');
});

test('Learning Algorithm', 'computeSignalScore: recency reduces old signals', () => {
  const recent = computeSignalScoreTest({ liked: true, _fakeDate: new Date() });
  const old31  = computeSignalScoreTest({ liked: true, _fakeDate: new Date(Date.now() - 31*24*60*60*1000) });
  assert(recent > old31, 'recent signal should score higher than 31-day-old signal');
  assertEqual(old31, 3 * 0.4, '31+ days old gets 40% recency weight');
});

test('Learning Algorithm', 'computeSignalScore: time on screen capped at 120s', () => {
  const capped  = computeSignalScoreTest({ secondsVisible: 300, _fakeDate: new Date() });
  const maxTime = computeSignalScoreTest({ secondsVisible: 120, _fakeDate: new Date() });
  assertEqual(capped, maxTime, 'time cap at 120s prevents unbounded score');
  assertEqual(maxTime, 120 / 10 * 0.5, '120s = 6 points');
});

test('Learning Algorithm', 'computeSignalScore: no signal = 0', () => {
  assertEqual(computeSignalScoreTest(null), 0, 'null signal returns 0');
});

// ── scoreLearnedKeywords tests ────────────────────────────────

function scoreLearnedKeywordsTest(paper, learnedKws) {
  if (!learnedKws.length) return 0;
  const text = `${paper.title || ''} ${paper.abstract || ''}`.toLowerCase();
  let boost  = 0;
  for (const lk of learnedKws) {
    if (text.includes(lk.text.toLowerCase())) boost += lk.weight * 0.3;
  }
  return Math.min(2, boost);
}

test('Learning Algorithm', 'scoreLearnedKeywords: matching keyword gives boost', () => {
  const paper   = { title: 'Emotional Contagion in Robots', abstract: '' };
  const learned = [{ text: 'emotional', weight: 1.0 }, { text: 'contagion', weight: 1.0 }];
  const boost   = scoreLearnedKeywordsTest(paper, learned);
  assert(boost > 0, 'matching learned keyword should give positive boost');
});

test('Learning Algorithm', 'scoreLearnedKeywords: no match = 0', () => {
  const paper   = { title: 'Quantum Physics', abstract: 'Laser beams.' };
  const learned = [{ text: 'robots', weight: 1.5 }];
  assertEqual(scoreLearnedKeywordsTest(paper, learned), 0, 'no match returns 0');
});

test('Learning Algorithm', 'scoreLearnedKeywords: capped at 2.0', () => {
  const paper   = { title: 'robots emotions priming contagion social', abstract: 'robots emotions priming' };
  const learned = Array(10).fill(null).map((_, i) => ({ text: ['robots','emotions','priming','contagion','social'][i % 5], weight: 3.0 }));
  const boost   = scoreLearnedKeywordsTest(paper, learned);
  assert(boost <= 2, 'boost should be capped at 2.0');
});

test('Learning Algorithm', 'scoreLearnedKeywords: empty learned list returns 0', () => {
  const paper = { title: 'Social Robots', abstract: 'Study of robots.' };
  assertEqual(scoreLearnedKeywordsTest(paper, []), 0, 'empty learned list gives 0');
});

// ── pickWildcard tests ────────────────────────────────────────

function pickWildcardTest(allPapersArr, alreadyShown) {
  const shownIds   = new Set(alreadyShown.map(p => p.paperId));
  const candidates = allPapersArr
    .filter(p => !shownIds.has(p.paperId) && p.score <= 2 && (p.influentialCitationCount || 0) >= 3)
    .sort((a, b) => (b.influentialCitationCount || 0) - (a.influentialCitationCount || 0));
  if (!candidates.length) return null;
  return { ...candidates[0], isWildcard: true };
}

test('Learning Algorithm', 'pickWildcard: picks low-score high-citation paper', () => {
  const all = [
    { paperId: 'a', score: 5, influentialCitationCount: 100 }, // high score — not a wildcard candidate
    { paperId: 'b', score: 1, influentialCitationCount: 15 },  // low score, cited — good wildcard
    { paperId: 'c', score: 2, influentialCitationCount: 5 },   // low score, cited — ok wildcard
    { paperId: 'd', score: 1, influentialCitationCount: 0 },   // low score, not cited — skip
  ];
  const wildcard = pickWildcardTest(all, []);
  assertEqual(wildcard?.paperId, 'b', 'should pick paper b (highest infl. citations among low-score papers)');
  assert(wildcard?.isWildcard === true, 'should be tagged as wildcard');
});

test('Learning Algorithm', 'pickWildcard: returns null if no candidates', () => {
  const all = [
    { paperId: 'a', score: 5, influentialCitationCount: 100 }, // high score, not a candidate
    { paperId: 'b', score: 1, influentialCitationCount: 0 },   // low citations, not a candidate
  ];
  const wildcard = pickWildcardTest(all, []);
  assertEqual(wildcard, null, 'returns null when no suitable wildcard exists');
});

test('Learning Algorithm', 'pickWildcard: excludes already-shown papers', () => {
  const all = [
    { paperId: 'a', score: 1, influentialCitationCount: 20 },
    { paperId: 'b', score: 1, influentialCitationCount: 10 },
  ];
  const wildcard = pickWildcardTest(all, [{ paperId: 'a' }]);
  assertEqual(wildcard?.paperId, 'b', 'should skip paper a (already shown)');
});


// ════════════════════════════════════════════════════════════
//  SECTION 16 — Reading List logic
//  Tests the addToReadingList / removeFromReadingList contract
//  and the feed-exclusion rule — all in pure JS, no DOM.
// ════════════════════════════════════════════════════════════

// ── Standalone Reading List helpers (mirroring index.html logic) ──

function makeReadingList() { return []; }

function rlAdd(list, paper) {
  if (!paper) return list;
  if (list.some(e => e.paper.paperId === paper.paperId)) return list; // no duplicates
  return [{ paper, likedAt: new Date().toISOString() }, ...list];    // newest first
}

function rlRemove(list, paperId) {
  return list.filter(e => e.paper.paperId !== paperId);
}

function rlContains(list, paperId) {
  return list.some(e => e.paper.paperId === paperId);
}

// Simulates the feed-exclusion rule in applyFiltersAndSort():
// papers already in the Reading List are hidden from the main feed.
function rlExcludeFeed(allPapers, readingList) {
  return allPapers.filter(p => !rlContains(readingList, p.paperId));
}

function makePaper(id, title = 'Test Paper') {
  return { paperId: id, title, score: 3, authors: [], abstract: '' };
}

// ── Tests ──

test('Reading List', 'addToReadingList: adds paper to empty list', () => {
  const paper = makePaper('p1');
  const list = rlAdd(makeReadingList(), paper);
  assertLength(list, 1, 'should have 1 entry');
  assertEqual(list[0].paper.paperId, 'p1', 'entry should be p1');
});

test('Reading List', 'addToReadingList: prepends (newest first)', () => {
  let list = makeReadingList();
  list = rlAdd(list, makePaper('p1'));
  list = rlAdd(list, makePaper('p2'));
  assertEqual(list[0].paper.paperId, 'p2', 'p2 was added last, should be first');
  assertEqual(list[1].paper.paperId, 'p1', 'p1 was added first, should be second');
});

test('Reading List', 'addToReadingList: ignores duplicate paper', () => {
  let list = makeReadingList();
  list = rlAdd(list, makePaper('p1'));
  list = rlAdd(list, makePaper('p1')); // add same paper again
  assertLength(list, 1, 'duplicate should not be added');
});

test('Reading List', 'addToReadingList: records likedAt timestamp', () => {
  const before = Date.now();
  const list = rlAdd(makeReadingList(), makePaper('p1'));
  const after = Date.now();
  const ts = new Date(list[0].likedAt).getTime();
  assert(ts >= before && ts <= after, 'likedAt should be a recent timestamp');
});

test('Reading List', 'addToReadingList: null paper is a no-op', () => {
  const list = rlAdd(makeReadingList(), null);
  assertLength(list, 0, 'null paper should not add an entry');
});

test('Reading List', 'removeFromReadingList: removes correct paper', () => {
  let list = makeReadingList();
  list = rlAdd(list, makePaper('p1'));
  list = rlAdd(list, makePaper('p2'));
  list = rlRemove(list, 'p1');
  assertLength(list, 1, 'should have 1 entry after removal');
  assert(!rlContains(list, 'p1'), 'p1 should be gone');
  assert(rlContains(list, 'p2'), 'p2 should remain');
});

test('Reading List', 'removeFromReadingList: removing non-existent id is safe', () => {
  let list = makeReadingList();
  list = rlAdd(list, makePaper('p1'));
  list = rlRemove(list, 'does-not-exist');
  assertLength(list, 1, 'list length should be unchanged');
});

test('Reading List', 'removeFromReadingList: does NOT affect like signal (userActions independent)', () => {
  // Simulates the contract: RL removal must not touch userActions
  const userActions = { p1: { liked: true, saved: false } };
  let list = makeReadingList();
  list = rlAdd(list, makePaper('p1'));
  list = rlRemove(list, 'p1');
  // userActions must be untouched — RL is purely a UI queue
  assert(userActions.p1.liked === true, 'like signal must be preserved after RL removal');
  assertLength(list, 0, 'RL should be empty');
});

test('Reading List', 'feed exclusion: liked paper disappears from feed', () => {
  const papers = [makePaper('p1'), makePaper('p2'), makePaper('p3')];
  let rl = makeReadingList();
  rl = rlAdd(rl, makePaper('p1'));
  const feed = rlExcludeFeed(papers, rl);
  assertLength(feed, 2, 'feed should have 2 papers (p1 excluded)');
  assert(!feed.some(p => p.paperId === 'p1'), 'p1 should be excluded from feed');
  assert(feed.some(p => p.paperId === 'p2'), 'p2 should still be in feed');
  assert(feed.some(p => p.paperId === 'p3'), 'p3 should still be in feed');
});

test('Reading List', 'feed exclusion: empty RL shows all papers', () => {
  const papers = [makePaper('p1'), makePaper('p2')];
  const feed = rlExcludeFeed(papers, makeReadingList());
  assertLength(feed, 2, 'all papers should appear when RL is empty');
});

test('Reading List', 'feed exclusion: multiple RL entries excluded', () => {
  const papers = [makePaper('p1'), makePaper('p2'), makePaper('p3')];
  let rl = makeReadingList();
  rl = rlAdd(rl, makePaper('p1'));
  rl = rlAdd(rl, makePaper('p3'));
  const feed = rlExcludeFeed(papers, rl);
  assertLength(feed, 1, 'only p2 should remain in feed');
  assertEqual(feed[0].paperId, 'p2', 'remaining paper should be p2');
});

test('Reading List', 'save→RL contract: saving adds paper (not just like)', () => {
  // Simulates the fixed handlePaperAction save branch:
  // when newVal===true, addToReadingList must be called.
  // We verify the logic contract independently.
  const paper = makePaper('p1');
  const userActions = { p1: { saved: false } };
  const newVal = !userActions.p1.saved; // toggle: false→true
  let rl = makeReadingList();
  if (newVal && paper) {
    rl = rlAdd(rl, paper);
  }
  assert(rlContains(rl, 'p1'), 'saving a paper should add it to Reading List');
});

test('Reading List', 'save→RL contract: un-saving does NOT re-add to RL', () => {
  // Un-saving (newVal===false) must not call addToReadingList
  const paper = makePaper('p1');
  const userActions = { p1: { saved: true } };
  const newVal = !userActions.p1.saved; // toggle: true→false (un-save)
  let rl = makeReadingList();
  if (newVal && paper) {
    rl = rlAdd(rl, paper); // this branch should NOT be reached
  }
  assert(!rlContains(rl, 'p1'), 'un-saving should not add paper to Reading List');
});

test('Reading List', 'like→RL contract: liking does NOT add to Reading List (stays in feed)', () => {
  // P2-6 change: Like is now a pure learning signal — card stays in feed, NOT added to RL.
  // Only Save moves a paper to the Reading List.
  const paper = makePaper('p1');
  const userActions = { p1: { liked: false } };
  const newVal = !userActions.p1.liked;
  let rl = makeReadingList();
  // Like branch: update card display only — do NOT call rlAdd
  if (newVal && paper) {
    // (addLearnedKeywords + rescore + updateCardActionDisplay — no RL add)
    userActions.p1.liked = true;
  }
  assert(!rlContains(rl, 'p1'), 'liking a paper should NOT add it to Reading List');
  assertEqual(userActions.p1.liked, true, 'like signal should be set');
});

test('Reading List', 'like keeps paper in feed (no animateCardOut)', () => {
  // After liking, the paper remains in the feed (not excluded by rlExcludeFeed)
  const paper = makePaper('p1');
  const allPapers = [makePaper('p2'), paper];
  const rl = makeReadingList(); // RL is empty — like does not add to it
  const feed = rlExcludeFeed(allPapers, rl);
  assertLength(feed, 2, 'p1 should remain in feed after like (RL is empty)');
});

test('Reading List', 'undo save: removes from RL, un-saves, paper returns to feed', () => {
  // Simulates the undo callback from showToastWithUndo for save action
  const paper = makePaper('p1');
  const allPapers = [makePaper('p2'), paper];
  const userActions = { p1: { saved: true } };

  // After save: paper is in RL, not in feed
  let rl = makeReadingList();
  rl = rlAdd(rl, paper);
  let feed = rlExcludeFeed(allPapers, rl);
  assertLength(feed, 1, 'p1 should be out of feed after saving');

  // Undo: remove from RL, un-save
  rl = rlRemove(rl, 'p1');
  userActions.p1.saved = false;
  feed = rlExcludeFeed(allPapers, rl);

  assertLength(feed, 2, 'p1 should be back in feed after undo');
  assert(!rlContains(rl, 'p1'), 'p1 should be removed from RL after undo');
  assertEqual(userActions.p1.saved, false, 'save signal should be false after undo');
});

test('Reading List', 'migration v3: only SAVED papers are back-filled (liked stays in feed)', () => {
  // Simulates migrateOldLikesToReadingList() with v3 logic (P2-6 change).
  // Like is now a pure feed signal — only saved papers belong in the RL.
  const allPapers = [makePaper('p1'), makePaper('p2'), makePaper('p3')];
  const userActions = {
    p1: { liked: true,  saved: false }, // liked only — should NOT migrate to RL
    p2: { liked: false, saved: true  }, // saved — SHOULD migrate to RL
    p3: { liked: false, saved: false }, // neither — should NOT migrate
  };
  let rl = makeReadingList();

  for (const [paperId, actions] of Object.entries(userActions)) {
    // v3: only saved papers go to RL
    if (actions.saved && !rlContains(rl, paperId)) {
      const paper = allPapers.find(p => p.paperId === paperId);
      if (paper) rl = [...rl, { paper, likedAt: new Date().toISOString() }];
    }
  }

  assertLength(rl, 1, 'migration v3 should only import p2 (saved)');
  assert(!rlContains(rl, 'p1'), 'p1 (liked only) should NOT be in RL — like stays in feed');
  assert(rlContains(rl, 'p2'), 'p2 (saved) should be in RL after migration');
  assert(!rlContains(rl, 'p3'), 'p3 (neither) should NOT be in RL after migration');
});

// ════════════════════════════════════════════════════════════
//  SECTION 17 — Panel toggle behaviour
//  Tests the openPanel / closeAllPanels toggle-to-close contract.
//  Uses lightweight DOM stubs — no full app needed.
// ════════════════════════════════════════════════════════════

// ── Minimal DOM stubs for panel toggle tests ─────────────────
function makePanelDOM() {
  // Returns a stub environment with open/close/isOpen/isActive helpers
  const panelClasses = new Set();
  const btnClasses   = new Set();
  const panelEl = { classList: {
    add(c)      { panelClasses.add(c); },
    remove(c)   { panelClasses.delete(c); },
    contains(c) { return panelClasses.has(c); },
  }};
  const btnEl = { classList: {
    add(c)      { btnClasses.add(c); },
    remove(c)   { btnClasses.delete(c); },
    contains(c) { return btnClasses.has(c); },
  }};

  function openPanel() {
    // mirrors openPanel(): closeAll first, then open target
    panelEl.classList.remove('open');
    btnEl.classList.remove('active');
    panelEl.classList.add('open');
    btnEl.classList.add('active');
  }
  function closeAllPanels() {
    panelEl.classList.remove('open');
    btnEl.classList.remove('active');
  }
  return {
    panelEl, btnEl,
    open:     openPanel,
    close:    closeAllPanels,
    isOpen:   () => panelEl.classList.contains('open'),
    isActive: () => btnEl.classList.contains('active'),
  };
}

test('Panel Toggle', 'openPanel adds .open class to panel', () => {
  const env = makePanelDOM();
  env.open();
  assert(env.isOpen(), 'panel should have .open class after openPanel()');
});

test('Panel Toggle', 'openPanel adds .active class to toggle button', () => {
  const env = makePanelDOM();
  env.open();
  assert(env.isActive(), 'button should have .active class after openPanel()');
});

test('Panel Toggle', 'closeAllPanels removes .open class', () => {
  const env = makePanelDOM();
  env.open();
  env.close();
  assert(!env.isOpen(), 'panel should not have .open after closeAllPanels()');
});

test('Panel Toggle', 'closeAllPanels removes .active class from button', () => {
  const env = makePanelDOM();
  env.open();
  env.close();
  assert(!env.isActive(), 'button should not have .active after closeAllPanels()');
});

test('Panel Toggle', 'clicking open panel closes it (toggle-to-close contract)', () => {
  const env = makePanelDOM();
  env.open();
  assert(env.isOpen(), 'panel should be open');
  // Simulate button click when already open — check flag then close
  if (env.isOpen()) { env.close(); } else { env.open(); }
  assert(!env.isOpen(), 'panel should be closed after second click');
  assert(!env.isActive(), 'button should be inactive after close');
});

test('Panel Toggle', 'opening a panel when another is open closes the first', () => {
  // Simulate two panels: keywords and insights
  const kw  = makePanelDOM();
  const ins = makePanelDOM();

  function closeAll() { kw.close(); ins.close(); }
  function openKeywords() { closeAll(); kw.panelEl.classList.add('open'); kw.btnEl.classList.add('active'); }
  function openInsights()  { closeAll(); ins.panelEl.classList.add('open'); ins.btnEl.classList.add('active'); }

  openKeywords();
  assert(kw.isOpen(),   'keywords panel should be open');
  assert(!ins.isOpen(), 'insights panel should be closed');

  openInsights();
  assert(!kw.isOpen(), 'keywords panel should be closed when insights opens');
  assert(ins.isOpen(), 'insights panel should now be open');
});

test('Panel Toggle', 'panel starts closed — no .open or .active on fresh state', () => {
  const env = makePanelDOM();
  assert(!env.isOpen(),   'panel should start without .open');
  assert(!env.isActive(), 'button should start without .active');
});


// ════════════════════════════════════════════════════════════
//  SECTION 18 — saveKeywords / loadKeywords localStorage fallback
//  Verifies the signed-out keyword persistence contract.
//  Uses an in-memory localStorage stub (no real browser storage).
// ════════════════════════════════════════════════════════════

const KEYWORDS_LOCAL_KEY_T = 'researchhub_keywords_local'; // must match index.html

function makeLocalStorageStub() {
  const store = {};
  return {
    getItem:    (k)    => (k in store ? store[k] : null),
    setItem:    (k, v) => { store[k] = String(v); },
    removeItem: (k)    => { delete store[k]; },
    _store: store,
  };
}

function saveKeywordsTest(keywords, currentUser, ls) {
  // Mirrors saveKeywords() signed-out branch from index.html
  if (!currentUser) {
    try { ls.setItem(KEYWORDS_LOCAL_KEY_T, JSON.stringify(keywords)); } catch(e) {}
  }
}

function loadKeywordsTest(ls, defaultKeywords) {
  // Mirrors loadKeywords() from index.html
  try {
    const saved = ls.getItem(KEYWORDS_LOCAL_KEY_T);
    return saved ? JSON.parse(saved) : defaultKeywords.map(k => ({ ...k }));
  } catch(e) {
    return defaultKeywords.map(k => ({ ...k }));
  }
}

test('Keywords localStorage', 'saveKeywords: signed-out writes to localStorage', () => {
  const ls = makeLocalStorageStub();
  const kws = [{ text: 'robots', active: true }];
  saveKeywordsTest(kws, null /* signed out */, ls);
  const raw = ls.getItem(KEYWORDS_LOCAL_KEY_T);
  assert(raw !== null, 'localStorage should have been written');
  const parsed = JSON.parse(raw);
  assertLength(parsed, 1, 'stored array should have 1 keyword');
  assertEqual(parsed[0].text, 'robots', 'stored keyword text should match');
});

test('Keywords localStorage', 'saveKeywords: signed-in does NOT write to localStorage', () => {
  const ls = makeLocalStorageStub();
  const kws = [{ text: 'robots', active: true }];
  saveKeywordsTest(kws, { uid: 'user1' } /* signed in */, ls);
  const raw = ls.getItem(KEYWORDS_LOCAL_KEY_T);
  assertEqual(raw, null, 'localStorage should be empty when signed in (Firestore is canonical)');
});

test('Keywords localStorage', 'loadKeywords: returns stored keywords if present', () => {
  const ls = makeLocalStorageStub();
  const kws = [{ text: 'priming', active: false }, { text: 'hri', active: true }];
  ls.setItem(KEYWORDS_LOCAL_KEY_T, JSON.stringify(kws));
  const loaded = loadKeywordsTest(ls, []);
  assertLength(loaded, 2, 'should load 2 keywords from localStorage');
  assertEqual(loaded[0].text, 'priming', 'first keyword text');
  assertEqual(loaded[1].active, true, 'second keyword active state');
});

test('Keywords localStorage', 'loadKeywords: returns defaults when nothing stored', () => {
  const ls = makeLocalStorageStub(); // empty
  const defaults = [{ text: 'social robots', active: true }];
  const loaded = loadKeywordsTest(ls, defaults);
  assertLength(loaded, 1, 'should return default keywords when localStorage is empty');
  assertEqual(loaded[0].text, 'social robots', 'should match default keyword');
});


// ════════════════════════════════════════════════════════════
//  SECTION 19 — One-shot UI tip guards
//  Verifies SCORE_TIP_SEEN_KEY and WILDCARD_TIP_SEEN_KEY
//  localStorage guard patterns (show-once semantics).
//  Reuses makeLocalStorageStub() from Section 18.
// ════════════════════════════════════════════════════════════

const SCORE_TIP_SEEN_KEY_T    = 'researchhub_score_tip_seen';
const WILDCARD_TIP_SEEN_KEY_T = 'researchhub_wildcard_tip_seen';

// Mirror the guard pattern from maybeShowScoreExplainer() in index.html
function shouldShowScoreTipTest(ls) {
  return !ls.getItem(SCORE_TIP_SEEN_KEY_T);
}
function markScoreTipSeenTest(ls) {
  ls.setItem(SCORE_TIP_SEEN_KEY_T, '1');
}

// Mirror the guard pattern for the wildcard tip in index.html
function shouldShowWildcardTipTest(ls) {
  return !ls.getItem(WILDCARD_TIP_SEEN_KEY_T);
}
function markWildcardTipSeenTest(ls) {
  ls.setItem(WILDCARD_TIP_SEEN_KEY_T, '1');
}

test('One-Shot Tips', 'score tip: shows on first visit (key absent)', () => {
  const ls = makeLocalStorageStub();
  assert(shouldShowScoreTipTest(ls), 'score tip should show when key is absent');
});

test('One-Shot Tips', 'score tip: does not show after dismiss (key set)', () => {
  const ls = makeLocalStorageStub();
  markScoreTipSeenTest(ls);
  assert(!shouldShowScoreTipTest(ls), 'score tip should not show once key is set');
});

test('One-Shot Tips', 'score tip: marking as seen is idempotent', () => {
  const ls = makeLocalStorageStub();
  markScoreTipSeenTest(ls);
  markScoreTipSeenTest(ls); // call twice
  assert(!shouldShowScoreTipTest(ls), 'tip should still be suppressed after double-mark');
});

test('One-Shot Tips', 'wildcard tip: shows on first visit (key absent)', () => {
  const ls = makeLocalStorageStub();
  assert(shouldShowWildcardTipTest(ls), 'wildcard tip should show when key is absent');
});

test('One-Shot Tips', 'wildcard tip: does not show after dismiss (key set)', () => {
  const ls = makeLocalStorageStub();
  markWildcardTipSeenTest(ls);
  assert(!shouldShowWildcardTipTest(ls), 'wildcard tip should not show once key is set');
});

test('One-Shot Tips', 'score tip and wildcard tip are independent guards', () => {
  const ls = makeLocalStorageStub();
  markScoreTipSeenTest(ls);
  // Score tip is suppressed; wildcard tip must still show (independent key)
  assert(!shouldShowScoreTipTest(ls),   'score tip should be suppressed');
  assert(shouldShowWildcardTipTest(ls), 'wildcard tip should still show (independent key)');
});


// ════════════════════════════════════════════════════════════
//  SECTION 20 — Like vs Save signal weights (P2-6 verification)
//  Pins the exact signal arithmetic after the Like/Save split.
//  Reuses computeSignalScoreTest() defined in Section 15.
// ════════════════════════════════════════════════════════════

test('Signal Weights', 'liked alone = +3 raw score (recency=1.0)', () => {
  const score = computeSignalScoreTest({ liked: true, _fakeDate: new Date() });
  assertEqual(score, 3, 'liked(+3) with full recency should equal 3');
});

test('Signal Weights', 'saved alone = +2 raw score (recency=1.0)', () => {
  const score = computeSignalScoreTest({ saved: true, _fakeDate: new Date() });
  assertEqual(score, 2, 'saved(+2) with full recency should equal 2');
});

test('Signal Weights', 'liked > saved (like is stronger positive signal)', () => {
  const liked = computeSignalScoreTest({ liked: true, _fakeDate: new Date() });
  const saved = computeSignalScoreTest({ saved: true, _fakeDate: new Date() });
  assert(liked > saved, `liked signal (${liked}) should be stronger than saved (${saved})`);
});

test('Signal Weights', 'liked + saved = +5 (they are additive)', () => {
  const score = computeSignalScoreTest({ liked: true, saved: true, _fakeDate: new Date() });
  assertEqual(score, 5, 'liked(+3) + saved(+2) = 5 when both set');
});

test('Signal Weights', 'like signal is independent of Reading List state (no RL field in signal)', () => {
  // computeSignalScore reads liked/saved/removed/expanded/clicked/secondsVisible only.
  // There is no 'inReadingList' field — RL is a pure UI queue, not a learning signal.
  const withRL    = computeSignalScoreTest({ liked: true, inReadingList: true,  _fakeDate: new Date() });
  const withoutRL = computeSignalScoreTest({ liked: true, inReadingList: false, _fakeDate: new Date() });
  assertEqual(withRL, withoutRL, 'inReadingList flag must not affect signal score');
});

test('Signal Weights', 'removed = -5, cancels liked+saved combined', () => {
  const score = computeSignalScoreTest({ removed: true, liked: true, saved: true, _fakeDate: new Date() });
  // removed(-5) + liked(+3) + saved(+2) = 0
  assertEqual(score, 0, 'removed(-5) + liked(+3) + saved(+2) = 0');
});


// ── Wire up the run button ───────────────────────────────────
document.getElementById('runBtn').addEventListener('click', runAll);

// Auto-run on load
runAll();
</script>
</body>
</html>
